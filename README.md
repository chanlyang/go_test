# GO学习

## 第一章 简介

### 1. 语言简介

Go语言（或 Golang）起源于 2007 年，并在 2009 年正式对外发布。Go 是非常年轻的一门语言，它的主要目标是“兼具 [Python](http://c.biancheng.net/python/) 等动态语言的开发速度和 C/[C++](http://c.biancheng.net/cplus/) 等编译型语言的性能与安全性”。

Go语言是编程语言设计的又一次尝试，是对类C语言的重大改进，它不但能让你访问底层操作系统，还提供了强大的网络编程和并发编程支持。Go语言的用途众多，可以进行网络编程、系统编程、并发编程、分布式编程。

Go语言的推出，旨在不损失应用程序性能的情况下降低代码的复杂性，具有“部署简单、并发性好、语言设计良好、执行性能好”等优势，目前国内诸多 IT 公司均已采用Go语言开发项目。

Go语言有时候被描述为“C 类似语言”，或者是“21 世纪的C语言”。Go 从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。

因为Go语言没有类和继承的概念，所以它和 [Java](http://c.biancheng.net/java/) 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说Go语言是一门混合型的语言。

此外，很多重要的开源项目都是使用Go语言开发的，其中包括 [Docker](http://c.biancheng.net/docker/)、Go-Ethereum、Thrraform 和 Kubernetes。

#### Go语言创始人

对语言进行评估时，明白设计者的动机以及语言要解决的问题很重要。Go语言出自 Ken Thompson 和 Rob Pike、Robert Griesemer 之手，他们都是计算机科学领域的重量级人物。

##### 1) Ken Thompson

贝尔实验室 Unix 团队成员，C语言、Unix 和 Plan 9 的创始人之一，在 20 世纪 70 年代，设计并实现了最初的 UNIX 操作系统，仅从这一点说，他对计算机科学的贡献怎么强调都不过分。他还与 Rob Pike 合作设计了 UTF-8 编码方案。

##### 2) Rob Pike

Go语言项目总负责人，贝尔实验室 Unix 团队成员，除帮助设计 UTF-8 外，还帮助开发了分布式多用户操作系统 Plan 9、Inferno 操作系统和 Limbo 编程语言，并与人合著了《The Unix Programming Environment》，对 UNIX 的设计理念做了正统的阐述。

##### 3) Robert Griesemer

就职于 Google，参与开发 Java HotSpot 虚拟机，对语言设计有深入的认识，并负责 Chrome 浏览器和 Node.js 使用的 Google V8 [JavaScript](http://c.biancheng.net/js/) 引擎的代码生成部分。

这些计算机科学领城的重量级人物设计Go语言的初衷是满足 Google 的需求。设计此语言花费了两年的时间，融入了整个团队多年的经验及对编程语言设计的深入认识。设计团队借鉴了 Pascal、Oberon 和C语言的设计智慧，同时让Go语言具备动态语言的便利性。因此，Go语言体现了经验丰富的计算机科学家的语言设计理念，是为全球最大的互联网公司之一设计的。

Go语言的所有设计者都说，设计Go语言是因为 C++ 给他们带来了挫败感。在 Google I/O 2012 的 Go 设计小组见面会上，Rob Pike 是这样说的：

> 我们做了大量的 C++ 开发，厌烦了等待编译完成，尽管这是玩笑，但在很大程度上来说也是事实。

#### Go 是编译型语言

Go 使用编译器来编译代码。编译器将源代码编译成二进制（或字节码）格式；在编译代码时，编译器检查错误、优化性能并输出可在不同平台上运行的二进制文件。要创建并运行 Go 程序，程序员必须执行如下步骤。

1. 使用文本编辑器创建 Go 程序；
2. 保存文件；
3. 编译程序；
4. 运行编译得到的可执行文件。


这不同于 Python、Ruby 和 JavaScript 等语言，它们不包含编译步骤。Go 自带了编译器，因此无须单独安装编译器。

#### 为什么要学习Go语言

如果你要创建系统程序，或者基于网络的程序，Go语言是很不错的选择。作为一种相对较新的语言，它是由经验丰富且受人尊敬的计算机科学家设计的，旨在应对创建大型并发网络程序面临的挑战。

在Go语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。

Go语言支持交叉编译，比如说你可以在运行 Linux 系统的计算机上开发可以在 Windows 上运行的应用程序。这是第一门完全支持 UTF-8 的编程语言，这不仅体现在它可以处理使用 UTF-8 编码的字符串，就连它的源码文件格式都是使用的 UTF-8 编码。Go语言做到了真正的国际化！

#### Go语言吉祥物

Go语言有一个吉祥物，在会议、文档页面和博文中，大多会包含下图所示的 Go Gopher，这是才华横溢的插画家 Renee French 设计的，她也是 Go 设计者之一 Rob Pike 的妻子。



![img](http://c.biancheng.net/uploads/allimg/180808/1-1PPQA9545W.jpg)

### 2. 语言的特性有哪些？

Go语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。

接下来从几个方面来具体介绍一下Go语言的特性。

#### 语法简单

抛开语法样式不谈，单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。

Go语言的语法处于简单和复杂的两极。C语言简单到你每写下一行代码，都能在脑中想象出编译后的模样，指令如何执行，内存如何分配，等等。而 C 的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Go 从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的世界。

Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性，我觉得是值得的。

将“++”、“--”从运算符降级为语句，保留指针，但默认阻止指针运算，带来的好处是显而易见的。还有，将切片和字典作为内置类型，从运行时的层面进行优化，这也算是一种“简单”。

#### 并发模型

时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。在这种情况下Go语言却一反常态做了件极大胆的事，从根本上将一切都并发化，运行时用 Goroutine 运行所有的一切，包括 main.main 入口函数。

可以说，Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然。

搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。

#### 内存分配

将一切并发化固然是好，但带来的问题同样很多。如何实现高并发下的内存分配和管理就是个难题。好在 Go 选择了 tcmalloc，它本就是为并发而设计的高性能内存分配组件。

可以说，内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。

在最近几个版本中，编译器优化卓有成效。它会竭力将对象分配在栈上，以降低垃圾回收压力，减少管理消耗，提升执行性能。可以说，除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。

#### 垃圾回收

垃圾回收一直是个难题。早年间，[Java](http://c.biancheng.net/java/) 就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。

相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难。

每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。尽管有了努力，当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。

#### 静态链接

Go 刚发布时，静态链接被当作优点宣传。只须编译后的一个可执行文件，无须附加任何东西就能部署。这似乎很不错，只是后来风气变了。连着几个版本，编译器都在完善动态库 buildmode 功能，场面一时变得有些尴尬。

暂不说未完工的 buildmode 模式，静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。

#### 标准库

功能完善、质量可靠的标准库为编程语言提供了充足动力。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。最关键的是，标准库有升级和修复保障，还能从运行时获得深层次优化的便利，这是第三方库所不具备的。

Go 标准库虽称不得完全覆盖，但也算极为丰富。其中值得称道的是 net/http，仅须简单几条语句就能实现一个高性能 Web Server，这从来都是宣传的亮点。更何况大批基于此的优秀第三方 Framework 更是将 Go 推到 Web/Microservice 开发标准之一的位置。

当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。

#### 工具链

完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。

内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器。

除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。

### 3. 语言为并发而生

在早期 CPU 都是以单核的形式顺序执行机器指令。Go语言的祖先C语言正是这种顺序编程语言的代表。顺序编程语言中的顺序是指：所有的指令都是以串行的方式执行，在相同的时刻有且仅有一个 CPU 在顺序执行程序的指令。

随着处理器技术的发展，单核时代以提升处理器频率来提高运行效率的方式遇到了瓶颈，单核 CPU 发展的停滞，给多核 CPU 的发展带来了机遇。相应地，编程语言也开始逐步向并行化的方向发展。

虽然一些编程语言的框架在不断地提高多核资源使用效率，例如 [Java](http://c.biancheng.net/java/) 的 Netty 等，但仍然需要开发人员花费大量的时间和精力搞懂这些框架的运行原理后才能熟练掌握。

作为程序员，要开发出能充分利用硬件资源的应用程序是一件很难的事情。现代计算机都拥有多个核，但是大部分编程语言都没有有效的工具让程序可以轻易利用这些资源。编程时需要写大量的线程同步代码来利用多个核，很容易导致错误。

Go语言正是在多核和网络化的时代背景下诞生的原生支持并发的编程语言。Go语言从底层原生支持并发，无须第三方库，开发人员可以很轻松地在编写程序时决定怎么使用 CPU 资源。

Go语言的并发是基于 goroutine 的，goroutine 类似于线程，但并非线程。可以将 goroutine 理解为一种虚拟线程。Go语言运行时会参与调度 goroutine，并将 goroutine 合理地分配到每个 CPU 中，最大限度地使用 CPU 性能。

多个 goroutine 中，Go语言使用通道（channel）进行通信，通道是一种内置的[数据结构](http://c.biancheng.net/data_structure/)，可以让用户在不同的 goroutine 之间同步发送具有类型的消息。这让编程模型更倾向于在 goroutine 之间发送消息，而不是让多个 goroutine 争夺同一个数据的使用权。

程序可以将需要并发的环节设计为生产者模式和消费者的模式，将数据放入通道。通道另外一端的代码将这些数据进行并发计算并返回结果，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180808/1-1PPQ001322K.jpg)

> 提示：Go语言通过通道可以实现多个 goroutine 之间内存共享。

【实例】生产者每秒生成一个字符串，并通过通道传给消费者，生产者使用两个 goroutine 并发运行，消费者在 main() 函数的 goroutine 中进行处理。

```go
package main

import (
        "fmt"
        "math/rand"
        "time"
)

// 数据生产者
func producer(header string, channel chan<- string) {
     // 无限循环, 不停地生产数据
     for {
            // 将随机数和字符串格式化为字符串发送给通道
            channel <- fmt.Sprintf("%s: %v", header, rand.Int31())
            // 等待1秒
            time.Sleep(time.Second)
        }
}

// 数据消费者
func customer(channel <-chan string) {
     // 不停地获取数据
     for {
            // 从通道中取出数据, 此处会阻塞直到信道中返回数据
            message := <-channel
            // 打印数据
            fmt.Println(message)
        }
}

func main() {
    // 创建一个字符串类型的通道
    channel := make(chan string)
    // 创建producer()函数的并发goroutine
    go producer("cat", channel)
    go producer("dog", channel)
    // 数据消费函数
    customer(channel)
}
```

运行结果：

```
dog: 2019727887
cat: 1298498081
dog: 939984059
cat: 1427131847
cat: 911902081
dog: 1474941318
dog: 140954425
cat: 336122540
cat: 208240456
dog: 646203300
```

对代码的分析：

- 第 03 行，导入格式化（fmt）、随机数（math/rand）、时间（time）包参与编译。
- 第 10 行，生产数据的函数，传入一个标记类型的字符串及一个只能写入的通道。
- 第 13 行，for{} 构成一个无限循环。
- 第 15 行，使用 rand.Int31() 生成一个随机数，使用 fmt.Sprintf() 函数将 header 和随机数格式化为字符串。
- 第 18 行，使用 time.Sleep() 函数暂停 1 秒再执行这个函数。如果在 goroutine 中执行时，暂停不会影响其他 goroutine 的执行。
- 第 23 行，消费数据的函数，传入一个只能写入的通道。
- 第 26 行，构造一个不断消费消息的循环。
- 第 28 行，从通道中取出数据。
- 第 31 行，将取出的数据进行打印。
- 第 35 行，程序的入口函数，总是在程序开始时执行。
- 第 37 行，实例化一个字符串类型的通道。
- 第 39 行和第 40 行，并发执行一个生产者函数，两行分别创建了这个函数搭配不同参数的两个 goroutine。
- 第 42 行，执行消费者函数通过通道进行数据消费。


整段代码中，没有线程创建，没有线程池也没有加锁，仅仅通过关键字 go 实现 goroutine，和通道实现数据交换。

### 4. 哪些项目使用Go语言开发？

所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，Go语言的简单、高效、并发特性吸引了众多传统语言开发者的加入，而且人数越来越多。

使用Go语言开发的开源项目非常多。早期的Go语言开源项目只是通过Go语言与传统项目进行C语言库绑定实现，例如 [Qt](http://c.biancheng.net/qt/)、Sqlite 等；后期的很多项目都使用Go语言进行重新原生实现，这个过程相对于其他语言要简单一些，这也促成了大量使用Go语言原生开发项目的出现。

下面列举的是原生使用Go语言进行开发的部分项目。

#### 1) [Docker](http://c.biancheng.net/docker/)

Docker 是一种操作系统层面的虚拟化技术，可以在操作系统和应用程序之间进行隔离，也可以称之为容器。Docker 可以在一台物理服务器上快速运行一个或多个实例。例如，启动一个 CentOS 操作系统，并在其内部命令行执行指令后结束，整个过程就像自己在操作系统一样高效。

项目链接：https://github.com/docker/docker

#### 2) Go语言

Go语言自己的早期源码使用C语言和[汇编语言](http://c.biancheng.net/asm/)写成。从 Go 1.5 版本后，完全使用Go语言自身进行编写。Go语言的源码对了解Go语言的底层调度有极大的参考意义，建议希望对Go语言有深入了解的读者读一读。

项目链接：https://github.com/golang/go

#### 3) Kubernetes

Google 公司开发的构建于 Docker 之上的容器调度服务，用户可以通过 Kubernetes 集群进行云端容器集群管理。系统会自动选取合适的工作节点来执行具体的容器集群调度处理工作。其核心概念是 Container Pod（容器仓）。

项目链接：https://github.com/kubernetes/kubernetes

#### 4) etcd

一款分布式、可靠的 KV 存储系统，可以快速进行云配置。由 CoreOS 开发并维护键值存储系统，它使用Go语言编写，并通过 Raft 一致性算法处理日志复制以保证强一致性。

项目链接：https://github.com/coreos/etcd

#### 5) beego

beego 是一个类似 [Python](http://c.biancheng.net/python/) 的 Tornado 框架，采用了 RESTFul 的设计思路，使用Go语言编写的一个极轻量级、高可伸缩性和高性能的 Web 应用框架。

项目链接：https://github.com/astaxie/beego

#### 6) martini

一款快速构建模块化的 Web 应用的Go语言框架。

项目链接：https://github.com/go-martini/martini

#### 7) codis

国产的优秀分布式 [Redis](http://c.biancheng.net/redis/) 解决方案。可以将 codis 理解成为 Web 服务领域的 Nginx，它实现了对 Redis 的反向代理和负载均衡。

项目链接：https://github.com/CodisLabs/codis

#### 8) delve

Go语言强大的调试器，被很多集成环境和编辑器整合。

项目链接：https://github.com/derekparker/delve

### 5. 哪些大公司正在使用Go语言

Go语言是谷歌在 2009 年发布的一款编程语言，自面世以来它以高效的开发效率和完美的运行速度迅速风靡全球，被誉为“21 世纪的C语言”。

现在越来越多的公司开始使用Go语言开发自己的服务，同时也诞生了很多使用Go语言开发的服务和应用，比如 [Docker](http://c.biancheng.net/docker/)、k8s 等，下面我们来看一下，有哪些大公司在使用Go语言。

#### 1) Google

作为创造了Go语言的 google 公司，当然会力挺Go语言了。Google 有很多基于 Go 开发的开源项目，比如 kubernets，docker，大家可以参考《[哪些项目使用Go语言开发](http://c.biancheng.net/view/3.html)》一节了解更多的Go语言开源项目。

#### 2) Facebook

Facebook 也在使用Go语言，为此他们还专门在 Github 上建立了一个开源组织 facebookgo。大家可以通过 https://github.com/facebookgo 访问查看 facebook 开源的项目，其中最具代表性的就是著名平滑重启工具 grace。

#### 3) 腾讯

腾讯在 15 年就已经做了 Docker 万台规模的实践。因为腾讯主要的开发语言是 C/[C++](http://c.biancheng.net/cplus/) ，所以在使用Go语言方面会方便很多，也有很多优势，不过日积月累的 C/C++ 代码很难改造，也不敢动，所以主要在新业务上尝试使用 Go。

#### 4) 百度

百度主要在运维方面使用到了Go语言，比如百度运维的一个 BFE 项目，主要负责前端流量的接入，其次就是百度消息通讯系统的服务器端也使用到了Go语言。

#### 5) 七牛云

七牛云算是国内第一家选Go语言做服务端的公司。早在 2011 年，当Go语言的语法还没完全稳定下来的情况下，七牛云就已经选择将 Go 作为存储服务端的主体语言。

#### 6) 京东

京东云消息推送系统、云存储，以及京东商城的列表页等都是使用Go语言开发的。

#### 7) 小米

小米对Go语言的支持，在于运维监控系统的开源，它的官方网址是 http://open-falcon.org/。此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Go语言。

#### 8) 360

360 对Go语言的使用也不少，比如开源的日志搜索系统 Poseidon，大家可以通过 https://github.com/Qihoo360/poseidon 查看，还有 360 的推送团队也在使用Go语言。

除了上面提到的，还有很多公司开始尝试使用Go语言，比如美团、滴滴、新浪等。

Go语言的强项在于它适合用来开发网络并发方面的服务，比如消息推送、监控、容器等，所以在高并发的项目上大多数公司会优先选择 Golang 作为开发语言。

### 6. 语言适合做什么

前面我们已经介绍过了 Go 语言的种种优势和不足，那么我们究竟可以使用 Go 语言来做些什么呢？

其实 Go 语言主要用作服务器端开发，其定位是用来开发 “大型软件” 的，适合于需要很多程序员一起开发，并且开发周期较长的大型软件和支持云计算的网络服务。

Go 语言融合了传统编译型语言的高效性和脚本语言的易用性和富于表达性，不仅提高了项目的开发速度，而且后期维护起来也非常轻松。

鉴于 Go 语言的特点和设计的初衷，从以下几个方面来分析 Go 语言擅长的领域：

- 在服务器编程方面，Go 语言适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；

- 网络编程方面，Go 语言广泛应用于 Web 应用、API 应用、下载应用等；

- 此外，Go 语言还可用于内存数据库和云平台领域，目前国外很多云平台都是采用 Go 开发。

除了上面介绍到的，Go 语言还可以用来开发底层，例如以太坊、超级账本等都是基于 Go 语言开发的。

而且对于现在比较流行的区块链技术方面，Go 语言也是非常受欢迎的，很多基于区块链的 DApps（去中心化应用）和工具都是用的 Go 语言来实现的。

下面列举了一些基于 Go 语言开发的优秀开源项目：

- 云计算基础设施领域，代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。

- 基础软件，代表项目：tidb、influxdb、cockroachdb 等。

- 微服务，代表项目：go-kit、micro、monzo bank 的 typhon、bilibili 等。

- 互联网基础设施，代表项目：以太坊、hyperledger 等。

总之，Go 语言的优势还是比较多的，比如 Go 语言的性能非常出色，最关键的是在性能强劲的同时还能像解释型语言一样高效地进行开发。

### 7. 语言和其它编程语言的对比

在软件行业做过一段时间的人都知道，没有万能的编程语言，也没有万能开发框架，更没有万能的解决方案。任何新技术的产生都应该归功于一部分人对老旧技术的强烈不满。Go 语言也不例外。比如，C 语言的依赖管理、C++ 的垃圾回收、Java 笨重的类型系统和厚重的 Java EE 规范，以及脚本语言（如 PHP、Python 和 Ruby）的性能，这些都是很多开发者社区经常争论和抱怨的问题。

#### Go 语言的优势

Go 语言是集多编程范式之大成者，体现了优秀的软件工程思想和原则，其特性可以使开发者快速地开发、测试和部署程序，大大提高了生产效率。下面我们来看看与其他主流语言相比，Go 语言具有的优势。

1. 相对于 C/C++ 来讲，Go 语言拥有清晰的依赖管理和全自动的垃圾回收机制，因此其代码量大大降低，开发效率大大提高。

1. 相对于 Java 来讲，Go 语言拥有简明的类型系统、函数式编程范式和先进的并发编程模型。因此其代码块更小更简洁、可重用性更高，并可在多核计算环境下更快地运行。

1. 对于 PHP 来讲，Go 语言更具通用性和规范性。这使得其更适合构建大型的软件，并能够更好地将各个模块组织在一起。在性能方面，PHP 不可与 Go 同日而语。

1. 对于 Python/Ruby 来讲，Go 的优势在于其简洁的语法、非侵入式和扁平化的类型系统和浑然天成的多范式编程模型。与 PHP 一样，Python 和 Ruby 也是动态类型的解释型语言，这就意味着它们的运行速度会比静态类型的编译型语言慢很多。

总而言之，Go 语言对于当前大多数主流语言来讲，最大的优势在于具有较高的生产效率、先进的依赖管理和类型系统，以及原生的并发计算支持。因此，Go 语言自发布以来就受到了各个领域开发者的关注和青睐。

#### Go 语言的劣势

下面，我们来客观地看一下目前 Go 语言需要加强或改进的地方（虽然有些 Gopher 并不这么认为）。

1. 从分布式计算的角度来看，Go 语言的成熟度不及 Erlang（现在已经出现了一些这方面的 Go 语言代码包，我们已经可以看到光明的未来了）。

1. 从程序运行速度的角度来看，Go 语言虽然已与 Java 不相上下，但还不及 C（差距正在不断地缩小）。

1. 从第三方库的角度来看，Go 语言的库数量还远远不及其他几门主流语言（比如 Java、Python、Ruby 等）。不过与 Go 语言的年纪相比，用它实现的第三方库已经相当多了，并且它们的数量在持续地飞速增长中。

另外，在更深的层面，Go 语言标准库中也有些不尽如人意的的地方，具体如下。

1. 从语言语法角度来看，Go 语言语法里的语法糖并不多，这让许多 Python、Ruby 爱好者们对它不屑一顾。另外，变量赋值方式多得有点儿累赘了。最让人遗憾的也是我比较在意的一个地方是，Go 语言不支持自定义的泛型类型。

1. 从并发编程角度来看，Go 语言提供的并发模型很强大，但也有一些编写规则需要了解。否则，很容易踩进 “坑” 里。其实不提倡把这叫作“坑”。因为这些所谓的“坑”，大都是我们由于对原理不熟悉而自己挖出来的。

1. 从垃圾回收角度看，Go 语言的垃圾回收采用的是并发的标记清除算法（Concurrent Mark and Sweep，CMS）。虽然是并发的操作，时间比串行操作短很多，但是还是会在垃圾回收期间停止所有用户程序的操作。这一点多少会影响到对实时性要求比较高的应用。不过，在 Go 语言 1.3 之后的版本中，这方面的问题已经得到了极大的改善。

虽然 Go 语言还有一些瑕疵，但从整体来看，它已经是一门非常优秀的通用编程语言了。并且，Go 语言在今后的发展上会关注性能、可靠性、可移植性和一些功能增强，所以上述缺憾会随着版本的推进而逐渐减弱和消失。 http://c.biancheng.net/view/vip_7299.html

### 8. 语言的性能如何？

根据 Go 开发团队和基本的算法测试，Go语言与C语言的性能差距大概在 10%~20% 之间。虽然没有官方的性能标准，但是与其它各个语言相比已经拥有非常出色的表现。

时下流行的语言大都是运行在虚拟机上，如：[Java](http://c.biancheng.net/java/) 和 Scala 使用的 JVM，[C#](http://c.biancheng.net/csharp/) 和 VB.NET 使用的 .NET CLR。尽管虚拟机的性能已经有了很大的提升，但任何使用 JIT 编译器和脚本语言解释器的编程语言（Ruby、[Python](http://c.biancheng.net/python/)、Perl 和 [JavaScript](http://c.biancheng.net/js/)）在 C 和 [C++](http://c.biancheng.net/cplus/) 的绝对优势下甚至都无法在性能上望其项背。

这里以国外的一个编程语言性能测试网站 http://benchmarksgame.alioth.debian.org/ 为测试基准和数据源。这个网站可以对常见的编程语言进行性能比较，网站使用都是最新的语言版本和常见的一些算法。

通过对 C(gcc)、C++、Java、JavaScript 和Go语言的测试。性能比较如下表所示，表中数据的单位为秒，数值越小表明运行性能越好。

​                                                                   常见编程语言的运行性能比较

| 编程语言↓ / 测试用例→ | reverse-complement | pidigits | fannkuch-redux | fasta | spectral-norm | n-body | k-nucleotide | mandelbrot | binary-trees | regex-redux |
| --------------------- | ------------------ | -------- | -------------- | ----- | ------------- | ------ | ------------ | ---------- | ------------ | ----------- |
| C语言                 | 0.42               | 1.73     | 8.97           | 1.33  | 1.99          | 9.96   | 5.38         | 1.65       | 2.38         | 1.45        |
| C++                   | 0.6                | 1.89     | 10.35          | 1.48  | 1.99          | 9.31   | 7.18         | 1.73       | 2.36         | 17.14       |
| Go                    | 0.49               | 2.02     | 14.49          | 2.17  | 3.96          | 21.47  | 14.79        | 5.46       | 35.18        | 29.29       |
| Java                  | 1.13               | 3.12     | 15.09          | 2.32  | 4.25          | 22.56  | 8.38         | 6.08       | 8.58         | 10.38       |
| JavaScript            | 4.3                | N/A      | 81.49          | 9.79  | 16.17         | 28.74  | 66.07        | 19.04      | 53.64        | 4.44        |


通过上表可以看出，Go语言在性能上更接近于 Java 语言，虽然在某些测试用例上不如经过多年优化的 Java 语言，但毕竟 Java 语言已经经历了多年的积累和优化。Go语言在未来的版本中会通过不断的版本优化提高单核运行性能。

### 8. 语言标准库强大

学习编程语言，早已不是学一点语法规则那么简单。现在更习惯称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。

在Go语言的安装文件里包含了一些可以直接使用的包，即标准库。Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含 I/O 操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。

在 Windows 下，标准库的位置在Go语言根目录下的子目录 pkg\windows_amd64 中；在 Linux 下，标准库在Go语言根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。

Go语言的编译器也是标准库的一部分，通过词法器扫描源码，使用语法树获得源码逻辑分支等。Go语言的周边工具也是建立在这些标准库上。在标准库上可以完成几乎大部分的需求。

Go语言的标准库以包的方式提供支持，下表列出了Go语言标准库中常见的包及其功能。

​                                                                 Go语言标准库常用的包及功能

| Go语言标准库包名 | 功  能                                                       |
| ---------------- | ------------------------------------------------------------ |
| bufio            | 带缓冲的 I/O 操作                                            |
| bytes            | 实现字节操作                                                 |
| container        | 封装堆、列表和环形列表等容器                                 |
| crypto           | 加密算法                                                     |
| database         | 数据库驱动和接口                                             |
| debug            | 各种调试文件格式访问及调试功能                               |
| encoding         | 常见算法如 JSON、XML、Base64 等                              |
| flag             | 命令行解析                                                   |
| fmt              | 格式化操作                                                   |
| go               | Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改 |
| html             | HTML 转义及模板系统                                          |
| image            | 常见图形格式的访问及生成                                     |
| io               | 实现 I/O 原始访问接口及访问封装                              |
| math             | 数学库                                                       |
| net              | 网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等                |
| os               | 操作系统平台不依赖平台操作封装                               |
| path             | 兼容各操作系统的路径操作实用函数                             |
| plugin           | Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载        |
| reflect          | 语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值 |
| regexp           | 正则表达式封装                                               |
| runtime          | 运行时接口                                                   |
| sort             | 排序接口                                                     |
| strings          | 字符串转换、解析及实用函数                                   |
| time             | 时间接口                                                     |
| text             | 文本模板及 Token 词法器                                      |


当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。

### 9. 语言上手简单

Go语言语法简单易懂，学习曲线平缓，不需要像 C/[C++](http://c.biancheng.net/cplus/) 语言动辄需要两到三年的学习期。Go语言被称为“互联网时代的C语言”。互联网的短、频、快特性在Go语言中体现得淋漓尽致。一个熟练的开发者只需要短短的一周时间就可以从学习阶段转到开发阶段，并完成一个高并发的服务器开发。

Go语言是 Google 公司开发的一种静态型、编译型并自带垃圾回收和并发的编程语言。所以它是一门类型安全的语言，加上通过构建到本地代码，程序的执行速度也非常快。

Go语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。

Go语言在拥有一些动态语言的特性的同时，其语法风格类似于C语言。在C语言的基础上进行了大幅的简化，去掉了不需要的表达式括号，循环也只有 for 一种表示方法，就可以实现数值、键值等各种遍历。因此，Go语言上手非常容易。

很多读者表示自己是在看了介绍后才开始了解这门语言的，他们一般也会使用两到三门编程语言。Go语言对于他们来说，也就是一到两天的熟悉过程，之后就可以开始使用Go语言解决具体问题了，大约一周左右已经可以使用Go语言完成既定的任务了。

Go语言这种从零开始使用到解决问题的速度，在其他语言中是完全不可想象的。学过 C++ 的朋友都知道，一到两年大强度的理论学习和实战操练也只能学到这门语言的皮毛，以及知道一些基本的避免错误的方法。

那么，Go语言到底有多么简单？下面通过实现一个 HTTP 服务器来了解一下。

【实例】HTTP 文件服务器是常见的 Web 服务之一。开发阶段为了测试，需要自行安装 Apache 或 Nginx 服务器，下载安装配置需要大量的时间。使用Go语言实现一个简单的 HTTP 服务器只需要几行代码，如下所示。

```go
package main
import (
    "net/http"
)
func main() {
    http.Handle("/", http.FileServer(http.Dir(".")))
    http.ListenAndServe(":8080", nil)
}
```

下面是代码说明：

- 第 1 行，标记当前文件为 main 包，main 包也是 Go 程序的入口包。
- 第 3~5 行，导入 net/http 包，这个包的作用是 HTTP 的基础封装和访问。
- 第 7 行，程序执行的入口函数 main()。
- 第 8 行，使用 http.FileServer 文件服务器将当前目录作为根目录（`/`目录）的处理器，访问根目录，就会进入当前目录。
- 第 9 行，默认的 HTTP 服务侦听在本机 8080 端口。


把这个源码保存为 main.go（Go语言的源文件后缀就是`.go`），安装Go语言的开发包（后续我们会讲解如何安装），在命令行输入如下命令：

$ go run main.go

在浏览器里输入`http://127.0.0.1:8080`即可浏览文件，这些文件正是当前目录在HTTP服务器上的映射目录。

#### Go语言工程结构简单

Go语言的源码无须头文件，编译的文件都来自于后缀名为`.go`的源码文件。

Go语言无须解决方案、工程文件和 Make File，只要将工程文件按照 GOPATH 的规则进行填充，即可使用 go build/go install 进行编译，编译完成的二进制可执行文件统一放在 bin 文件夹下。

后面的章节会介绍 GOPATH 及 go build/go install 的详细使用方法。

#### Go语言编译速度快

Go语言可以利用自己的特性实现并发编译，并发编译的最小元素是包。从 Go 1.9 版本开始，最小并发编译元素缩小到函数，整体编译速度提高了 20%。

另外，Go语言语法简单，具有严谨的工程结构设计、没有头文件、不允许包的交叉依赖等规则，在很大程度上加速了编译的过程。

### 10. 语言代码风格清晰、简单

Go语言语法类似于C语言，因此熟悉C语言及其派生语言（[C++](http://c.biancheng.net/cplus/)、[C#](http://c.biancheng.net/csharp/)、Objective-C 等）的人都会迅速熟悉这门语言。

C语言的有些语法会让代码可读性降低甚至发生歧义。Go语言在C语言的基础上取其精华，弃其糟粕，将C语言中较为容易发生错误的写法进行调整，做出相应的编译提示。

#### 1) 去掉循环冗余括号

Go语言在众多大师的丰富实战经验的基础上诞生，去除了C语言语法中一些冗余、烦琐的部分。下面的代码是C语言的数值循环：

```go
// C语言的for数值循环
for(int a = 0;a<10;a++){
    // 循环代码
}
```

在Go语言中，这样的循环变为：

```go
for a := 0;a<10;a++{
    // 循环代码
}
```

for 两边的括号被去掉，int 声明被简化为`:=`，直接通过编译器右值推导获得 a 的变量类型并声明。

#### 2) 去掉表达式冗余括号

同样的简化也可以在判断语句中体现出来，以下是C语言的判断语句：

```go
if (表达式){
    // 表达式成立
}
```

在Go语言中，无须添加表达式括号，代码如下：

```go
if 表达式{
    // 表达式成立
}
```

#### 3) 强制的代码风格

Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。这个特性刚开始会使开发者有一些不习惯，但随着对Go语言的不断熟悉，开发者就会发现风格统一让大家在阅读代码时把注意力集中到了解决问题上，而不是代码风格上。

同时Go语言也提供了一套格式化工具。一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。

#### 4) 不再纠结于 i++ 和 ++i

C语言非常经典的考试题为：

```go
int a, b;
a = i++;
b = ++i;
```

这种题目对于初学者简直摸不着头脑。为什么一个简单的自增表达式需要有两种写法？

在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：

```go
i++
```

如果写成前置自增`++i`，或者赋值后自增`a=i++`都将导致编译错误。

### 11. 语言是怎么完成编译的

Go 语言是一门需要编译才能运行的编程语言，也就说代码在运行之前需要通过编译器生成二进制机器码，随后二进制文件才能在目标机器上运行，如果我们想要了解 Go 语言的实现原理，理解它的编译过程就是一个没有办法绕过的事情。

#### 预备知识

想要深入了解 Go 语言的编译过程，需要提前了解一下编译过程中涉及的一些术语和专业知识。这些知识其实在我们的日常工作和学习中比较难用到，但是对于理解编译的过程和原理还是非常重要的。

##### 1) 抽象语法树

在计算机科学中，抽象语法树（Abstract Syntax Tree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。

之所以说语法是 “抽象” 的，是因为这里的语法并不会表示出真实语法中出现的每个细节。比如，嵌套括号被隐含在树的结构中，并没有以节点的形式呈现。而类似于 if else 这样的条件判断语句，可以使用带有两个分支的节点来表示。

以算术表达式 1+3*(4-1)+2 为例，可以解析出的抽象语法树如下图所示：

[![](http://c.biancheng.net/uploads/allimg/191115/4-191115094600340.gif) ](http://c.biancheng.net/uploads/allimg/191115/4-191115094600340.gif)

图：抽象语法树

抽象语法树可以应用在很多领域，比如浏览器，智能编辑器，编译器。

##### 2) 静态单赋值

在编译器设计中，静态单赋值形式（static single assignment form，通常简写为 SSA form 或是 SSA）是中介码（IR，intermediate representation）的属性，它要求每个变量只分配一次，并且变量需要在使用之前定义。在实践中我们通常会用添加下标的方式实现每个变量只能被赋值一次的特性，这里以下面的代码举一个简单的例子：

```go
x := 1 x := 2 y := x
```

从上面的描述所知，第一行赋值行为是不需要的，因为 x 在第二行被二度赋值并在第三行被使用，在 SSA 下，将会变成下列的形式：

```go
x1 := 1 x2 := 2 y1 := x2
```

从使用 SSA 的中间代码我们就可以非常清晰地看出变量 y1 的值和 x1 是完全没有任何关系的，所以在机器码生成时其实就可以省略第一步，这样就能减少需要执行的指令来优化这一段代码。

根据 Wikipedia（维基百科）对 SSA 的介绍来看，在中间代码中使用 SSA 的特性能够为整个程序实现以下的优化：

- 常数传播（constant propagation）

- 值域传播（value range propagation）

- 稀疏有条件的常数传播（sparse conditional constant propagation）

- 消除无用的程式码（dead code elimination）

- 全域数值编号（global value numbering）

- 消除部分的冗余（partial redundancy elimination）

- 强度折减（strength reduction）

- 寄存器分配（register allocation）

因为 SSA 的主要作用就是代码的优化，所以是编译器后端（主要负责目标代码的优化和生成）的一部分。当然，除了 SSA 之外代码编译领域还有非常多的中间代码优化方法，优化编译器生成的代码是一个非常古老并且复杂的领域，这里就不展开介绍了。

### 3) 指令集架构

最后要介绍的一个预备知识就是指令集架构了，指令集架构（Instruction Set Architecture，简称 ISA），又称指令集或指令集体系，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部 I/O。指令集架构包含一系列的 opcode 即操作码（机器语言），以及由特定处理器执行的基本命令。

指令集架构常见种类如下：

- 复杂指令集运算（Complex Instruction Set Computing，简称 CISC）；

- 精简指令集运算（Reduced Instruction Set Computing，简称 RISC）；

- 显式并行指令集运算（Explicitly Parallel Instruction Computing，简称 EPIC）；

- 超长指令字指令集运算（VLIW）。

不同的处理器（CPU）使用了大不相同的机器语言，所以我们的程序想要在不同的机器上运行，就需要将源代码根据架构编译成不同的机器语言。

#### 编译原理

Go 语言编译器的源代码在 cmd/compile 目录中，目录下的文件共同构成了 Go 语言的编译器，学过编译原理的人可能听说过编译器的前端和后端，编译器的前端一般承担着词法分析、语法分析、类型检查和中间代码生成几部分工作，而编译器后端主要负责目标代码的生成和优化，也就是将中间代码翻译成目标机器能够运行的机器码。

[![img](http://c.biancheng.net/uploads/allimg/191115/4-19111511533W48.gif)](http://c.biancheng.net/uploads/allimg/191115/4-19111511533W48.gif)

Go 的编译器在逻辑上可以被分成四个阶段：词法与语法分析、类型检查和 AST 转换、通用 SSA 生成和最后的机器代码生成，下面我们来分别介绍一下这四个阶段做的工作。

##### 1) 词法与语法分析

所有的编译过程其实都是从解析代码的源文件开始的，词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析，我们一般会把执行词法分析的程序称为词法解析器（lexer）。

而语法分析的输入就是词法分析器输出的 Token 序列，这些序列会按照顺序被语法分析器进行解析，语法的解析过程就是将词法分析生成的 Token 按照语言定义好的文法（Grammar）自下而上或者自上而下的进行规约，每一个 Go 的源代码文件最终会被归纳成一个 SourceFile 结构：

```go
SourceFile = PackageClause “;” {ImportDecl “;”} { TopLevelDecl “;” }
```

标准的 Golang 语法解析器使用的就是 LALR(1) 的文法，语法解析的结果其实就是上面介绍过的抽象语法树（AST），每一个 AST 都对应着一个单独的 Go 语言文件，这个抽象语法树中包括当前文件属于的包名、定义的常量、结构体和函数等。

如果在语法解析的过程中发生了任何语法错误，都会被语法解析器发现并将消息打印到标准输出上，整个编译过程也会随着错误的出现而被中止。

##### 2) 类型检查

当拿到一组文件的抽象语法树 AST 之后，Go 语言的编译器会对语法树中定义和使用的类型进行检查，类型检查分别会按照顺序对不同类型的节点进行验证，按照以下的顺序进行处理：

- 常量、类型和函数名及类型；

- 变量的赋值和初始化；

- 函数和闭包的主体；

- 哈希键值对的类型；

- 导入函数体；

- 外部的声明；

通过对每一棵抽象节点树的遍历，我们在每一个节点上都会对当前子树的类型进行验证保证当前节点上不会出现类型错误的问题，所有的类型错误和不匹配都会在这一个阶段被发现和暴露出来。

类型检查的阶段不止会对树状结构的节点进行验证，同时也会对一些内建的函数进行展开和改写，例如 make 关键字在这个阶段会根据子树的结构被替换成 makeslice 或者 makechan 等函数。

其实类型检查不止对类型进行了验证工作，还对 AST 进行了改写以及处理 Go 语言内置的关键字，所以，这一过程在整个编译流程中是非常重要的，没有这个步骤很多关键字其实就没有办法工作。

##### 3) 中间代码生成

当我们将源文件转换成了抽象语法树，对整个语法树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码基本上不存在无法编译或者语法错误的问题了，Go 语言的编译器就会将输入的 AST 转换成中间代码。

Go 语言编译器的中间代码使用了 SSA(Static Single Assignment Form) 的特性，如果我们在中间代码生成的过程中使用这种特性，就能够比较容易的分析出代码中的无用变量和片段并对代码进行优化。

在类型检查之后，就会通过一个名为 compileFunctions 的函数开始对整个 Go 语言项目中的全部函数进行编译，这些函数会在一个编译队列中等待几个后端工作协程的消费，这些 Goroutine 会将所有函数对应的 AST 转换成使用 SSA 特性的中间代码。

##### 4) 机器码生成

Go 语言源代码的 cmd/compile/internal 目录中包含了非常多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包进行生成 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm，也就是说 Go 语言能够在几乎全部常见的 CPU 指令集类型上运行。

#### 编译器入口

Go 语言的编译器入口是 src/cmd/compile/internal/gc 包中的 main.go 文件，这个 600 多行的 Main 函数就是 Go 语言编译器的主程序，这个函数会先获取命令行传入的参数并更新编译的选项和配置，随后就会开始运行 parseFiles 函数对输入的所有文件进行词法与语法分析得到文件对应的抽象语法树：

func Main(archInit func(*Arch)) {   // …

lines := parseFiles(flag.Args())

接下来就会分九个阶段对抽象语法树进行更新和编译，就像我们在上面介绍的，整个过程会经历类型检查、SSA 中间代码生成以及机器码生成三个部分：

- 检查常量、类型和函数的类型；

- 处理变量的赋值；

- 对函数的主体进行类型检查；

- 决定如何捕获变量；

- 检查内联函数的类型；

- 进行逃逸分析；

- 将闭包的主体转换成引用的捕获变量；

- 编译顶层函数；

- 检查外部依赖的声明；

了解了剩下的编译过程之后，我们重新回到词法和语法分析后的具体流程，在这里编译器会对生成语法树中的节点执行类型检查，除了常量、类型和函数这些顶层声明之外，它还会对变量的赋值语句、函数主体等结构进行检查：

```go
  for i := 0; i < len(xtop); i++ {
      n := xtop[i]
      if op := n.Op; op != ODCL && op != OAS && op != OAS2 && (op != ODCLTYPE || !n.Left.Name.Param.Alias) {
          xtop[i] = typecheck(n, ctxStmt)
      }
  }

  for i := 0; i < len(xtop); i++ {
      n := xtop[i]
      if op := n.Op; op == ODCL || op == OAS || op == OAS2 || op == ODCLTYPE && n.Left.Name.Param.Alias {
          xtop[i] = typecheck(n, ctxStmt)
      }
  }

  for i := 0; i < len(xtop); i++ {
      n := xtop[i]
      if op := n.Op; op == ODCLFUNC || op == OCLOSURE {
          typecheckslice(Curfn.Nbody.Slice(), ctxStmt)
      }
  }

  checkMapKeys()

  for _, n := range xtop {
      if n.Op == ODCLFUNC && n.Func.Closure != nil {
          capturevars(n)
      }
  }

  escapes(xtop)

  for _, n := range xtop {
      if n.Op == ODCLFUNC && n.Func.Closure != nil {
          transformclosure(n)
      }
  }
```

类型检查会对传入节点的子节点进行遍历，这个过程会对 make 等关键字进行展开和重写，类型检查结束之后并没有输出新的数据结构，只是改变了语法树中的一些节点，同时这个过程的结束也意味着源代码中已经不存在语法错误和类型错误，中间代码和机器码也都可以正常的生成了。

```go
      initssaconfig()

      peekitabs()

      for i := 0; i < len(xtop); i++ {
          n := xtop[i]
          if n.Op == ODCLFUNC {
              funccompile(n)
          }
      }

      compileFunctions()

      for i, n := range externdcl {
          if n.Op == ONAME {
              externdcl\[i\] = typecheck(externdcl\[i\], ctxExpr)
          }
      }

      checkMapKeys()
  }
```

在主程序运行的最后，会将顶层的函数编译成中间代码并根据目标的 CPU 架构生成机器码，不过这里其实也可能会再次对外部依赖进行类型检查以验证正确性。

#### 总结

Go 语言的编译过程其实是非常有趣并且值得学习的，通过对 Go 语言四个编译阶段的分析和对编译器主函数的梳理，我们能够对 Golang 的实现有一些基本的理解，掌握编译的过程之后，Go 语言对于我们来讲也不再那么神秘，所以学习其编译原理的过程还是非常有必要的。 http://c.biancheng.net/view/vip_7300.html

###  13. Mac OS上安装Go语言开发包

本节主要为大家讲解如何在Mac OS上安装Go语言开发包，大家可以在Go语言官网下载对应版本的的安装包（https://golang.google.cn/dl/），如下图所示。



![下载Mac OS版Go语言开发包](http://c.biancheng.net/uploads/allimg/191115/4-19111516133L57.gif)

#### 安装Go语言开发包

Mac OS 的Go语言开发包是 .pkg 格式的，双击我们下载的安装包即可开始安装。



![img](http://c.biancheng.net/uploads/allimg/191115/4-191115152Qb04.gif)


Mac OS 下是傻瓜式安装，一路点击“继续”即可，不再赘述。



![img](http://c.biancheng.net/uploads/allimg/180808/1-1PPQ633343F.jpg)


安装包会默认安装在 /usr/local 目录下，如下所示。



![Go 的安装目录](http://c.biancheng.net/uploads/allimg/191115/4-1911151621243C.gif)


安装完成之后，在终端运行 `go version`，如果显示类似下面的信息，表明安装成功。

go version go1.13.4 darwin/amd64

#### 设置 GOPATH 环境变量

开始写 go 项目代码之前，需要我们先配置好环境变量。编辑 ~/.bash_profile（在终端中运行 `vi ~/.bash_profile` 即可）来添加下面这行代码（如果你找不到 .bash_profile，那自己创建一个就可以了）

export GOPATH=$HOME/go

保存然后退出你的编辑器。然后在终端中运行下面命令

source ~/.bash_profile

> 提示：$HOME 是每个电脑下的用户主目录，每个电脑可能不同，可以在终端运行 echo $HOME 获取

GOROOT 也就是 Go 开发包的安装目录默认是在 /usr/local/go，如果没有，可以在 bash_profile 文件中设置。

export GOROOT=/usr/local/go

然后保存并退出编辑器，运行 `source ~/.bash_profile `命令即可。

### 13.  集成开发环境（IDE）大汇总

前面我们介绍了Go语言的安装，本节我们来为大家介绍几款强大的Go语言集成开发环境（Integrated Development Environment，IDE）和编辑器。

如何挑选合适的编辑器或集成开发环境呢？下面列举了一些Go语言集成开发环境或编辑器应该具备的特性：

- 语法高亮是必不可少的功能，这也是为什么每个开发工具都提供配置文件来实现自定义配置的原因。
- 拥有较好的项目文件纵览和导航能力，可以同时编辑多个源文件并设置书签，能够匹配括号，能够跳转到某个函数或类型的定义部分。
- 完美的查找和替换功能，替换之前最好还能预览结果。
- 当有编译错误时，双击错误提示可以跳转到发生错误的位置。
- 跨平台，能够在 Linux、Mac OS X 和 Windows 下工作，这样就可以专注于一个开发环境。
- 能够通过插件架构来轻易扩展和替换某个功能。
- 拥有断点、检查变量值、单步执行、逐过程执行标识库中代码的能力。
- 能够方便的存取最近使用过的文件或项目。
- 拥有对包、类型、变量、函数和方法的智能代码补全的功能。
- 能够方便地在不同的 Go 环境之间切换。
- 针对一些特定的项目有项目模板，如：Web 应用，App Engine 项目，从而能够更快地开始开发工作。


下面为大家推荐几款常用的适用于Go语言的编辑器或集成开发环境。

#### 1) Goland

Goland 是由 JetBrains 公司开发的一个新的商业 IDE，旨在为 Go 开发者提供的一个符合人体工程学的新的商业 IDE。Goland 整合了 IntelliJ 平台（一个用于 java 语言开发的集成环境，也可用于其他开发语言），提供了针对Go语言的编码辅助和工具集成。



![Goland](http://c.biancheng.net/uploads/allimg/191107/4-19110G24221554.gif)


关于 Goland 的详细使用说明请参考《[Goland 2019下载和安装](http://c.biancheng.net/view/6124.html)》一节。

#### 2) LiteIDE

LiteIDE是一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。同时还包括了对源代码的抽象语法树视图和一些内置工具（此开发环境由国人 vfc 大叔开发）。

LiteIDE 是一款非常好用的轻量级 Go 集成开发环境（基于 QT、Kate 和 SciTE），包含了跨平台开发及其它必要的特性，对代码编写、自动补全和运行调试都有极佳的支持。它采用了 Go 项目的概念来对项目文件进行浏览和管理，它还支持在各个 Go 开发环境之间随意切换以及交叉编译的功能。

同时，它具备了抽象语法树视图的功能，可以清楚地纵览项目中的常量、变量、函数、不同类型以及他们的属性和方法。



![LiteIDE界面](http://c.biancheng.net/uploads/allimg/190605/4-1Z6051J24a61.gif)


关于 LiteIDE 的安装和使用大家可以参考《[LiteIDE搭建Go语言开发环境](http://c.biancheng.net/view/6241.html)》一节。

#### 3) Sublime Text

一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。

#### 4) GoClipse

是一款 Eclipse IDE 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。其依附于著名的 Eclipse 这个大型开发环境，虽然需要安装 JVM 运行环境，但却可以很容易地享有 Eclipse 本身所具有的诸多功能。这是一个非常好的编辑器，完善的代码补全、抽象语法树视图、项目管理和程序调试功能。



![GoClipse界面](http://c.biancheng.net/uploads/allimg/190605/4-1Z6051J320429.gif)


如果你对集成开发环境都不是很熟悉，那就使用 LiteIDE 吧，另外使用 GoClipse 或者 IntelliJ Idea Plugin 也是不错的选择。

代码补全一般都是通过内置 GoCode 实现的（如：LiteIDE、GoClipse），如果需要手动安装 GoCode，在命令行输入指令 `go get -u github.com/nsf/gocode` 即可（务必事先配置好 Go 环境变量） 。

#### 5) Visual Studio Code（简称VS Code）

是一款由微软公司开发的，能运行在 Mac OS X、Windows 和 Linux 上的跨平台开源代码编辑器。

VS Code 使用 JSON 格式的配置文件进行所有功能和特性的配置，同时它还可以通过扩展程序为编辑器实现编程语言高亮、参数提示、编译、调试、文档生成等各种功能。

### 15. 语言工程结构详述

一般的编程语言往往对工程（项目）的目录结构是没有什么规定的，但是Go语言却在这方面做了相关规定，本节我们就来聊聊Go语言在工程结构方面的有关知识。

我们前面讲搭建Go语言开发环境时提到的环境变量 GOPATH，项目的构建主要是靠它来实现的。这么说吧，如果想要构建一个项目，就需要将这个项目的目录添加到 GOPATH 中，多个项目之间可以使用`;`分隔。

如果不配置 GOPATH，即使处于同一目录，代码之间也无法通过绝对路径相互调用。

#### 目录结构

一个Go语言项目的目录一般包含以下三个子目录：

- src 目录：放置项目和库的源文件；
- pkg 目录：放置编译后生成的包/库的归档文件；
- bin 目录：放置编译后生成的可执行文件。


三个目录中我们需要重点关注的是 src 目录，其他两个目录了解即可，下面来分别介绍一下这三个目录。

##### src 目录

用于以包（package）的形式组织并存放 Go 源文件，这里的包与 src 下的每个子目录是一一对应。例如，若一个源文件被声明属于 log 包，那么它就应当保存在 src/log 目录中。

并不是说 src 目录下不能存放 Go 源文件，一般在测试或演示的时候也可以把 Go 源文件直接放在 src 目录下，但是这么做的话就只能声明该源文件属于 main 包了。正常开发中还是建议大家把 Go 源文件放入特定的目录中。

包是Go语言管理代码的重要机制，其作用类似于[Java](http://c.biancheng.net/java/)中的 package 和 C/[C++](http://c.biancheng.net/cplus/) 的头文件。Go 源文件中第一段有效代码必须是`package <包名> `的形式，如 package hello。

另外需要注意的是，Go语言会把通过`go get `命令获取到的库源文件下载到 src 目录下对应的文件夹当中。

##### pkg 目录

用于存放通过`go install `命令安装某个包后的归档文件。归档文件是指那些名称以“.a”结尾的文件。

该目录与 GOROOT 目录（也就是Go语言的安装目录）下的 pkg 目录功能类似，区别在于这里的 pkg 目录专门用来存放项目代码的归档文件。

编译和安装项目代码的过程一般会以代码包为单位进行，比如 log 包被编译安装后，将生成一个名为 log.a 的归档文件，并存放在当前项目的 pkg 目录下。

##### bin 目录

与 pkg 目录类似，在通过`go install `命令完成安装后，保存由 Go 命令源文件生成的可执行文件。在类 Unix 操作系统下，这个可执行文件的名称与命令源文件的文件名相同。而在 Windows 操作系统下，这个可执行文件的名称则是命令源文件的文件名加 .exe 后缀。

#### 源文件

上面我们提到了命令源文件和库源文件，它们到底是什么呢？

- 命令源文件：如果一个 Go 源文件被声明属于 main 包，并且该文件中包含 main 函数，则它就是命令源码文件。命令源文件属于程序的入口，可以通过Go语言的`go run `命令运行或者通过`go build `命令生成可执行文件。
- 库源文件：库源文件则是指存在于某个包中的普通源文件，并且库源文件中不包含 main 函数。

不管是命令源文件还是库源文件，在同一个目录下的所有源文件，其所属包的名称必须一致的。

### 16. 语言依赖管理

早期的 Go 语言被很多开发者所吐槽的一个问题就是没有依赖包的管理，不过随着版本的不断更迭，Go 语言依赖管理方面也在不断的完善。

#### 为什么需要依赖管理

最初的时候 Go 语言所依赖的所有的第三方包都放在 GOPATH 目录下面，这就导致了同一个包只能保存一个版本的代码，如果不同的项目依赖同一个第三方的包的不同版本，应该怎么解决呢？

#### godep

godep 是一个 Go 语言官方提供的通过 vender 模式来管理第三方依赖的工具，类似的还有由社区维护的准官方包管理工具 dep。

Go 语言从 1.5 版本开始开始引入 vendor 模式，如果项目目录下有 vendor 目录，那么 Go 语言编译器会优先使用 vendor 内的包进行编译、测试等。

#### 安装 godep 工具

我们可以通过`go get `命令来获取 godep 工具。

go get github.com/tools/godep

命令执行成功后会将 godep 工具的源码下载到 GOPATH 的 src 目录下对应的文件夹中，同时还会在 GOPATH 的 bin 目录下生成一个名为 godep.exe 的可执行文件，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/191112/4-191112093444133.gif)](http://c.biancheng.net/uploads/allimg/191112/4-191112093444133.gif)

为了方便使用 godep 工具，我们需要将存放 godep.exe 文件的目录添加到环境变量 PATH 中。在系统变量中找到并选中 “Path” 一行，点击 “编辑” 按钮，在新弹出的窗口中点击“新建”，然后在最下面一行中填入对应的目录信息。确认无误后点击“确定”。

[![img](http://c.biancheng.net/uploads/allimg/191112/4-1911121006323N.gif)](http://c.biancheng.net/uploads/allimg/191112/4-1911121006323N.gif)

环境变量设置的打开方式我们在《[安装 Go 语言开发包](http://c.biancheng.net/view/3992.html)》一节中已经介绍过了，这里不再赘述。

### godep 工具的基本命令

完成上面的操作后，我们就可以在命令行窗口（CMD）中使用 godep 工具了，godep 支持的命令如下表所示：

#### 

| 命令                                                         | 作用                                    |
| :----------------------------------------------------------- | :-------------------------------------- |
| [godep save](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep save 326e6f182c744961b5029c407650d6be.html) | 将依赖包的信息保存到 Godeps.json 文件中 |
| [godep go](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep go 6cca4d2321764f5680e97703d9bafa51.html) | 使用保存的依赖项运行 go 工具            |
| [godep get](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep get 903226da862e4974be966d3cd8b27b8c.html) | 下载并安装指定的包                      |
| [godep path](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep path 0d5b9c21d81f445da740d05d682c8648.html) | 打印依赖的 GOPATH 路径                  |
| [godep restore](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep restore b66d1b2dfc124033aee8290f71308fb7.html) | 在 GOPATH 中拉取依赖的版本              |
| [godep update](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep update eda2219475524081aba706096308c3b9.html) | 更新选定的包或 go 版本                  |
| [godep diff](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep diff 53cd2b7874834f59b3dd8c89081f9e37.html) | 显示当前和以前保存的依赖项集之间的差异  |
| [godep version](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 88b171c799e34f7dafce9029d16de5b3/godep version a9ff7274a0114763a90a65a3c15aaebd.html) | 查看版本信息                            |

使用`godep help [命令名称]`可以查看命令的帮助信息，如下所示。

C:\Users\Administrator>godep help go Args: godep go [-v] [-d] command [arguments]

Go runs the go tool with a modified GOPATH giving access to dependencies saved in Godeps.

Any go tool command can run this way, but “godep go get” is unnecessary and has been disabled. Instead, use “godep go install”.

If -v is given, verbose output is enabled.

If -d is given, debug output is enabled (you probably don’t want this, see -v).

#### 使用 godep 工具

执行`godep save `命令，会在当前目录中创建 Godeps 和 vender 两个文件夹。Godeps 文件夹下会生成一个 Godeps.json 文件，用来记录项目中所依赖的包信息；vender 目录则是用来保存当前项目所依赖的所有第三方包。

[![img](http://c.biancheng.net/uploads/allimg/191112/4-19111213453B61.gif)](http://c.biancheng.net/uploads/allimg/191112/4-19111213453B61.gif)

生成的 Godeps.json 文件的结构如下所示：

{   “ImportPath”: “main”,   “GoVersion”: “go1.13”,   “GodepVersion”: “v80”,   “Deps”: [     {       “ImportPath”: “github.com/go-gomail/gomail”,       “Comment”: “2.0.0-23-g81ebce5”,       “Rev”: “81ebce5c23dfd25c6c67194b37d3dd3f338c98b1”     }   ] }

其中，“ImportPath” 为项目的路径信息，“GoVersion” 为 Go 语言的版本号，“GodepVersion” 为 godep 工具的版本号，“Deps” 为当前依赖包的路径、版本号信息等等。

提示：当引用的第三方包要升级时，只需要修改 Godep.json 里面的依赖包的版本号，然后再次执行 godep save 命令即可。

godep 工具的主要功能就是控制 Go 语言程序编译时依赖包搜索路径的优先级。例如查找项目的某个依赖包，首先会在项目根目录下的 vender 文件夹中查找，如果没有找到就会去 GOAPTH/src 目录下查找。

#### go module

go module 是 Go 语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了 Go 语言默认的依赖管理工具。

#### GO111MODULE

在 Go 语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在 Go 语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。

- GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包。

- GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。

- GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。

Windows 下开启 GO111MODULE 的命令为：

set GO111MODULE=on 或者 set GO111MODULE=auto

MacOS 或者 Linux 下开启 GO111MODULE 的命令为：

export GO111MODULE=on 或者 export GO111MODULE=auto

在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。

使用 go module 的`go mod init `命令后会在当前目录下生成一个 go. mod 文件，并且在编译 / 运行当前目录下代码或者使用`go get `命令的时候会在当前目录下生成一个 go.sun 文件。

[![img](http://c.biancheng.net/uploads/allimg/191113/4-191113092510407.gif)](http://c.biancheng.net/uploads/allimg/191113/4-191113092510407.gif)

go.mod 文件记录了项目所有的依赖信息，其结构大致如下：

module main.go

go 1.13

require (   github.com/astaxie/beego v1.12.0   github.com/shiena/ansicolor v0.0.0-20151119151921-a422bbe96644 // indirect )

其中，module 为 go.mod 文件所属的包，require 为项目所依赖的包及版本号，indirect 表示间接引用。

go.sum 文件则是用来记录每个依赖包的版本及哈希值，如下所示。

github.com/Knetic/govaluate v3.0.0+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0= github.com/OwnLocal/goes v1.0.0/go.mod h1:8rIFjBGTue3lCU0wplczcUgt9Gxgrkkrw7etMIcn8TM= github.com/astaxie/beego v1.12.0 h1:MRhVoeeye5N+Flul5PoVfD9CslfdoH+xqC/xvSQ5u2Y= github.com/astaxie/beego v1.12.0/go.mod h1:fysx+LZNZKnvh4GED/xND7jWtjCR6HzydR2Hh2Im57o=

常用的 go mod 命令如下表所示：

| 命令                                                         | 作用                                           |
| :----------------------------------------------------------- | :--------------------------------------------- |
| [go mod download](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod download ca56a2736cac416880f3b85ba94fb120.html) | 下载依赖包到本地（默认为 GOPATH/pkg/mod 目录） |
| [go mod edit](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod edit 836de78efa7f4e959d29809a12ef489e.html) | 编辑 go.mod 文件                               |
| [go mod graph](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod graph 904c6d5af2d34b3e966ae5432955747d.html) | 打印模块依赖图                                 |
| [go mod init](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod init 45b0a906e6e3476f8e0a09537a48eab6.html) | 初始化当前文件夹，创建 go.mod 文件             |
| [go mod tidy](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod tidy 0f361f0def34424db9b0224702c94176.html) | 增加缺少的包，删除无用的包                     |
| [go mod vendor](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod vendor ccb12ce1db6d4983983d06e2c09cb735.html) | 将依赖复制到 vendor 目录下                     |
| [go mod verify](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod verify 7c6faa8ee8844241bccb0e694b928301.html) | 校验依赖                                       |
| [go mod why](Go语言依赖管理 405e9f109cad4e2eaf6990d621d87fe2/Untitled Database 2864d18a5cc741f6940cb87b73eefcd8/go mod why e7b49794e3c54af3a0f3a79eae40e8ed.html) | 解释为什么需要依赖                             |

#### GOPROXY

proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些 Go 语言的第三方包我们无法直接通过`go get `命令获取。GOPROXY 是 Go 语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。

目前公开的代理服务器的地址有：

- goproxy.io

- goproxy.cn：（推荐）由国内的七牛云提供。

Windows 下设置 GOPROXY 的命令为：

go env -w GOPROXY=[https://goproxy.cn,direct](https://goproxy.cn,direct/)

MacOS 或 Linux 下设置 GOPROXY 的命令为：

export GOPROXY=[https://goproxy.cn](https://goproxy.cn/)

Go 语言在 1.13 版本之后 GOPROXY 默认值为 [https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将](https://proxy.golang.xn--org,,-fi1h14cbmv3p1naz2a81iqwc0xrosaea708fkskjxbz5bsy7amjjftdpxfd4aj30e636bhx6c3u1cncgz66gjpat33hc19b/) GOPROXY 设置为国内的 goproxy.cn。

#### 使用 go get 命令下载指定版本的依赖包

执行`go get `命令，在下载依赖包的同时还可以指定依赖包的版本。

- 运行`go get -u`命令会将项目中的包升级到最新的次要版本或者修订版本；

- 运行`go get -u=patch`命令会将项目中的包升级到最新的修订版本；

- 运行`go get [包名]@[版本号]`命令会下载对应包的指定版本或者将对应包升级到指定的版本。

提示：`go get [包名]@[版本号]`命令中版本号可以是 x.y.z 的形式，例如 go get foo@v1.2.3，也可以是 git 上的分支或 tag，例如 go get foo@master，还可以是 git 提交时的哈希值，例如 go get foo@e3702bed2。 http://c.biancheng.net/view/vip_7301.html

### 16. 第一个Go语言程序

通过前面学习大家已经对Go语言有了一定的了解，那要怎么来创建一个Go语言程序呢？本节就来带领大家实现一个简单的程序——在控制台输出“Hello World!”。

在控制台输出“Hello World!”非常简单，仅需要几行代码就可以搞定，如下所示：

```go
package main    // 声明 main 包
import (
    "fmt"       // 导入 fmt 包，打印字符串是需要用到
)
func main() {   // 声明 main 主函数
    fmt.Println("Hello World!") // 打印 Hello World!
}
```

大家也许不明白这些代码的含义，没关系，下面就来一一介绍。

#### package（创建包）

Go语言以“包”作为管理单位，每个 Go 源文件必须先声明它所属的包，所以我们会看到每个 Go 源文件的开头都是一个 package 声明，格式如下：

```go
package name
```

其中 package 是声明包名的关键字，name 为包的名字。

Go语言的包与文件夹是一一对应的，它具有以下几点特性：

- 一个目录下的同级文件属于同一个包。
- 包名可以与其目录名不同。
- main 包是Go语言程序的入口包，一个Go语言程序必须**有且仅有一个** main 包。如果一个程序没有 main 包，那么编译时将会出错，无法生成可执行文件。

#### import（导入包）

在包声明之后，是 import 语句，用于导入程序中所依赖的包，导入的包名使用双引号`""`包围，格式如下：

```go
import "name"
```

其中 import 是导入包的关键字，name 为所导入包的名字。

代码第 4 行导入了 fmt 包，这行代码会告诉 Go 编译器，我们需要用到 fmt 包中的函数或者变量等，fmt 包是Go语言标准库为我们提供的，用于格式化输入输出的内容（类似于C语言中的 stdio.h 头文件），类似的还有 os 包、io 包等，后面我们会详细介绍。

另外有一点需要注意，导入的包中不能含有代码中没有使用到的包，否则Go编译器会报编译错误，例如` imported and not used: "xxx"`，"xxx" 表示包名。

也可以使用一个 import 关键字导入多个包，此时需要用括号`( )`将包的名字包围起来，并且每个包名占用一行，也就是写成下面的样子：

```go
import(
  "name1"
  "name2"
)
```

#### main 函数

代码的第 7 行创建了一个 main 函数，它是Go语言程序的入口函数，也即程序启动后运行的第一个函数。main 函数只能声明在 main 包中，不能声明在其他包中，并且，一个 main 包中也必须有且仅有一个 main 函数。

`C/C++ 程序的入口函数也是 main()，一个 C/C++ 程序有且只能有一个 main() 函数。`

main 函数是自定义函数的一种，在Go语言中，所有函数都以关键字 func 开头的，定义格式如下所示：

```go
func 函数名 (参数列表) (返回值列表){
  函数体
}
```

格式说明如下：

- 函数名：由字母、数字、下画线`_`组成，其中，函数名的第一个字母不能为数字，并且，在同一个包内，函数名称不能重名。
- 参数列表：一个参数由参数变量和参数类型组成，例如`func foo( a int, b string )`。
- 返回值列表：可以是返回值类型列表，也可以是参数列表那样变量名与类型的组合，函数有返回值时，必须在函数体中使用 return 语句返回。
- 函数体：能够被重复调用的代码片段。


注意：Go语言函数的左大括号`{`必须和函数名称在同一行，否则会报错。

#### 打印 Hello World

代码的第 8 行`fmt.Println("Hello World!")`中，Println 是 fmt 包中的一个函数，它用来格式化输出数据，比如字符串、整数、小数等，类似于C语言中的 printf 函数。这里我们使用 Println 函数来打印字符串，也就是`( )`里面使用`""`包裹的部分。

注意，Println 函数打印完成后会自动换行，ln是 line 的缩写。

点号`.`是Go语言运算符的一种，这里表示调用 fmt 包中的 Println 函数。

另外，代码`fmt.Println("Hello World!")`的结尾，不需要使用`;`来作为结束符，Go 编译器会自动帮我们添加，当然，在这里加上`;`也是可以的。

到这里，相信大家已经知道如何创建一个简单的Go语言程序了，赶快动手试试吧！下一节将为大家演示，如何运行我们所编写的Go语言程序。

### 17. 语言程序的编译和运行

Go语言是编译型的静态语言（和C语言一样），所以在运行Go语言程序之前，先要将其编译成二进制的可执行文件。

可以通过Go语言提供的`go build`或者`go run`命令对Go语言程序进行编译：

- `go build`命令可以将Go语言程序代码编译成二进制的可执行文件，但是需要我们手动运行该二进制文件；
- `go run`命令则更加方便，它会在编译后直接运行Go语言程序，编译过程中会产生一个临时文件，但不会生成可执行文件，这个特点很适合用来调试程序。


下面就来演示一下，如何运行我们上一节中编写的Go语言程序。

因为之前我们已经配置好了环境变量，所以可以直接使用 Windows 自带的命令行工具（也叫 CMD 窗口或者命令提示符）来编译Go语言程序。微软后来对命令行工具进行了一次升级，并更名为 Powershell，power 是更加强大的意思。

打开命令行工具的方式多种多样，下面列出了比较常用的两种：

- 可以在开始菜单中打开命令行工具，然后 cd 到 Go 源文件所在的目录。
- 也可以在 Go 源文件所在目录的空白处按住 Shift 键并单击鼠标右键，然后在弹出菜单中选择“在此处打开命令行窗口”或者“在此处打开 Powershell 窗口”，这样会自动 cd 到 Go 源文件所在的目录，如下图所示。这种方式更加方便，推荐大家使用。

提示：cd 是命令行工具的一个命令，用来改变当前所在的目录，是 change directory 的缩写。

![img](http://c.biancheng.net/uploads/allimg/191022/1-191022135453b2.gif)
Win7 下选择“在此处打开命令窗口”

![img](http://c.biancheng.net/uploads/allimg/191017/4-19101G64932535.gif)
Win10 下选择“在此处打开 Powershell 窗口”

#### go build 命令

`go build`命令用来启动编译，它可以将Go语言程序与相关依赖编译成一个可执行文件，其语法格式如下。

go build fileName

其中 fileName 为所需要的参数，可以是一个或者多个 Go 源文件名（当有多个参数时需要使用空格将两个相邻的参数隔开），也可以省略不写。

使用 go build 命令进行编译时，不同参数的执行结果也是不同的。

##### 1) 当参数不为空时

如果 fileName 为同一 main 包下的所有源文件名（可能有一个或者多个），编译器将生成一个与第一个 fileName 同名的可执行文件（如执行`go build abc.go def.go ...`会生成一个 abc.exe 文件）；如果 fileName 为非 main 包下的源文件名，编译器将只对该包进行语法检查，不生成可执行文件。

##### 2) 当参数为空时

如果当前目录下存在 main 包，则会生成一个与当前目录名同名的“目录名.exe”可执行文件（如在 hello 目录中执行`go build`命令时，会生成 hello.exe 文件）；如果不存在 main 包，则只对当前目录下的程序源码进行语法检查，不会生成可执行文件。

使用`go build`命令对我们上一节编写的程序进行编译，运行结果如下所示：

D:\code> go build .\demo.go
D:\code> .\demo.exe
Hello World!

其中`D:\code>`对应的是当前目录，也就是 D 盘下的 code 文件夹，它是命令行工具自动添加的，不属于编译命令的一部分。

第 1 行`go build`命令后面的参数中，`.\`表示当前目录。在Windows 系统中，当前目录使用`.\`表示；在类 Unix 系统（例如 Linux、MacOS 等）中，当前目录使用`./`表示。

注意，这里的`go build`命令中`.\`可以省略不写，不会影响编译。

另外，`go build`命令只有在执行出错的情况下才会有返回信息，执行成功的话是没有返回信息的，但是会在当前目录生成一个与 main 包文件同名的 .exe 可执行文件，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/191017/4-19101G64RA16.gif)


第 2 行中的`.\demo.exe`表示执行当前目录下的 demo.exe 程序。

第 3 行则是 demo.exe 程序的运行结果。

##### go run 命令

除了使用`go build`命令外，Go语言还为我们提供了`go run`命令，`go run`命令将编译和执行指令合二为一，会在编译之后立即执行Go语言程序，但是不会生成可执行文件。

`go run`命令的语法格式如下：

go run fileName

其中 fileName 为所需要的参数，参数必须是同一 main 包下的所有源文件名，并且不能为空。

使用`go run`命令对我们上一节编写的程序进行编译，运行结果如下所示：

```go
D:\code> go run demo.go
Hello World!
```

可以看到第 1 行的`go run`命令执行后，直接在第 2 行输出了程序的运行结果。

除了本节中所讲的，`go build`命令和`go run`命令还有很多其他的编译方法，我们将在后面为大家详细介绍。

### 18. 使用Goland创建并运行项目

#### 创建项目

首先，在“文件”菜单中找到“New”，并在下一级菜单中选择“Project”来创建一个新项目。



![新建项目](http://c.biancheng.net/uploads/allimg/191024/4-1910241G000108.gif)
在菜单中选择新建项目


为项目选择一个目录（尽量选择空目录），并点击“Create”完成创建。



![img](http://c.biancheng.net/uploads/allimg/191024/4-1910241K4505E.gif)

创建项目

#### 编辑运行/调试配置

每次创建项目之后，我们都需要对 Goland 进行一些配置，在 Goland 的右上方找到“Add Configuration”并单击。



![点击 Add Configuration](http://c.biancheng.net/uploads/allimg/191029/4-191029133130V4.gif)
点击 Add Configuration


在弹出的窗口中点击“+”，并在下拉菜单中选择“Go Build”。



![编辑配置信息](http://c.biancheng.net/uploads/allimg/191029/4-191029115120K4.gif)
编辑配置信息


点击“Go Build”之后，在窗口中填写对应的信息，如下所示。



![img](http://c.biancheng.net/uploads/allimg/191029/4-19102912220C93.gif)


上图中有以下几点需要注意：

- 名称：为本条配置信息的名称，可以自定义，也可以使用系统默认的值；
- Run kind：这里需要设置为“Directory”；
- Directory：用来设置 main 包所在的目录，不能为空；
- Output directory：用来设置编译后生成的可执行文件的存放目录，可以为空，为空时默认不生成可执行文件；
- Working directory：用来设置程序的运行目录，可以与“Directory”的设置相同，但是不能为空。

提示：除了上面提到的几点外，其余的配置项使用系统的默认值即可，无需修改。

#### 编写并运行代码

将 Goland 配置好后，就可以在项目文件夹下编写代码了。首先新建一个 Go 源文件，在项目文件夹上点击右键，然后在弹出的菜单中找到“新建”，并在下一级菜单中选择“Go File”，最后在弹出框中输入文件名（红框处）并选择“Empty file”，无误后按“Enter”键进行确认。



![新建Go文件](http://c.biancheng.net/uploads/allimg/191029/4-19102911064TZ.gif)
新建 Go 源文件


在新创建的 Go 源文件中写入如下代码。



![编写测试代码](http://c.biancheng.net/uploads/allimg/191029/4-191029133504501.gif)
编写测试代码


然后，我们就可以点击 Goland 右上方的绿色三角来运行上面编写的程序了。



![运行程序](http://c.biancheng.net/uploads/allimg/191029/4-191029132004436.gif)
运行程序

### 19. Goland常用快捷键

本节来介绍一下 Goland 中快捷键的设置以及一些常用的快捷键。

#### Goland 快捷键设置

Goland 可以模拟各种编辑器的快捷键，例如 Eclipse、Sublime Text 等。

大家可以在“文件”菜单中找到“设置”，然后在新弹出的窗口选择“快捷键”选项，就可以对快捷键进行编辑了，如下图所示。



![编辑快捷键](http://c.biancheng.net/uploads/allimg/191028/4-19102P95535642.gif)
编辑快捷键

#### Goland 常用快捷键

下面列举了一些 Goland 中经常使用到的快捷键。

1) 文件操作相关的快捷键

| 快捷键           | 作用                                 |
| ---------------- | ------------------------------------ |
| Ctrl + E         | 打开最近浏览过的文件                 |
| Ctrl + N         | 快速打开某个 struct 结构体所在的文件 |
| Ctrl + Shift + N | 快速打开文件                         |
| Shift + F6       | 重命名文件夹、文件、方法、变量名等   |


2) 代码格式化相关的快捷键

| 快捷键           | 作用                                                         |
| ---------------- | ------------------------------------------------------------ |
| Ctrl + Alt + L   | 格式化代码                                                   |
| Ctrl + 空格      | 代码提示                                                     |
| Ctrl + /         | 单行注释                                                     |
| Ctrl + Shift + / | 多行注释                                                     |
| Ctrl + B 或 F4   | 快速跳转到结构体或方法的定义位置（需将光标移动到结构体或方法的名称上） |
| Ctrl +“+ 或 -”   | 可以将当前（光标所在位置）的方法进行展开或折叠               |


3) 查找和定位相关的快捷键

| 快捷键                 | 作用                     |
| ---------------------- | ------------------------ |
| Ctrl + R               | 替换文本                 |
| Ctrl + F               | 查找文本                 |
| Ctrl + Shift + F       | 全局查找                 |
| Ctrl + G               | 显示当前光标所在行的行号 |
| Ctrl + Shift + Alt + N | 查找类中的方法或变量     |


4) 编辑代码相关的快捷键

| 快捷键                      | 作用                                                         |
| --------------------------- | ------------------------------------------------------------ |
| Ctrl + J                    | 快速生成一个代码片段                                         |
| Shift+Enter                 | 向光标的下方插入一行，并将光标移动到该行的开始位置           |
| Ctrl + X                    | 删除当前光标所在行                                           |
| Ctrl + D                    | 复制当前光标所在行                                           |
| Ctrl + Shift + 方向键上或下 | 将光标所在的行进行上下移动（也可以使用 Alt+Shift+方向键上或下） |
| Alt + 回车                  | 自动导入需要导入的包                                         |
| Ctrl + Shift + U            | 将选中的内容进行大小写转化                                   |
| Alt + Insert                | 生成测试代码                                                 |
| Alt + Up/Down               | 快速移动到上一个或下一个方法                                 |
| Ctrl + Alt + Space          | 类名或接口名提示（代码提示）                                 |
| Ctrl + P                    | 提示方法的参数类型（需在方法调用的位置使用，并将光标移动至`( )`的内部或两侧） |


5) 编辑器相关的快捷键

| 快捷键                  | 作用                                 |
| ----------------------- | ------------------------------------ |
| Ctrl + Alt + left/right | 返回至上次浏览的位置                 |
| Alt + left/right        | 切换代码视图                         |
| Ctrl + W                | 快速选中代码                         |
| Alt + F3                | 逐个向下查找选中的代码，并高亮显示   |
| Tab                     | 代码标签输入完成后，按 Tab，生成代码 |
| F2 或 Shift + F2        | 快速定位错误或警告                   |
| Alt + Shift + C         | 查看最近的操作                       |
| Alt + 1                 | 快速打开或隐藏工程面板               |

## 第二章  基本语法

### 1. 语言变量的声明

Go语言是静态类型语言，因此变量（variable）是有明确类型的，编译器也会检查变量类型的正确性。在数学概念中，变量表示没有固定值且可改变的数。但从计算机系统实现角度来看，变量是一段或多段用来存储数据的内存。

声明变量的一般形式是使用 var 关键字：

```go
var name type
```

其中，var 是声明变量的关键字，name 是变量名，type 是变量的类型。

需要注意的是，Go语言和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。这样做的好处就是可以避免像C语言中那样含糊不清的声明形式，例如：`int* a, b;` 。其中只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。而在 Go 中，则可以和轻松地将它们都声明为指针类型：

```go
var a, b *int
```

Go语言的基本类型有：

- bool
- string
- int、int8、int16、int32、int64
- uint、uint8、uint16、uint32、uint64、uintptr
- byte // uint8 的别名
- rune // int32 的别名 代表一个 Unicode 码
- float32、float64
- complex64、complex128


当一个变量被声明之后，系统自动赋予它该类型的零值：int 为 0，float 为 0.0，bool 为 false，string 为空字符串，指针为 nil 等。所有的内存在 Go 中都是经过初始化的。

变量的命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：numShips 和 startDate 。

变量的声明有几种形式，通过下面几节进行整理归纳。

#### 标准格式

Go语言的变量声明的标准格式为：

```go
var 变量名 变量类型
```

变量声明以关键字 var 开头，后置变量类型，行尾无须分号。

#### 批量格式

觉得每行都用 var 声明变量比较烦琐？没关系，还有一种为懒人提供的定义变量的方法：

```go
var (
    a int
    b string
    c []float32
    d func() bool
    e struct {
        x int
    }
)
```

使用关键字 var 和括号，可以将一组变量定义放在一起。

#### 简短格式

除 var 关键字外，还可使用更加简短的变量定义和初始化语法。

```go
名字 := 表达式
```

需要注意的是，简短模式（short variable declaration）有以下限制：

- 定义变量，同时显式初始化。
- 不能提供数据类型。
- 只能用在函数内部。


和 var 形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：

```go
i, j := 0, 1
```

下面通过一段代码来演示简短格式变量声明的基本样式。

```go
func main() {
   x:=100
   a,s:=1, "abc"
}
```

因为简洁和灵活的特点，简短变量声明被广泛用于大部分的局部变量的声明和初始化。var 形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。

### 2. 变量的初始化

正如上一节《[Go语言变量声明](http://c.biancheng.net/view/9.html)》中提到的[Go语言](http://c-local.biancheng.net/golang/)在声明变量时，自动对变量对应的内存区域进行初始化操作。每个变量会初始化其类型的默认值，例如：

- 整型和浮点型变量的默认值为 0 和 0.0。
- 字符串变量的默认值为空字符串。
- 布尔型变量默认为 bool。
- 切片、函数、指针变量的默认为 nil。


当然，依然可以在变量声明时赋予变量一个初始值。

#### 回顾C语言

在C语言中，变量在声明时，并不会对变量对应内存区域进行清理操作。此时，变量值可能是完全不可预期的结果。开发者需要习惯在使用C语言进行声明时要初始化操作，稍有不慎，就会造成不可预知的后果。

在网络上只有程序员才能看懂的“烫烫烫”和“屯屯屯”的梗，就来源于 C/[C++](http://c.biancheng.net/cplus/) 中变量默认不初始化。

微软的 VC 编译器会将未初始化的栈空间以 16 进制的 0xCC 填充，而未初始化的堆空间使用 0xCD 填充，而 0xCCCC 和 0xCDCD 在中文的 GB2312 编码中刚好对应“烫”和“屯”字。

因此，如果一个字符串没有结束符`\0`，直接输出的内存数据转换为字符串就刚好对应“烫烫烫”和“屯屯屯”。

#### 变量初始化的标准格式

```go
var 变量名 类型 = 表达式
```

例如，游戏中，玩家的血量初始值为100。可以这样写：

```go
var hp int = 100
```

这句代码中，hp 为变量名，类型为 int，hp 的初始值为 100。

上面代码中，100 和 int 同为 int 类型，int 可以认为是冗余信息，因此可以进一步简化初始化的写法。

#### 编译器推导类型的格式

在标准格式的基础上，将 int 省略后，编译器会尝试根据等号右边的表达式推导 hp 变量的类型。

```go
var hp = 100
```

等号右边的部分在编译原理里被称做右值（rvalue）。

下面是编译器根据右值推导变量类型完成初始化的例子。

```go
var attack = 40
var defence = 20
var damageRate float32 = 0.17
var damage = float32(attack-defence) * damageRate
fmt.Println(damage)
```

代码说明如下：

- 第 1 和 2 行，右值为整型，attack 和 defence 变量的类型为 int。

- 第 3 行，表达式的右值中使用了 0.17。由于Go语言和C语言一样，编译器会尽量提高精确度，以避免计算中的精度损失。所以这里如果不指定 damageRate 变量的类型，Go语言编译器会将 damageRate 类型推导为 float64，我们这里不需要 float64 的精度，所以需要强制指定类型为 float32。

- 第 4 行，将 attack 和 defence 相减后的数值结果依然为整型，使用 float32() 将结果转换为 float32 类型，再与 float32 类型的 damageRate 相乘后，damage 类型也是 float32 类型。

  > 提示：damage 变量的右值是一个复杂的表达式，整个过程既有 attack 和 defence 的运算还有强制类型转换。强制类型转换会在后面的章节中介绍。

- 第 5 行，输出 damage 的值。


以上代码输出结果为：

```go
3.4
```

#### 短变量声明并初始化

var 的变量声明还有一种更为精简的写法，例如：

```go
hp := 100
```

这是Go语言的推导声明写法，编译器会自动根据右值类型推断出左值的对应类型。

> 注意：由于使用了`:=`，而不是赋值的`=`，因此推导声明写法的左值变量必须是没有定义过的变量。若定义过，将会发生编译错误。

如果 hp 已经被声明过，但依然使用`:=`时编译器会报错，代码如下：

```go
// 声明 hp 变量
var hp int
// 再次声明并赋值
hp := 10
```

编译报错如下：

```go
no new variables on left side of :=
```

意思是，在“:=”的左边没有新变量出现，意思就是“:=”的左边变量已经被声明了。

短变量声明的形式在开发中的例子较多，比如：

```go
conn, err := net.Dial("tcp","127.0.0.1:8080")
```

net.Dial 提供按指定协议和地址发起网络连接，这个函数有两个返回值，一个是连接对象（conn），一个是错误对象（err）。如果是标准格式将会变成：

```go
var conn net.Conn
var err error
conn, err = net.Dial("tcp", "127.0.0.1:8080")
```

因此，短变量声明并初始化的格式在开发中使用比较普遍。

注意：在多个短变量声明和赋值中，至少有一个新声明的变量出现在左值中，即便其他变量名可能是重复声明的，编译器也不会报错，代码如下：

```go
conn, err := net.Dial("tcp", "127.0.0.1:8080")
conn2, err := net.Dial("tcp", "127.0.0.1:8080")
```

上面的代码片段，编译器不会报 err 重复定义。

### 3. 多个变量同时赋值

编程最简单的算法之一，莫过于变量交换。交换变量的常见算法需要一个中间变量进行变量的临时保存。用传统方法编写变量交换代码如下：

```go
var a int = 100
var b int = 200
var t int
t = a
a = b
b = t
fmt.Println(a, b)
```

在计算机刚发明时，内存非常“精贵”。这种变量交换往往是非常奢侈的。于是计算机“大牛”发明了一些算法来避免使用中间变量：

```go
var a int = 100
var b int = 200
a = a ^ b
b = b ^ a
a = a ^ b
fmt.Println(a, b)
```

这样的算法很多，但是都有一定的数值范围和类型要求。

到了Go语言时，内存不再是紧缺资源，而且写法可以更简单。使用 Go 的“多重赋值”特性，可以轻松完成变量交换的任务：

```go
var a int = 100
var b int = 200
b, a = a, b
fmt.Println(a, b)
```

多重赋值时，变量的左值和右值按从左到右的顺序赋值。

多重赋值在Go语言的错误处理和函数返回值中会大量地使用。例如使用Go语言进行排序时就需要使用交换，代码如下：

```go
type IntSlice []int
func (p IntSlice) Len() int           { return len(p) }
func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
```

代码说明如下：

- 第 1 行，将 IntSlice 声明为 []int 类型。
- 第 3 行，为 IntSlice 类型编写一个 Len 方法，提供切片的长度。
- 第 4 行，根据提供的 i、j 元素索引，获取元素后进行比较，返回比较结果。
- 第 5 行，根据提供的 i、j 元素索引，交换两个元素的值。

### 4.匿名变量

在编码过程中，可能会遇到没有名称的变量、类型或方法。虽然这不是必须的，但有时候这样做可以极大地增强代码的灵活性，这些变量被统称为匿名变量。

匿名变量的特点是一个下画线“_”，“_”本身就是一个特殊的标识符，被称为空白标识符。它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量对其它变量进行赋值或运算。使用匿名变量时，只需要在变量声明的地方使用下画线替换即可。例如：

```go
func GetData() (int, int) {
    return 100, 200
}
func main(){
    a, _ := GetData()
    _, b := GetData()
    fmt.Println(a, b)
}
```

代码运行结果：

```
100 200
```

GetData() 是一个函数，拥有两个整型返回值。每次调用将会返回 100 和 200 两个数值。

代码说明如下：

- 第 5 行只需要获取第一个返回值，所以将第二个返回值的变量设为下画线（匿名变量）。
- 第 6 行将第一个返回值的变量设为匿名变量。


`匿名变量不占用内存空间，不会分配内存。匿名变量与匿名变量之间也不会因为多次声明而无法使用。`

提示：在 Lua 等编程语言里，匿名变量也被叫做哑元变量。

### 5. 变量的作用域

一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。

了解变量的作用域对我们学习Go语言来说是比较重要的，因为Go语言会在编译时检查每个变量是否使用过，一旦出现未使用的变量，就会报编译错误。如果不能理解变量的作用域，就有可能会带来一些不明所以的编译错误。

根据变量定义位置的不同，可以分为以下三个类型：

- 函数内定义的变量称为局部变量
- 函数外定义的变量称为全局变量
- 函数定义中的变量称为形式参数


下面就来分别介绍一下。

#### 局部变量

在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。

局部变量不是一直存在的，它只在定义它的函数被调用后存在，函数调用结束后这个局部变量就会被销毁。

【示例】下面的 main() 函数中使用到了局部变量 a、b、c。

```go
package mainimport (    "fmt")func main() {    //声明局部变量 a 和 b 并赋值    var a int = 3    var b int = 4    //声明局部变量 cpackage main
import (
    "fmt"
)
func main() {
    //声明局部变量 a 和 b 并赋值
    var a int = 3
    var b int = 4
    //声明局部变量 c 并计算 a 和 b 的和
    c := a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
} 并计算 a 和 b 的和    c := a + b    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)}
```

运行结果如下所示：

```go
a = 3, b = 4, c = 7
```

#### 全局变量

在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。

全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。

【示例】下面代码中，第 6 行定义了全局变量 c。

```go
package main
import "fmt"
//声明全局变量
var c int
func main() {
    //声明局部变量
    var a, b int
    //初始化参数
    a = 3
    b = 4
    c = a + b
    fmt.Printf("a = %d, b = %d, c = %d\n", a, b, c)
}
```

运行结果如下所示：

```go
a = 3, b = 4, c = 7
```

Go语言程序中全局变量与局部变量名称可以相同，但是函数体内的局部变量会被优先考虑。

```go
package main
import "fmt"
//声明全局变量
var a float32 = 3.14
func main() {
    //声明局部变量
    var a int = 3
    fmt.Printf("a = %d\n", a)
}
```

运行结果如下所示：

```go
a = 3
```

#### 形式参数

在定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。

形式参数会作为函数的局部变量来使用。

【示例】下面代码中第 21 行定义了形式参数 a 和 b。

```go
package main
import (
    "fmt"
)
//全局变量 a
var a int = 13
func main() {
    //局部变量 a 和 b
    var a int = 3
    var b int = 4
    fmt.Printf("main() 函数中 a = %d\n", a)
    fmt.Printf("main() 函数中 b = %d\n", b)
    c := sum(a, b)
    fmt.Printf("main() 函数中 c = %d\n", c)
}
func sum(a, b int) int {
    fmt.Printf("sum() 函数中 a = %d\n", a)
    fmt.Printf("sum() 函数中 b = %d\n", b)
    num := a + b
    return num
}
```

运行结果如下所示：

```go
main() 函数中 a = 3
main() 函数中 b = 4
sum() 函数中 a = 3
sum() 函数中 b = 4
main() 函数中 c = 7
```

### 6. 整数类型

Go语言的数值类型分为以下几种：整数、浮点数、复数，其中每一种都包含了不同大小的数值类型，例如有符号整数包含 int8、int16、int32、int64 等，每种数值类型都决定了对应的大小范围和是否支持正负符号。本节我们主要介绍一下整数类型。

Go语言同时提供了有符号和无符号的整数类型，其中包括 int8、int16、int32 和 int64 四种大小截然不同的有符号整数类型，分别对应 8、16、32、64 bit（二进制位）大小的有符号整数，与此对应的是 uint8、uint16、uint32 和 uint64 四种无符号整数类型。

此外还有两种整数类型 int 和 uint，它们分别对应特定 CPU 平台的字长（机器字大小），其中 int 表示有符号整数，应用最为广泛，uint 表示无符号整数。实际开发中由于编译器和计算机硬件的不同，int 和 uint 所能表示的整数大小会在 32bit 或 64bit 之间变化。

大多数情况下，我们只需要 int 一种整型即可，它可以用于循环计数器（for 循环中控制循环次数的变量）、数组和切片的索引，以及任何通用目的的整型运算符，通常 int 类型的处理速度也是最快的。

用来表示 Unicode 字符的 rune 类型和 int32 类型是等价的，通常用于表示一个 Unicode 码点。这两个名称可以互换使用。同样，byte 和 uint8 也是等价类型，byte 类型一般用于强调数值是一个原始的数据而不是一个小的整数。

最后，还有一种无符号的整数类型 uintptr，它没有指定具体的 bit 大小但是足以容纳指针。uintptr 类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方。

尽管在某些特定的运行环境下 int、uint 和 uintptr 的大小可能相等，但是它们依然是不同的类型，比如 int 和 int32，虽然 int 类型的大小也可能是 32 bit，但是在需要把 int 类型当做 int32 类型使用的时候必须显示的对类型进行转换，反之亦然。

Go语言中有符号整数采用 2 的补码形式表示，也就是最高 bit 位用来表示符号位，一个 n-bit 的有符号数的取值范围是从 -2(n-1) 到 2(n-1)-1。无符号整数的所有 bit 位都用于表示非负数，取值范围是 0 到 2n-1。例如，int8 类型整数的取值范围是从 -128 到 127，而 uint8 类型整数的取值范围是从 0 到 255。

#### 哪些情况下使用 int 和 uint

程序逻辑对整型范围没有特殊需求。例如，对象的长度使用内建 len() 函数返回，这个长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用 int 来表示。

反之，在二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用 int 和 uint。

### 7. 浮点类型

Go语言提供了两种精度的浮点数 float32 和 float64，它们的算术规范由 IEEE754 浮点数国际标准定义，该浮点数规范被所有现代的 CPU 支持。

这些浮点数类型的取值范围可以从很微小到很巨大。浮点数取值范围的极限值可以在 math 包中找到：

- 常量 math.MaxFloat32 表示 float32 能取到的最大数值，大约是 3.4e38；
- 常量 math.MaxFloat64 表示 float64 能取到的最大数值，大约是 1.8e308；
- float32 和 float64 能表示的最小值分别为 1.4e-45 和 4.9e-324。


一个 float32 类型的浮点数可以提供大约 6 个十进制数的精度，而 float64 则可以提供约 15 个十进制数的精度，通常应该优先使用 float64 类型，因为 float32 类型的累计计算误差很容易扩散，并且 float32 能精确表示的正整数并不是很大。

```go
var f float32 = 16777216 // 1 << 24
fmt.Println(f == f+1)    // "true"!
```

浮点数在声明的时候可以只写整数部分或者小数部分，像下面这样：

```go
const e = .71828 // 0.71828
const f = 1.     // 1
```

很小或很大的数最好用科学计数法书写，通过 e 或 E 来指定指数部分：

```go
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数
```

用 Printf 函数打印浮点数时可以使用“%f”来控制保留几位小数

```go
package main
import (
    "fmt"
    "math"
)
func main() {
    fmt.Printf("%f\n", math.Pi)
    fmt.Printf("%.2f\n", math.Pi)
}
```

运行结果如下所示：

```go
3.141593
3.14
```

### 8. 复数

在计算机中，复数是由两个浮点数表示的，其中一个表示实部（real），一个表示虚部（imag）。

Go语言中复数的类型有两种，分别是 complex128（64 位实数和虚数）和 complex64（32 位实数和虚数），其中 complex128 为复数的默认类型。

复数的值由三部分组成 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，RE 和 IM 均为 float 类型，而最后的 i 是虚数单位。

声明复数的语法格式如下所示：

```go
var name complex128 = complex(x, y)
```

其中 name 为复数的变量名，complex128 为复数的类型，“=”后面的 complex 为Go语言的内置函数用于为复数赋值，x、y 分别表示构成该复数的两个 float64 类型的数值，x 为实部，y 为虚部。

上面的声明语句也可以简写为下面的形式：

```go
name := complex(x, y)
```

对于一个复数`z := complex(x, y)`，可以通过Go语言的内置函数`real(z) `来获得该复数的实部，也就是 x；通过`imag(z) `获得该复数的虚部，也就是 y。

【示例】使用内置的 complex 函数构建复数，并使用 real 和 imag 函数返回复数的实部和虚部：

```go
var x complex128 = complex(1, 2) // 1+2i
var y complex128 = complex(3, 4) // 3+4i
fmt.Println(x*y)                 // "(-5+10i)"
fmt.Println(real(x*y))           // "-5"
fmt.Println(imag(x*y))           // "10"
```

如果大家对复数的运算法则不是很了解，可以查阅《[复数运算法则](https://baike.baidu.com/item/复数运算法则/2568041?fr=aladdin)》，其中详细的讲解了复数的加减乘除操作。

复数也可以用`==`和`!=`进行相等比较，只有两个复数的实部和虚部都相等的时候它们才是相等的。

Go语言内置的 math/cmplx 包中提供了很多操作复数的公共方法，实际操作中建议大家使用复数默认的 complex128 类型，因为这些内置的包中都使用 complex128 类型作为参数。

### 9. 输出正弦函数（Sin）图像

在 Go 语言中，正弦函数由 math 包提供，函数入口为 math.Sin，正弦函数的参数为 float64，返回值也是 float64。在使用正弦函数时，根据实际精度可以进行转换。

Go 语言的标准库支持对图片像素进行访问，并且支持输出各种图片格式，如 JPEG、PNG、GIF 等。

首先给出本节完整的代码：

```go
  package main

  import (
      "image"
      "image/color"
      "image/png"
      "log"
      "math"
      "os"
  )

  func main() {

      // 图片大小
      const size = 300
      // 根据给定大小创建灰度图
      pic := image.NewGray(image.Rect(0, 0, size, size))

      // 遍历每个像素
      for x := 0; x < size; x++ {
          for y := 0; y < size; y++ {
              // 填充为白色
              pic.SetGray(x, y, color.Gray{255})
          }
      }

      // 从0到最大像素生成x坐标
      for x := 0; x < size; x++ {

          // 让sin的值的范围在0~2Pi之间
          s := float64(x) * 2 * math.Pi / size
          // sin的幅度为一半的像素。向下偏移一半像素并翻转
          y := size/2 - math.Sin(s)*size/2

          // 用黑色绘制sin轨迹
          pic.SetGray(x, int(y), color.Gray{0})
      }

      // 创建文件
      file, err := os.Create("sin.png")
      if err != nil {
          log.Fatal(err)
      }
      // 使用png格式将数据写入文件
      png.Encode(file, pic) //将image信息写入文件中

      // 关闭文件
      file.Close()
  }
```

#### 设置图片背景色

以下是设置图片背景的代码：

```go
  // 图片大小
  const size = 300

  // 根据给定大小创建灰度图
  pic := image.NewGray(image.Rect(0, 0, size, size))

 // 遍历每个像素
 for x := 0; x < size; x++ {
      for y := 0; y < size; y++ {
          // 填充为白色
          pic.SetGray(x, y, color.Gray{255})
      }
  }
```

代码说明如下：

- 第 2 行，声明一个 size 常量，值为 300。

- 第 5 行，使用 image 包的 NewGray() 函数创建一个图片对象，使用区域由 image.Rect 结构提供，image.Rect 描述一个方形的两个定位点 (x1,y1) 和 (x2,y2)，image.Rect(0,0,size,size) 表示使用完整灰度图像素，尺寸为宽 300，长 300。

- 第 8 行和第 9 行，遍历灰度图的所有像素。

- 第 11 行，将每一个像素的灰度设为 255，也就是白色。

灰度图是一种常见的图片格式，一般情况下颜色由 8 位组成，灰度范围为 0～255，0 表示黑色，255 表示白色。

初始化好的灰度图默认的灰度值都是 0，对的是黑色，由于显示效果的效果不是很好，所以这里将所有像素设置为 255，也就是白色。

#### 绘制正弦函数轨迹

正弦函数是一个周期函数，定义域是实数集，取值范围是 [-1, 1]。用编程的通俗易懂的话来说就是：math.Sin 函数的参数支持任意浮点数范围，函数返回值的范围总是在 -1～1 之间（包含 1、-1）。

要将正弦函数放在图片上需要考虑以下一些因素：

- math.Sin 的返回值在 -1～1 之间，需要考虑将正弦的输出幅度变大，可以将 math.Sin 的返回值乘以一个常量进行放大。

- 图片的坐标系原点在左上角，而 math.Sin 基于笛卡尔坐标系原点在左下角，需要对图像进行上下翻转和平移。

将这些处理逻辑汇总为代码如下：

```go
  // 从0到最大像素生成x坐标
  for x := 0; x < size; x++ {

      // 让sin的值的范围在0~2Pi之间
      s := float64(x) * 2 * math.Pi / size

      // sin的幅度为一半的像素。向下偏移一半像素并翻转
      y := size/2 - math.Sin(s)*size/2

      // 用黑色绘制sin轨迹
      pic.SetGray(x, int(y), color.Gray{0})
  }
```

代码说明如下： 1) 第 2 行，生成 0 到 size（300）的 x 坐标轴。

1. 第 5 行，计算 math.Sin 的定义域，这段代码等效为：

```go
  rate := x / size
  s := rate * 2 * math.Pi
```

x 的范围是 0 到 size，因此除以 size 后，rate 的范围是 0～1 之间，再乘以 2π 后，s 的范围刚好是 0～2π 之间。

float64(x) 表示将整型的 x 变量转换为 float64 类型，之后运算的所有表达式将以 float64 类型进行。

1. 第 8 行中，math.Sin(s)*size/2 表示将正弦函数的返回值幅度从 1 扩大到二分之一的 size。负号表示将正弦函数图形以图形中心上下翻转。叠加 size/2 表示将图形在 y 轴上向下偏移二分之一的 size（图片坐标系的 y 向下）。

1. 第 11 行将计算好的 x 轴和 y 轴数据，以灰度为 0（黑色）使用 SetGray() 方法填充到像素中。

写入图片的正弦函数图像如下图所示：

[![img](http://c.biancheng.net/uploads/allimg/180810/1-1PQ01IS2215.png)](http://c.biancheng.net/uploads/allimg/180810/1-1PQ01IS2215.png)

#### 写入图片文件

内存中的正弦函数图形是不可见的，我们选用 PNG 格式将图形输出为文件，Go 语言提供了文件创建函数和 PNG 格式写入函数，代码如下：

```go
  // 创建文件
  file, err := os.Create("sin.png")

  if err != nil {
      log.Fatal(err)
  }
  // 使用PNG格式将数据写入文件
  png.Encode(file, pic)  //将image信息写入文件中

  // 关闭文件
  file.Close()
```

代码说明如下：

- 第 2 行，创建 sin.png 的文件。

- 第 4 行，如果创建文件失败，返回错误，打印错误并终止。

- 第 8 行，使用 PNG 包，将图形对象写入文件中。

- 第 11 行，关闭文件。

### 10. bool类型

一个布尔类型的值只有两种：true 或 false。if 和 for 语句的条件部分都是布尔类型的值，并且`==`和`<`等比较操作也会产生布尔型的值。

一元操作符`!`对应逻辑非操作，因此`!true`的值为 false，更复杂一些的写法是`(!true==false) ==true`，实际开发中我们应尽量采用比较简洁的布尔表达式，就像用 x 来表示`x==true`。

```go
var aVar = 10
aVar == 5  // false
aVar == 10 // true
aVar != 5  // true
aVar != 10 // false
```

Go语言对于值之间的比较有非常严格的限制，只有两个相同类型的值才可以进行比较，如果值的类型是接口（interface），那么它们也必须都实现了相同的接口。如果其中一个值是常量，那么另外一个值可以不是常量，但是类型必须和该常量类型相同。如果以上条件都不满足，则必须将其中一个值的类型转换为和另外一个值的类型相同之后才可以进行比较。

布尔值可以和 &&（AND）和 ||（OR）操作符结合，并且有短路行为，如果运算符左边的值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：

```go
s != "" && s[0] == 'x'
```

其中 s[0] 操作如果应用于空字符串将会导致 panic 异常。

因为`&&`的优先级比`||`高（&& 对应逻辑乘法，|| 对应逻辑加法，乘法比加法优先级要高），所以下面的布尔表达式可以不加小括号：

```go
if 'a' <= c && c <= 'z' ||
    'A' <= c && c <= 'Z' ||
    '0' <= c && c <= '9' {
    // ...ASCII字母或数字...
}
```

布尔值并不会隐式转换为数字值 0 或 1，反之亦然，必须使用 if 语句显式的进行转换：

```go
i := 0
if b {
    i = 1
}
```

如果需要经常做类似的转换，可以将转换的代码封装成一个函数，如下所示：

```go
// 如果b为真，btoi返回1；如果为假，btoi返回0
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

数字到布尔型的逆转换非常简单，不过为了保持对称，我们也可以封装一个函数：

```go
// itob报告是否为非零。
func itob(i int) bool { return i != 0 }
```

Go语言中不允许将整型强制转换为布尔型，代码如下：

```go
var n boolfmt.Println(int(n) * 2)
```

编译错误，输出如下：

```go
cannot convert n (type bool) to type int
```

布尔型无法参与数值运算，也无法与其他类型进行转换。

### 11. 字符串

一个字符串是一个不可改变的字节序列，字符串可以包含任意的数据，但是通常是用来包含可读的文本，字符串是 UTF-8 字符的一个序列（当字符为 ASCII 码表上的字符时则占用 1 个字节，其它字符根据需要占用 2-4 个字节）。

UTF-8 是一种被广泛使用的编码格式，是文本文件的标准编码，其中包括 XML 和 JSON 在内也都使用该编码。由于该编码对占用字节长度的不定性，在Go语言中字符串也可能根据需要占用 1 至 4 个字节，这与其它编程语言如 [C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/) 或者 [Python](http://c.biancheng.net/python/) 不同（Java 始终使用 2 个字节）。Go语言这样做不仅减少了内存和硬盘空间占用，同时也不用像其它语言那样需要对使用 UTF-8 字符集的文本进行编码和解码。

字符串是一种值类型，且值不可变，即创建某个文本后将无法再次修改这个文本的内容，更深入地讲，字符串是字节的定长数组。

#### 定义字符串

可以使用双引号`""`来定义字符串，字符串中可以使用转义字符来实现换行、缩进等效果，常用的转义字符包括：

- \n：换行符
- \r：回车符
- \t：tab 键
- \u 或 \U：Unicode 字符
- \\：反斜杠自身

```go
package main
import (
    "fmt"
)
func main() {
    var str = "C语言中文网\nGo语言教程"
    fmt.Println(str)
}
```

运行结果为：

```go
C语言中文网
Go语言教程
```

一般的比较运算符（==、!=、<、<=、>=、>）是通过在内存中按字节比较来实现字符串比较的，因此比较的结果是字符串自然编码的顺序。字符串所占的字节长度可以通过函数 len() 来获取，例如 len(str)。

字符串的内容（纯字节）可以通过标准索引法来获取，在方括号`[ ]`内写入索引，索引从 0 开始计数：

- 字符串 str 的第 1 个字节：str[0]
- 第 i 个字节：str[i - 1]
- 最后 1 个字节：str[len(str)-1]


需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。

> 注意：获取字符串中某个字节的地址属于非法行为，例如 &str[i]。

#### 字符串拼接符“+”

两个字符串 s1 和 s2 可以通过 s := s1 + s2 拼接在一起。将 s2 追加到 s1 尾部并生成一个新的字符串 s。

可以通过下面的方式来对代码中多行的字符串进行拼接：

```go
str := "Beginning of the string " +
"second part of the string"
```

> 提示：因为编译器会在行尾自动补全分号，所以拼接字符串用的加号“+”必须放在第一行末尾。

也可以使用“+=”来对字符串进行拼接：

```go
s := "hel" + "lo,"
s += "world!"
fmt.Println(s) //输出 “hello, world!”
```

#### 字符串实现基于 UTF-8 编码

Go语言中字符串的内部实现使用 UTF-8 编码，通过 rune 类型，可以方便地对每个 UTF-8 字符进行访问。当然，Go语言也支持按照传统的 ASCII 码方式逐字符进行访问。

关于字符串的 UTF-8 字符访问的详细方法，后面的章节将会详细介绍。

#### 定义多行字符串

在Go语言中，使用双引号书写字符串的方式是字符串常见表达方式之一，被称为字符串字面量（string literal），这种双引号字面量不能跨行，如果想要在源码中嵌入一个多行字符串时，就必须使用```反引号，代码如下：

```go
const str = `第一行
第二行
第三行
\r\n
`
fmt.Println(str)
```

代码运行结果：

```go
第一行
第二行
第三行
\r\n
```

反引号` ` `，是键盘上 1 键左边的键，两个反引号间的字符串将被原样赋值到 str 变量中。

在这种方式下，反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。

多行字符串一般用于内嵌源码和内嵌数据等，代码如下：

```go
const codeTemplate = `// Generated by github.com/davyxu/cellnet/
protoc-gen-msg
// DO NOT EDIT!{{range .Protos}}
// Source: {{.Name}}{{end}}
package {{.PackageName}}
{{if gt .TotalMessages 0}}
import (
    "github.com/davyxu/cellnet"
    "reflect"
    _ "github.com/davyxu/cellnet/codec/pb"
)
{{end}}
func init() {
    {{range .Protos}}
    // {{.Name}}{{range .Messages}}
    cellnet.RegisterMessageMeta("pb","{{.FullName}}", reflect.TypeOf((*{{.Name}})(nil)).Elem(), {{.MsgID}})    {{end}}
    {{end}}
}
`
```

这段代码只定义了一个常量 codeTemplate，类型为字符串，使用```定义，字符串的内容为一段代码生成中使用到的 Go 源码格式。

在` ` `间的所有代码均不会被编译器识别，而只是作为字符串的一部分。

字符串类型在业务中的应用可以说是最广泛的，读者需要详细了解字符串的常见用法，请猛击下面的文章：

- [Go语言计算字符串长度——len()和RuneCountInString()](http://c.biancheng.net/view/36.html)
- [Go语言遍历字符串——获取每一个字符串元素](http://c.biancheng.net/view/37.html)
- [Go语言字符串截取（获取字符串的某一段字符）](http://c.biancheng.net/view/38.html)
- [Go语言修改字符串](http://c.biancheng.net/view/39.html)
- [Go语言字符串拼接（连接）](http://c.biancheng.net/view/40.html)
- [Go语言fmt.Sprintf（格式化输出）](http://c.biancheng.net/view/41.html)
- [Go语言Base64编码——电子邮件的基础编码格式](http://c.biancheng.net/view/42.html)

### 12. 字符类型

字符串中的每一个元素叫做“字符”，在遍历或者单个获取字符串元素时可以获得字符。

Go语言的字符有以下两种：

- 一种是 uint8 类型，或者叫 byte 型，代表了 ASCII 码的一个字符。
- 另一种是 rune 类型，代表一个 UTF-8 字符，当需要处理中文、日文或者其他复合字符时，则需要用到 rune 类型。rune 类型等价于 int32 类型。


byte 类型是 uint8 的别名，对于只占用 1 个字节的传统 ASCII 编码的字符来说，完全没有问题，例如 var ch byte = 'A'，字符使用单引号括起来。

在 ASCII 码表中，A 的值是 65，使用 16 进制表示则为 41，所以下面的写法是等效的：

var ch byte = 65 或 var ch byte = '\x41'   //（\x 总是紧跟着长度为 2 的 16 进制数）

另外一种可能的写法是`\`后面紧跟着长度为 3 的八进制数，例如 \377。

Go语言同样支持 Unicode（UTF-8），因此字符同样称为 Unicode 代码点或者 runes，并在内存中使用 int 来表示。在文档中，一般使用格式 U+hhhh 来表示，其中 h 表示一个 16 进制数。

在书写 Unicode 字符时，需要在 16 进制数之前加上前缀`\u`或者`\U`。因为 Unicode 至少占用 2 个字节，所以我们使用 int16 或者 int 类型来表示。如果需要使用到 4 字节，则使用`\u`前缀，如果需要使用到 8 个字节，则使用`\U`前缀。

```go
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3)   // UTF-8 code point
```

输出：

```go
65 - 946 - 1053236
A - β - r
41 - 3B2 - 101234
U+0041 - U+03B2 - U+101234
```

格式化说明符`%c`用于表示字符，当和字符配合使用时，`%v`或`%d`会输出用于表示该字符的整数，`%U`输出格式为 U+hhhh 的字符串。

Unicode 包中内置了一些用于测试字符的函数，这些函数的返回值都是一个布尔值，如下所示（其中 ch 代表字符）：

- 判断是否为字母：unicode.IsLetter(ch)
- 判断是否为数字：unicode.IsDigit(ch)
- 判断是否为空白符号：unicode.IsSpace(ch)

#### UTF-8 和 Unicode 有何区别？

Unicode 与 ASCII 类似，都是一种字符集。

字符集为每个字符分配一个唯一的 ID，我们使用到的所有字符在 Unicode 字符集中都有一个唯一的 ID，例如上面例子中的 a 在 Unicode 与 ASCII 中的编码都是 97。汉字“你”在 Unicode 中的编码为 20320，在不同国家的字符集中，字符所对应的 ID 也会不同。而无论任何情况下，Unicode 中的字符的 ID 都是不会变化的。

UTF-8 是编码规则，将 Unicode 中字符的 ID 以某种方式进行编码，UTF-8 的是一种变长编码规则，从 1 到 4 个字节不等。编码规则如下：

- 0xxxxxx 表示文字符号 0～127，兼容 ASCII 字符集。
- 从 128 到 0x10ffff 表示其他字符。


根据这个规则，拉丁文语系的字符编码一般情况下每个字符占用一个字节，而中文每个字符占用 3 个字节。

广义的 Unicode 指的是一个标准，它定义了字符集及编码规则，即 Unicode 字符集和 UTF-8、UTF-16 编码等。

### 13. 数据类型转换

在必要以及可行的情况下，一个类型的值可以被转换成另一种类型的值。由于Go语言不存在隐式类型转换，因此所有的类型转换都必须显式的声明：

```go
valueOfTypeB = typeB(valueOfTypeA)
```

类型 B 的值 = 类型 B(类型 A 的值)

示例：

```go
a := 5.0
b := int(a)
```

类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将 int16 转换为 int32）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将 int32 转换为 int16 或将 float32 转换为 int），会发生精度丢失（截断）的情况。

只有相同底层类型的变量之间可以进行相互转换（如将 int16 类型转换成 int32 类型），不同底层类型的变量相互转换时会引发编译错误（如将 bool 类型转换为 int 类型）：

```go
package main
import (
        "fmt"
        "math"
)
func main() {
        // 输出各数值范围
        fmt.Println("int8 range:", math.MinInt8, math.MaxInt8)
        fmt.Println("int16 range:", math.MinInt16, math.MaxInt16)
        fmt.Println("int32 range:", math.MinInt32, math.MaxInt32)
        fmt.Println("int64 range:", math.MinInt64, math.MaxInt64)
        // 初始化一个32位整型值
        var a int32 = 1047483647
        // 输出变量的十六进制形式和十进制值
        fmt.Printf("int32: 0x%x %d\n", a, a)
        // 将a变量数值转换为十六进制, 发生数值截断
        b := int16(a)
        // 输出变量的十六进制形式和十进制值
        fmt.Printf("int16: 0x%x %d\n", b, b)
        // 将常量保存为float32类型
        var c float32 = math.Pi
        // 转换为int类型, 浮点发生精度丢失
        fmt.Println(int(c))
}
```

代码说明如下：

- 第 11～14 行，输出几个常见整型类型的数值范围。
- 第 17 行，声明 int32 类型的变量 a 并初始化。
- 第 19 行，使用 fmt.Printf 的`%x`动词将数值以十六进制格式输出，这一行输出 a 在转换前的 32 位的值。
- 第 22 行，将 a 的值转换为 int16 类型，也就是从 32 位有符号整型转换为 16 位有符号整型，由于 int16 类型的取值范围比 int32 类型的取值范围小，因此数值会进行截断（精度丢失）。
- 第 24 行，输出转换后的 a 变量值，也就是 b 的值，同样以十六进制和十进制两种方式进行打印。
- 第 27 行，math.Pi 是 math 包的常量，默认没有类型，会在引用到的地方自动根据实际类型进行推导，这里 math.Pi 被赋值到变量 c 中，因此类型为 float32。
- 第 29 行，将 float32 转换为 int 类型并输出。


代码输出如下：

```go
int8 range: -128 127
int16 range: -32768 32767
int32 range: -2147483648 2147483647
int64 range: -9223372036854775808 9223372036854775807
int32: 0x3e6f54ff 1047483647
int16: 0x54ff 21759
3
```

根据输出结果，16 位有符号整型的范围是 -32768～32767，而变量 a 的值 1047483647 不在这个范围内。1047483647 对应的十六进制为 0x3e6f54ff，转为 int16 类型后，长度缩短一半，也就是在十六进制上砍掉一半，变成 0x54ff，对应的十进制值为 21759。

浮点数在转换为整型时，会将小数部分去掉，只保留整数部分。

### 14. 指针

与 [Java](http://c.biancheng.net/java/) 和 .NET 等编程语言不同，Go语言为程序员提供了控制[数据结构](http://c.biancheng.net/data_structure/)指针的能力，但是，并不能进行指针运算。Go语言允许你控制特定集合的数据结构、分配的数量以及内存访问模式，这对于构建运行良好的系统是非常重要的。指针对于性能的影响不言而喻，如果你想要做系统编程、操作系统或者网络应用，指针更是不可或缺的一部分。

指针（pointer）在Go语言中可以被拆分为两个核心概念：

- 类型指针，允许对这个指针类型的数据进行修改，传递数据可以直接使用指针，而无须拷贝数据，类型指针不能进行偏移和运算。
- 切片，由指向起始元素的原始指针、元素数量和容量组成。


受益于这样的约束和拆分，Go语言的指针类型变量即拥有指针高效访问的特点，又不会发生指针偏移，从而避免了非法修改关键性数据的问题。同时，垃圾回收也比较容易对不会发生偏移的指针进行检索和回收。

切片比原始指针具备更强大的特性，而且更为安全。切片在发生越界时，运行时会报出宕机，并打出堆栈，而原始指针只会崩溃。

#### C/[C++](http://c.biancheng.net/cplus/)中的指针

说到 C/C++ 中的指针，会让许多人“谈虎色变”，尤其是对指针的偏移、运算和转换。

其实，指针是 C/C++ 语言拥有极高性能的根本所在，在操作大块数据和做偏移时即方便又便捷。因此，操作系统依然使用C语言及指针的特性进行编写。

C/C++ 中指针饱受诟病的根本原因是指针的运算和内存释放，C/C++ 语言中的裸指针可以自由偏移，甚至可以在某些情况下偏移进入操作系统的核心区域，我们的计算机操作系统经常需要更新、修复漏洞的本质，就是为解决指针越界访问所导致的“缓冲区溢出”的问题。

要明白指针，需要知道几个概念：指针地址、指针类型和指针取值，下面将展开详细说明。

#### 认识指针地址和指针类型

一个指针变量可以指向任何一个值的内存地址，它所指向的值的内存地址在 32 和 64 位机器上分别占用 4 或 8 个字节，占用字节的大小与所指向的值的大小无关。当一个指针被定义后没有分配到任何变量时，它的默认值为 nil。指针变量通常缩写为 ptr。

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用在变量名前面添加`&`操作符（前缀）来获取变量的内存地址（取地址操作），格式如下：

```go
ptr := &v   // v 的类型为 T
```

其中 v 代表被取地址的变量，变量 v 的地址使用变量 ptr 进行接收，ptr 的类型为`*T`，称做 T 的指针类型，`*`代表指针。

指针实际用法，可以通过下面的例子了解：

```go
package main
import (
    "fmt"
)
func main() {
    var cat int = 1
    var str string = "banana"
    fmt.Printf("%p %p", &cat, &str)
}
```

运行结果：

```go
0xc042052088 0xc0420461b0
```

代码说明如下：

- 第 8 行，声明整型变量 cat。
- 第 9 行，声明字符串变量 str。
- 第 10 行，使用 fmt.Printf 的动词`%p`打印 cat 和 str 变量的内存地址，指针的值是带有`0x`十六进制前缀的一组数据。


提示：变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。

#### 从指针获取指针指向的值

当使用`&`操作符对普通变量进行取地址操作并得到变量的指针后，可以对指针使用`*`操作符，也就是指针取值，代码如下。

```go
package main
import (
    "fmt"
)
func main() {
    // 准备一个字符串类型
    var house = "Malibu Point 10880, 90265"
    // 对字符串取地址, ptr类型为*string
    ptr := &house
    // 打印ptr的类型
    fmt.Printf("ptr type: %T\n", ptr)
    // 打印ptr的指针地址
    fmt.Printf("address: %p\n", ptr)
    // 对指针进行取值操作
    value := *ptr
    // 取值后的类型
    fmt.Printf("value type: %T\n", value)
    // 指针取值后就是指向变量的值
    fmt.Printf("value: %s\n", value)
}
```

运行结果：

```go
ptr type: *string
address: 0xc0420401b0
value type: string
value: Malibu Point 10880, 90265
```

代码说明如下：

- 第 10 行，准备一个字符串并赋值。
- 第 13 行，对字符串取地址，将指针保存到变量 ptr 中。
- 第 16 行，打印变量 ptr 的类型，其类型为 *string。
- 第 19 行，打印 ptr 的指针地址，地址每次运行都会发生变化。
- 第 22 行，对 ptr 指针变量进行取值操作，变量 value 的类型为 string。
- 第 25 行，打印取值后 value 的类型。
- 第 28 行，打印 value 的值。


取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值。

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址操作使用`&`操作符，可以获得这个变量的指针变量。
- 指针变量的值是指针地址。
- 对指针变量进行取值操作使用`*`操作符，可以获得指针变量指向的原变量的值。

#### 使用指针修改值

通过指针不仅可以取值，也可以修改值。

前面已经演示了使用多重赋值的方法进行数值交换，使用指针同样可以进行数值交换，代码如下：

```go
package main
import "fmt"
// 交换函数
func swap(a, b *int) {
    // 取a指针的值, 赋给临时变量t
    t := *a
    // 取b指针的值, 赋给a指针指向的变量
    *a = *b
    // 将a指针的值赋给b指针指向的变量
    *b = t
}
func main() {
// 准备两个变量, 赋值1和2
    x, y := 1, 2
    // 交换变量值
    swap(&x, &y)
    // 输出变量值
    fmt.Println(x, y)
}
```

运行结果：

```go
2 1
```

代码说明如下：

- 第 6 行，定义一个交换函数，参数为 a、b，类型都为 *int 指针类型。
- 第 9 行，取指针 a 的值，并把值赋给变量 t，t 此时是 int 类型。
- 第 12 行，取 b 的指针值，赋给指针 a 指向的变量。注意，此时`*a`的意思不是取 a 指针的值，而是“a 指向的变量”。
- 第 15 行，将 t 的值赋给指针 b 指向的变量。
- 第 21 行，准备 x、y 两个变量，分别赋值为 1 和 2，类型为 int。
- 第 24 行，取出 x 和 y 的地址作为参数传给 swap() 函数进行调用。
- 第 27 行，交换完毕时，输出 x 和 y 的值。


`*`操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，`*`操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作在左值时，就是将值设置给指向的变量。

如果在 swap() 函数中交换操作的是指针值，会发生什么情况？可以参考下面代码：

```go
package main
import "fmt"
func swap(a, b *int) {
    b, a = a, b
}
func main() {
    x, y := 1, 2
    swap(&x, &y)
    fmt.Println(x, y)
}
```

运行结果：

```go
1 2
```

结果表明，交换是不成功的。上面代码中的 swap() 函数交换的是 a 和 b 的地址，在交换完毕后，a 和 b 的变量值确实被交换。但和 a、b 关联的两个变量并没有实际关联。这就像写有两座房子的卡片放在桌上一字摊开，交换两座房子的卡片后并不会对两座房子有任何影响。

#### 示例：使用指针变量获取命令行的输入信息

Go语言内置的 flag 包实现了对命令行参数的解析，flag 包使得开发命令行工具更为简单。

下面的代码通过提前定义一些命令行指令和对应的变量，并在运行时输入对应的参数，经过 flag 包的解析后即可获取命令行的数据。

【示例】获取命令行输入：

```go
package main
// 导入系统包
import (
    "flag"
    "fmt"
)
// 定义命令行参数
var mode = flag.String("mode", "", "process mode")
func main() {
    // 解析命令行参数
    flag.Parse()
    // 输出命令行参数
    fmt.Println(*mode)
}
```

将这段代码命名为 main.go，然后使用如下命令行运行：

```go
go run main.go --mode=fast
```

命令行输出结果如下：

```go
fast
```

代码说明如下：

- 第 10 行，通过 flag.String，定义一个 mode 变量，这个变量的类型是 *string。后面 3 个参数分别如下：
    - 参数名称：在命令行输入参数时，使用这个名称。
    - 参数值的默认值：与 flag 所使用的函数创建变量类型对应，String 对应字符串、Int 对应整型、Bool 对应布尔型等。
    - 参数说明：使用 -help 时，会出现在说明中。
- 第 15 行，解析命令行参数，并将结果写入到变量 mode 中。
- 第 18 行，打印 mode 指针所指向的变量。


由于之前已经使用 flag.String 注册了一个名为 mode 的命令行参数，flag 底层知道怎么解析命令行，并且将值赋给 mode*string 指针，在 Parse 调用完毕后，无须从 flag 获取值，而是通过自己注册的这个 mode 指针获取到最终的值。代码运行流程如下图所示。

![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ311430K50.jpg)
图：命令行参数与变量的关系

#### 创建指针的另一种方法——new() 函数

Go语言还提供了另外一种方法来创建指针变量，格式如下：

```go
new(类型)
```

一般这样写：

```go
str := new(string)
*str = "Go语言教程"
fmt.Println(*str)
```

new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。

### 15. 变量逃逸分析

在讨论变量生命周期之前，先来了解下计算机组成里两个非常重要的概念：堆和栈。变量的生命周期我们将在下一节《[变量生命周期](http://c.biancheng.net/view/4034.html)》中为大家讲解。

#### 什么是栈

栈（Stack）是一种拥有特殊规则的线性表数据结构。

##### 1) 概念

栈只允许从线性表的同一端放入和取出数据，按照后进先出（LIFO，Last InFirst Out）的顺序，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3132T4944.jpg)](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3132T4944.jpg)

图：栈的操作及扩展

往栈中放入元素的过程叫做入栈。入栈会增加栈的元素数量，最后放入的元素总是位于栈的顶部，最先放入的元素总是位于栈的底部。

从栈中取出元素时，只能从栈顶部取出。取出元素后，栈的元素数量会变少。最先放入的元素总是最后被取出，最后放入的元素总是最先被取出。不允许从栈底获取数据，也不允许对栈成员（除了栈顶部的成员）进行任何查看和修改操作。

栈的原理类似于将书籍一本一本地堆起来。书按顺序一本一本从顶部放入，要取书时只能从顶部一本一本取出。

##### 2) 变量和栈有什么关系

栈可用于内存分配，栈的分配和回收速度非常快。下面的代码展示了栈在内存分配上的作用：

```go
 func calc(a, b int) int {
      var c int
      c = a * b

      var x int
      x = c * 10

      return x
  }
```

代码说明如下：

- 第 1 行，传入 a、b 两个整型参数。

- 第 2 行，声明整型变量 c，运行时，c 会分配一段内存用以存储 c 的数值。

- 第 3 行，将 a 和 b 相乘后赋值给 c。

- 第 5 行，声明整型变量 x，x 也会被分配一段内存。

- 第 6 行，让 c 乘以 10 后赋值给变量 x。

- 第 8 行，返回 x 的值。

上面的代码在没有任何优化的情况下，会进行变量 c 和 x 的分配过程。Go 语言默认情况下会将 c 和 x 分配在栈上，这两个变量在 calc() 函数退出时就不再使用，函数结束时，保存 c 和 x 的栈内存再出栈释放内存，整个分配内存的过程通过栈的分配和回收都会非常迅速。

#### 什么是堆

堆在内存分配中类似于往一个房间里摆放各种家具，家具的尺寸有大有小，分配内存时，需要找一块足够装下家具的空间再摆放家具。经过反复摆放和腾空家具后，房间里的空间会变得乱七八糟，此时再往这个空间里摆放家具会发现虽然有足够的空间，但各个空间分布在不同的区域，没有一段连续的空间来摆放家具。此时，内存分配器就需要对这些空间进行调整优化，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3133J3a0.jpg)](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3133J3a0.jpg)

图：堆的分配及空间

堆分配内存和栈分配内存相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。

#### 变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率

堆和栈各有优缺点，该怎么在编程中处理这个问题呢？在 C/C++ 语言中，需要开发者自己学习如何进行内存分配，选用怎样的内存分配方式来适应不同的算法需求。比如，函数局部变量尽量使用栈，全局变量、结构体成员使用堆分配等。程序员不得不花费很长的时间在不同的项目中学习、记忆这些概念并加以实践和使用。

Go 语言将这个过程整合到了编译器中，命名为 “变量逃逸分析”。通过编译器分析代码的特征和代码的生命周期，决定应该使用堆还是栈来进行内存分配。

##### 1) 逃逸分析

通过下面的代码来展现 Go 语言如何使用命令行来分析变量逃逸，代码如下：

```go
  package main

  import "fmt"

  // 本函数测试入口参数和返回值情况
  func dummy(b int) int {

      // 声明一个变量c并赋值
      var c int
      c = b

      return c
  }

  // 空函数, 什么也不做
  func void() {
  }

  func main() {

      // 声明a变量并打印
      var a int

      // 调用void()函数
      void()
      // 打印a变量的值和dummy()函数返回
      fmt.Println(a, dummy(0))
  }
```

代码说明如下：

- 第 6 行，dummy() 函数拥有一个参数，返回一个整型值，用来测试函数参数和返回值分析情况。

- 第 9 行，声明变量 c，用于演示函数临时变量通过函数返回值返回后的情况。

- 第 16 行，这是一个空函数，测试没有任何参数函数的分析情况。

- 第 23 行，在 main() 中声明变量 a，测试 main() 中变量的分析情况。

- 第 26 行，调用 void() 函数，没有返回值，测试 void() 调用后的分析情况。

- 第 29 行，打印 a 和 dummy(0) 的返回值，测试函数返回值没有变量接收时的分析情况。

接着使用如下命令行运行上面的代码：

```go
go run -gcflags “-m -l” main.go
```

使用 go run 运行程序时，-gcflags 参数是编译参数。其中 -m 表示进行内存分配分析，-l 表示避免程序内联，也就是避免进行程序优化。

运行结果如下：

```go
\# command-line-arguments ./main.go:# command-line-arguments
./main.go:29:13: a escapes to heap
./main.go:29:22: dummy(0) escapes to heap
./main.go:29:13: main … argument does not escape
0 029:13: a escapes to heap ./main.go:29:22: dummy(0) escapes to heap ./main.go:29:13: main … argument does not escape 0 0
```

程序运行结果分析如下：

- 第 2 行告知 “代码的第 29 行的变量 a 逃逸到堆”。

- 第 3 行告知 “dummy(0) 调用逃逸到堆”。由于 dummy() 函数会返回一个整型值，这个值被 fmt.Println 使用后还是会在 main() 函数中继续存在。

- 第 4 行，这句提示是默认的，可以忽略。

上面例子中变量 c 是整型，其值通过 dummy() 的返回值 “逃出” 了 dummy() 函数。变量 c 的值被复制并作为 dummy() 函数的返回值返回，即使变量 c 在 dummy() 函数中分配的内存被释放，也不会影响 main() 中使用 dummy() 返回的值。变量 c 使用栈分配不会影响结果。

##### 2) 取地址发生逃逸

下面的例子使用结构体做数据，来了解结构体在堆上的分配情况，代码如下：

```go
  package main

  import "fmt"

  // 声明空结构体测试结构体逃逸情况
  type Data struct {
  }

  func dummy() \*Data {
      // 实例化c为Data类型
      var c Data

      //返回函数局部变量地址
      return &c
  }

  func main() {
      fmt.Println(dummy())
  }
```

代码说明如下：

- 第 6 行，声明一个空的结构体做结构体逃逸分析。

- 第 9 行，将 dummy() 函数的返回值修改为 *Data 指针类型。

- 第 11 行，将变量 c 声明为 Data 类型，此时 c 的结构体为值类型。

- 第 14 行，取函数局部变量 c 的地址并返回。

- 第 18 行，打印 dummy() 函数的返回值。

执行逃逸分析：

```go
go run -gcflags “-m -l” main.go
# command-line-arguments
./main.go:15:9: &c escapes to heap
./main.go:12:6: moved to heap: c
./main.go:20:19: dummy() escapes to heap
./main.go:20:13: main … argument does not escape
&{}
```

注意第 4 行出现了新的提示：将 c 移到堆中。这句话表示，Go 编译器已经确认如果将变量 c 分配在栈上是无法保证程序最终结果的，如果这样做，dummy() 函数的返回值将是一个不可预知的内存地址，这种情况一般是 C/C++ 语言中容易犯错的地方，引用了一个函数局部变量的地址。

Go 语言最终选择将 c 的 Data 结构分配在堆上。然后由垃圾回收器去回收 c 的内存。

##### 3) 原则

在使用 Go 语言进行编程时，Go 语言的设计者不希望开发者将精力放在内存应该分配在栈还是堆的问题上，编译器会自动帮助开发者完成这个纠结的选择，但变量逃逸分析也是需要了解的一个编译器技术，这个技术不仅用于 Go 语言，在 Java 等语言的编译器优化上也使用了类似的技术。

编译器觉得变量应该分配在堆和栈上的原则是：

- 变量是否被取地址；

- 变量是否发生逃逸。

### 16. 变量的生命周期

变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。

变量的生命周期与[变量的作用域](http://c.biancheng.net/view/4032.html)有着不可分割的联系：

- 全局变量：它的生命周期和整个程序的运行周期是一致的；
- 局部变量：它的生命周期则是动态的，从创建这个变量的声明语句开始，到这个变量不再被引用为止；
- 形式参数和函数返回值：它们都属于局部变量，在函数被调用的时候创建，函数调用结束后被销毁。

```go
for t := 0.0; t < cycles*2*math.Pi; t += res {
    x := math.Sin(t)
    y := math.Sin(t*freq + phase)
    img.SetColorIndex(
        size+int(x*size+0.5), size+int(y*size+0.5),
        blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性
    )               // 小括号另起一行缩进，和大括号的风格保存一致
}
```

上面代码中，在每次循环的开始会创建临时变量 t，然后在每次循环迭代中创建临时变量 x 和 y。临时变量 x、y 存放在栈中，随着函数执行结束（执行遇到最后一个`}`），释放其内存。

栈的概念在上一节《[变量逃逸](http://c.biancheng.net/view/22.html)》中介绍过，它和堆的区别在于：

- 堆（heap）：堆是用于存放进程执行中被动态分配的内存段。它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态加入到堆上（堆被扩张）。当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）；
- 栈(stack)：栈又称堆栈， 用来存放程序暂时创建的局部变量，也就是我们函数的大括号`{ }`中定义的局部变量。


在程序的编译阶段，编译器会根据实际情况自动选择在栈或者堆上分配局部变量的存储空间，不论使用 var 还是 new 关键字声明变量都不会影响编译器的选择。

```go
var global *int
func f() {
    var x int
    x = 1
    global = &x
}
func g() {
    y := new(int)
    *y = 1
}
```

上述代码中，函数 f 里的变量 x 必须在堆上分配，因为它在函数退出后依然可以通过包一级的 global 变量找到，虽然它是在函数内部定义的。用Go语言的术语说，这个局部变量 x 从函数 f 中逃逸了。

相反，当函数 g 返回时，变量 *y 不再被使用，也就是说可以马上被回收的。因此，*y 并没有从函数 g 中逃逸，编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的 GC（垃圾回收机制）回收这个变量的内存空间。

在实际的开发中，并不需要刻意的实现变量的逃逸行为，因为逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。

虽然Go语言能够帮助我们完成对内存的分配和释放，但是为了能够开发出高性能的应用我们任然需要了解变量的声明周期。例如，如果将局部变量赋值给全局变量，将会阻止 GC 对这个局部变量的回收，导致不必要的内存占用，从而影响程序的性能。

### 17. 常量和const关键字

Go语言中的常量使用关键字 const 定义，用于存储不会改变的数据，常量是在编译时被创建的，即使定义在函数内部也是如此，并且只能是布尔型、数字型（整数型、浮点型和复数）和字符串型。由于编译时的限制，定义常量的表达式必须为能被编译器求值的常量表达式。

常量的定义格式和变量的声明语法类似：`const name [type] = value`，例如：

```go
const pi = 3.14159 // 相当于 math.Pi 的近似值
```

在Go语言中，你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。

- 显式类型定义： const b string = "abc"
- 隐式类型定义： const b = "abc"


常量的值必须是能够在编译时就能够确定的，可以在其赋值表达式中涉及计算过程，但是所有用于计算的值必须在编译期间就能获得。

- 正确的做法：const c1 = 2/3
- 错误的做法：const c2 = getNumber() // 引发构建错误: getNumber() 用做值


和变量声明一样，可以批量声明多个常量：

```go
const (
    e  = 2.7182818
    pi = 3.1415926
)
```

所有常量的运算都可以在编译期完成，这样不仅可以减少运行时的工作，也方便其他代码的编译优化，当操作数是常量时，一些运行时的错误也可以在编译时被发现，例如整数除零、字符串索引越界、任何导致无效浮点数的操作等。

常量间的所有算术运算、逻辑运算和比较运算的结果也是常量，对常量的类型转换操作或以下函数调用都是返回常量结果：len、cap、real、imag、complex 和 unsafe.Sizeof。

因为它们的值是在编译期就确定的，因此常量可以是构成类型的一部分，例如用于指定数组类型的长度：

```go
const IPv4Len = 4
// parseIPv4 解析一个 IPv4 地址 (d.d.d.d).
func parseIPv4(s string) IP {
    var p [IPv4Len]byte
    // ...
}
```

一个常量的声明也可以包含一个类型和一个值，但是如果没有显式指明类型，那么将从右边的表达式推断类型。在下面的代码中，time.Duration 是一个命名类型，底层类型是 int64，time.Minute 是对应类型的常量。下面声明的两个常量都是 time.Duration 类型，可以通过 %T 参数打印类型信息：

```go
const noDelay time.Duration = 0
const timeout = 5 * time.Minute
fmt.Printf("%T %[1]v\n", noDelay)     // "time.Duration 0"
fmt.Printf("%T %[1]v\n", timeout)     // "time.Duration 5m0s"
fmt.Printf("%T %[1]v\n", time.Minute) // "time.Duration 1m0s"
```

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。例如：

```go
const (
    a = 1
    b
    c = 2
    d
)
fmt.Println(a, b, c, d) // "1 1 2 2"
```

如果只是简单地复制右边的常量表达式，其实并没有太实用的价值。但是它可以带来其它的特性，那就是 iota 常量生成器语法。

#### iota 常量生成器

常量声明可以使用 iota 常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。在一个 const 声明语句中，在第一个声明的常量所在的行，iota 将会被置为 0，然后在每一个有常量声明的行加一。

【示例 1】首先定义一个 Weekday 命名类型，然后为一周的每天定义了一个常量，从周日 0 开始。在其它编程语言中，这种类型一般被称为枚举类型。

```go
type Weekday int
const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
```

周日将对应 0，周一为 1，以此类推。

#### 无类型常量

Go语言的常量有个不同寻常之处。虽然一个常量可以有任意一个确定的基础类型，例如 int 或 float64，或者是类似 time.Duration 这样的基础类型，但是许多常量并没有一个明确的基础类型。

编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算，可以认为至少有 256bit 的运算精度。这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。

通过延迟明确常量的具体类型，不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。

【示例 2】math.Pi 无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：

```go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

如果 math.Pi 被确定为特定类型，比如 float64，那么结果精度可能会不一样，同时对于需要 float32 或 complex128 类型值的地方则需要一个明确的强制类型转换：

```go
const Pi64 float64 = math.Pi
var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)
```

对于常量面值，不同的写法可能会对应不同的类型。例如 0、0.0、0i 和 \u0000 虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true 和 false 也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。

### 18. 模拟枚举（const和iota模拟枚举）

Go 语言现阶段没有枚举类型，但是可以使用 const 常量配合上一节《[Go 语言常量](http://c.biancheng.net/view/23.html)》中介绍的 iota 来模拟枚举类型，请看下面的代码：

```go
  type Weapon int

  const (
       Arrow Weapon = iota    // 开始生成枚举值, 默认为0
       Shuriken
       SniperRifle
       Rifle
       Blower
  )

  // 输出所有枚举值
  fmt.Println(Arrow, Shuriken, SniperRifle, Rifle, Blower)

  // 使用枚举类型并赋初值
  var weapon Weapon = Blower
  fmt.Println(weapon)
```

代码输出如下：

```go
0 1 2 3 4 4
```

代码说明如下： 第 1 行中，将 int 定义为 Weapon 类型，就像枚举类型的本质是一个 int 类型一样。当然，某些情况下，如果需要 int32 和 int64 的枚举，也是可以的。

第 4 行中，将常量 Arrow 的类型标识为 Weapon，这样标识后，const 下方的常量可以使用 Weapon 作为默认类型。该行使用 iota 进行常量值自动生成，iota 的起始值为 0，一般情况下也是建议枚举从 0 开始，让每个枚举类型都有一个空值，方便业务和逻辑的灵活使用。

一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加，类似于电子表格中单元格自动填充的效果，只需要建立好单元格之间的变化关系，拖动右下方的小点就可以自动生成单元格的值。

当然，iota 不仅可以生成每次增加 1 的枚举值。还可以利用 iota 来做一些强大的枚举常量值生成器。下面的代码可以方便的生成标志位常量：

```go
  const (
      FlagNone = 1 << iota
      FlagRed
      FlagGreen
      FlagBlue
  )

  fmt.Printf("%d %d %d\\n", FlagRed, FlagGreen, FlagBlue)
  fmt.Printf("%b %b %b\\n", FlagRed, FlagGreen, FlagBlue)
```

代码输出如下：

```go
2 4 8 10 100 1000
```

在代码中编写一些标志位时，我们往往手动编写常量值，常量值特别多时，很容易重复或者写错，因此，使用 ioto 自动生成更加方便。

代码说明如下：

- 第 2 行中 iota 使用了一个移位操作，每次将上一次的值左移一位（二进制位），以得出每一位的常量值。

- 第 8 行，将 3 个枚举按照常量输出，分别输出 2、4、8，都是将 1 每次左移一位的结果。

- 第 9 行，将枚举值按二进制格式输出，可以清晰地看到每一位的变化。

#### 将枚举值转换为字符串

枚举在 C# 中是一个独立的类型，可以通过枚举值获取该值对应的字符串。例如，C# 中 Week 枚举值 Monday 为 1，那么可以通过 Week.Monday.ToString() 函数获得 Monday 字符串。

Go 语言中也可以实现这一功能，代码如下所示：

转换字符串：

```go
  package main

  import "fmt"

  // 声明芯片类型
  type ChipType int

  const (
      None ChipType = iota
      CPU    // 中央处理器
      GPU    // 图形处理器
  )

  func (c ChipType) String() string {
      switch c {
      case None:
          return "None"
      case CPU:
          return "CPU"
      case GPU:
          return "GPU"
      }

      return "N/A"
  }

  func main() {

      // 输出CPU的值并以整型格式显示
      fmt.Printf("%s %d", CPU, CPU)
  }
```

运行结果：

```go
CPU 1
```

代码说明如下：

- 第 6 行，将 int 声明为 ChipType 芯片类型。

- 第 9 行，将 const 里定义的常量值设为 ChipType 类型，且从 0 开始，每行值加 1。

- 第 14 行，定义 ChipType 类型的方法 String()，返回值为字符串类型。

- 第 15～22 行，使用 switch 语句判断当前的 ChitType 类型的值，返回对应的字符串。

- 第 30 行，按整型的格式输出 CPU 的值。

String() 方法的 ChipType 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，Go 语言会自动寻找 String() 方法并进行调用。

### 19. type关键字（类型别名）

注意：本节内容涉及Go语言新版本的功能，内容上会涉及后续章节讲解的类型定义及结构体嵌入等特性。另外，本节内容适用于对Go语言很熟悉且正在关注工程升级、代码重构等问题的读者阅读。

类型别名是 Go 1.9 版本添加的新功能，主要用于解决代码升级、迁移中存在的类型兼容性问题。在 C/[C++](http://c.biancheng.net/cplus/) 语言中，代码重构升级可以使用宏快速定义一段新的代码，Go语言中没有选择加入宏，而是解决了重构中最麻烦的类型名变更问题。

在 Go 1.9 版本之前定义内建类型的代码是这样写的：

```go
type byte uint8
type rune int32
```

而在 Go 1.9 版本之后变为：

```go
type byte = uint8
type rune = int32
```

这个修改就是配合类型别名而进行的修改。

#### 区分类型别名与类型定义

定义类型别名的写法为：

```go
type TypeAlias = Type
```

类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型，就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。

类型别名与类型定义表面上看只有一个等号的差异，那么它们之间实际的区别有哪些呢？下面通过一段代码来理解。

```go
package main
import (
    "fmt"
)
// 将NewInt定义为int类型
type NewInt int
// 将int取一个别名叫IntAlias
type IntAlias = int
func main() {
    // 将a声明为NewInt类型
    var a NewInt
    // 查看a的类型名
    fmt.Printf("a type: %T\n", a)
    // 将a2声明为IntAlias类型
    var a2 IntAlias
    // 查看a2的类型名
    fmt.Printf("a2 type: %T\n", a2)
}
```

代码运行结果：

```go
a type: main.NewInt
a2 type: int
```

代码说明如下：

- 第 8 行，将 NewInt 定义为 int 类型，这是常见的定义类型的方法，通过 type 关键字的定义，NewInt 会形成一种新的类型，NewInt 本身依然具备 int 类型的特性。
- 第 11 行，将 IntAlias 设置为 int 的一个别名，使用 IntAlias 与 int 等效。
- 第 16 行，将 a 声明为 NewInt 类型，此时若打印，则 a 的值为 0。
- 第 18 行，使用`%T`格式化参数，打印变量 a 本身的类型。
- 第 21 行，将 a2 声明为 IntAlias 类型，此时打印 a2 的值为 0。
- 第 23 行，打印 a2 变量的类型。


结果显示 a 的类型是 main.NewInt，表示 main 包下定义的 NewInt 类型，a2 类型是 int，IntAlias 类型只会在代码中存在，编译完成时，不会有 IntAlias 类型。

#### 非本地类型不能定义方法

能够随意地为各种类型起名字，是否意味着可以在自己包里为这些类型任意添加方法呢？参见下面的代码演示：

```go
package main
import (
    "time"
)
// 定义time.Duration的别名为MyDuration
type MyDuration = time.Duration
// 为MyDuration添加一个函数
func (m MyDuration) EasySet(a string) {
}
func main() {
}
```

代码说明如下：

- 第 8 行，为 time.Duration 设定一个类型别名叫 MyDuration。
- 第 11 行，为这个别名添加一个方法。


编译上面代码报错，信息如下：

```go
cannot define new methods on non-local type time.Duration
```

编译器提示：不能在一个非本地的类型 time.Duration 上定义新方法，非本地类型指的就是 time.Duration 不是在 main 包中定义的，而是在 time 包中定义的，与 main 包不在同一个包中，因此不能为不在一个包中的类型定义方法。

解决这个问题有下面两种方法：

- 将第 8 行修改为 type MyDuration time.Duration，也就是将 MyDuration 从别名改为类型；
- 将 MyDuration 的别名定义放在 time 包中。

#### 在结构体成员嵌入时使用别名

当类型别名作为结构体嵌入的成员时会发生什么情况呢？请参考下面的代码。

```go
package main
import (
    "fmt"
    "reflect"
)
// 定义商标结构
type Brand struct {
}
// 为商标结构添加Show()方法
func (t Brand) Show() {
}
// 为Brand定义一个别名FakeBrand
type FakeBrand = Brand
// 定义车辆结构
type Vehicle struct {
    // 嵌入两个结构
    FakeBrand
    Brand
}
func main() {
    // 声明变量a为车辆类型
    var a Vehicle
   
    // 指定调用FakeBrand的Show
    a.FakeBrand.Show()
    // 取a的类型反射对象
    ta := reflect.TypeOf(a)
    // 遍历a的所有成员
    for i := 0; i < ta.NumField(); i++ {
        // a的成员信息
        f := ta.Field(i)
        // 打印成员的字段名和类型
        fmt.Printf("FieldName: %v, FieldType: %v\n", f.Name, f.Type.
            Name())
    }
}
```

代码输出如下：

```go
FieldName: FakeBrand, FieldType: Brand
FieldName: Brand, FieldType: Brand
```

代码说明如下：

- 第 9 行，定义商标结构。
- 第 13 行，为商标结构添加 Show() 方法。
- 第 17 行，为 Brand 定义一个别名 FakeBrand。
- 第 20～25 行，定义车辆结构 Vehicle，嵌入 FakeBrand 和 Brand 结构。
- 第 30 行，将 Vechicle 实例化为 a。
- 第 33 行，显式调用 Vehicle 中 FakeBrand 的 Show() 方法。
- 第 36 行，使用反射取变量 a 的反射类型对象，以查看其成员类型。
- 第 39～42 行，遍历 a 的结构体成员。
- 第 45 行，打印 Vehicle 类型所有成员的信息。


这个例子中，FakeBrand 是 Brand 的一个别名，在 Vehicle 中嵌入 FakeBrand 和 Brand 并不意味着嵌入两个 Brand，FakeBrand 的类型会以名字的方式保留在 Vehicle 的成员中。

如果尝试将第 33 行改为：

```go
a.Show()
```

编译器将发生报错：

```go
ambiguous selector a.Show
```

在调用 Show() 方法时，因为两个类型都有 Show() 方法，会发生歧义，证明 FakeBrand 的本质确实是 Brand 类型。

### 20. 注释的定义及使用

注释在程序中的作用是对程序进行注解和说明，便于对源码的阅读。编译系统在对源代码进行编译时会自动忽略注释的部分，因此注释对于程序的功能实现不起任何作用。在源码中适当地添加注释，能够提高源码的可读性。

Go语言的注释主要分成两类，分别是单行注释和多行注释。

- 单行注释简称行注释，是最常见的注释形式，可以在任何地方使用以`//`开头的单行注释；
- 多行注释简称块注释，以`/*`开头，并以`*/`结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。


单行注释的格式如下所示

```go
//单行注释
```

多行注释的格式如下所示

```go
/*
第一行注释
第二行注释
...
*/
```

每一个包都应该有相关注释，在使用 package 语句声明包名之前添加相应的注释，用来对包的功能及作用进行简要说明。

同时，在 package 语句之前的注释内容将被默认认为是这个包的文档说明。一个包可以分散在多个文件中，但是只需要对其中一个进行注释说明即可。

在多段注释之间可以使用空行分隔加以区分，如下所示：

```go
// Package superman implements methods for saving the world.
//
// Experience has shown that a small number of procedures can prove
// helpful when attempting to save the world.
package superman
```

对于代码中的变量、常量、函数等对象最好也都加上对应的注释，这样有利于后期对代码进行维护，例如下面代码中对 enterOrbit 函数的注释：

```go
// enterOrbit causes Superman to fly into low Earth orbit, a position
// that presents several possibilities for planet salvation.
func enterOrbit() error {
   ...
}
```

当开发人员需要了解包的一些情况时，可以使用 godoc 来显示包的文档说明，下面来介绍一下 godoc 工具的使用。

#### godoc 工具

godoc 工具会从 Go 程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，并生成相关文档，也可以作为一个提供在线文档浏览的 web 服务器，Go语言官网（https://golang.google.cn/）就是通过这种形式实现的。

但是Go语言 1.13 版本移除了 godoc 工具，大家可以通过`go get `命令来获取 godoc 工具。

```go
go get golang.org/x/tools/cmd/godoc
```

由于防火墙的原因，国内的用户可能无法通过`go get `命令来获取 godoc 工具，这时候就需要大家来手动操作了。

- 首先从 GitHub（https://github.com/golang/tools.git） 下载 golang.org/x/tools 包；
- 然后将下载得到的文件解压到 GOPATH 下的 src\golang.org\x\tools 目录中，没有的话可以手动创建；
- 打开 GOPATH 下的 src\golang.org\x\tools\cmd\godoc 目录，在该目录下打开命令行工具，并执行`go build `命令，生成 godoc.exe 可执行文件；
- 最后，将生成的 godoc.exe 文件移动到 GOPATH 下的 bin 目录中。（需要把 GOPATH 下的 bin 目录添加到环境变量 Path 中）

![img](http://c.biancheng.net/uploads/allimg/191120/4-1911201109532V.gif)


完成上述操作后就可以使用 godoc 工具了，godoc 工具一般有以下几种用法：

- go doc package：获取包的文档注释，例如`go doc fmt `会显示使用 godoc 生成的 fmt 包的文档注释；
- go doc package/subpackage：获取子包的文档注释，例如`go doc container/list`；
- go doc package function：获取某个函数在某个包中的文档注释，例如`go doc fmt Printf `会显示有关 fmt.Printf() 的使用说明。


下图演示了使用`go doc `命令来获取包的文档注释：

![go doc 命令的使用](http://c.biancheng.net/uploads/allimg/191119/4-1911191P31I24.gif)


godoc 工具还可以获取 Go 安装目录下 ../go/src 中的注释内容，并将这些注释内容整合到 web 服务器中供我们预览。在命令行输入`godoc -http=:6060`，然后使用浏览器打开 http://localhost:6060 后，就可以看到本地文档浏览服务器提供的页面。



![img](http://c.biancheng.net/uploads/allimg/190927/4-1Z92GA3292J.gif)

### 21. 关键字与标识符简述

Go语言的词法元素包括 5 种，分别是标识符（identifier）、关键字（keyword）、操作符（operator）、分隔符（delimiter）、字面量（literal），它们是组成Go语言代码和程序的最基本单位。

本节我们主要来介绍一下Go语言中的关键字和标识符。

#### 关键字

关键字即是被Go语言赋予了特殊含义的单词，也可以称为保留字。

Go语言中的关键字一共有 25 个：



| break    | default     | func   | interface | select |
| -------- | ----------- | ------ | --------- | ------ |
| case     | defer       | go     | map       | struct |
| chan     | else        | goto   | package   | switch |
| const    | fallthrough | if     | range     | type   |
| continue | for         | import | return    | var    |


之所以刻意地将Go语言中的关键字保持的这么少，是为了简化在编译过程中的代码解析。和其它语言一样，关键字不能够作标识符使用。

#### 标识符

标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线`_`、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。

下划线`_`是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用`_`作为变量对其它变量进行赋值或运算。

在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。

标识符的命名需要遵守以下规则：

- 由 26 个英文字母、0~9、`_`组成；
- 不能以数字开头，例如 var 1num int 是错误的；
- Go语言中严格区分大小写；
- 标识符不能包含空格；
- 不能以系统保留关键字作为标识符，比如 break，if 等等。


命名标识符时还需要注意以下几点：

- 标识符的命名要尽量采取简短且有意义；
- 不能和标准库中的包名重复；
- 为变量、函数、常量命名时采用驼峰命名法，例如 stuName、getVal；


当然Go语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于 [Java](http://c.biancheng.net/java/) 中的 public）；如果首字母小写，则表示它只能在本包中使用 (类似于 Java 中 private）。

在Go语言中还存在着一些特殊的标识符，叫做预定义标识符，如下表所示：

| append | bool    | byte    | cap     | close  | complex | complex64 | complex128 | uint16  |
| ------ | ------- | ------- | ------- | ------ | ------- | --------- | ---------- | ------- |
| copy   | false   | float32 | float64 | imag   | int     | int8      | int16      | uint32  |
| int32  | int64   | iota    | len     | make   | new     | nil       | panic      | uint64  |
| print  | println | real    | recover | string | true    | uint      | uint8      | uintptr |


预定义标识符一共有 36 个，主要包含Go语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。

### 22. 运算符的优先级

运算符是用来在程序运行时执行数学或逻辑运算的，在Go语言中，一个表达式可以包含多个运算符，当表达式中存在多个运算符时，就会遇到优先级的问题，此时应该先处理哪个运算符呢？这个就由Go语言运算符的优先级来决定的。

比如对于下面的表达式：

```go
var a, b, c int = 16, 4, 2
d := a + b*c
```

对于表达式`a + b * c`，如果按照数学规则推导，应该先计算乘法，再计算加法；`b * c`的结果为 8，`a + 8`的结果为 24，所以 d 最终的值也是 24。实际上Go语言也是这样处理的，先计算乘法再计算加法，和数据中的规则一样，读者可以亲自验证一下。

先计算乘法后计算加法，说明乘法运算符的优先级比加法运算符的优先级高。所谓优先级，就是当多个运算符出现在同一个表达式中时，先执行哪个运算符。

Go语言有几十种运算符，被分成十几个级别，有的运算符优先级不同，有的运算符优先级相同，请看下表。

| 优先级 | 分类           | 运算符                                         | 结合性   |
| ------ | -------------- | ---------------------------------------------- | -------- |
| 1      | 逗号运算符     | ,                                              | 从左到右 |
| 2      | 赋值运算符     | =、+=、-=、*=、/=、 %=、 >=、 <<=、&=、^=、\|= | 从右到左 |
| 3      | 逻辑或         | \|\|                                           | 从左到右 |
| 4      | 逻辑与         | &&                                             | 从左到右 |
| 5      | 按位或         | \|                                             | 从左到右 |
| 6      | 按位异或       | ^                                              | 从左到右 |
| 7      | 按位与         | &                                              | 从左到右 |
| 8      | 相等/不等      | ==、!=                                         | 从左到右 |
| 9      | 关系运算符     | <、<=、>、>=                                   | 从左到右 |
| 10     | 位移运算符     | <<、>>                                         | 从左到右 |
| 11     | 加法/减法      | +、-                                           | 从左到右 |
| 12     | 乘法/除法/取余 | *（乘号）、/、%                                | 从左到右 |
| 13     | 单目运算符     | !、*（指针）、& 、++、--、+（正号）、-（负号） | 从右到左 |
| 14     | 后缀运算符     | ( )、[ ]、->                                   | 从左到右 |


注意：优先级值越大，表示优先级越高。

一下子记住所有运算符的优先级并不容易，还好Go语言中大部分运算符的优先级和数学中是一样的，大家在以后的编程过程中也会逐渐熟悉起来。如果实在搞不清，可以加括号，就像下面这样：

```go
d := a + (b * c)
```

括号的优先级是最高的，括号中的表达式会优先执行，这样各个运算符的执行顺序就一目了然了。

运算符的结合性是指相同优先级的运算符在同一个表达式中，且没有括号的时候，操作数计算的顺序，通常有从左到右和从右到左两种方式，例如，`+`加法运算符的结合性是从左到右，那么表达式`a + b + c`则可以理解为为`(a + b) + c`。

### 23. strconv包：字符串和数值类型的相互转换

在实际开发中我们往往需要对一些常用的数据类型进行转换，如 string、int、int64、float 等数据类型之间的转换，Go 语言中的 strconv 包为我们提供了字符串和基本数据类型之间的转换功能。

strconv 包中常用的函数包括 Atoi()、Itia()、parse 系列函数、format 系列函数、append 系列函数等，下面就来分别介绍一下。

#### string 与 int 类型之间的转换

字符串和整型之间的转换是我们平时编程中使用的最多的，下面就来介绍一下具体的操作。

##### Itoa()：整型转字符串

Itoa() 函数用于将 int 类型数据转换为对应的字符串类型，函数签名如下。

```go
func Itoa(i int) string
```

示例代码如下：

```go
  func main() {
      num := 100
      str := strconv.Itoa(num)
      fmt.Printf("type:%T value:%#v\\n", str, str)
  }
```

运行结果如下所示：

```go
type:string value:“100”
```

##### Atoi()：字符串转整型

Atoi() 函数用于将字符串类型的整数转换为 int 类型，函数签名如下。

```go
func Atoi(s string) (i int, err error)
```

通过函数签名可以看出 Atoi() 函数有两个返回值，i 为转换成功的整型，err 在转换成功是为空转换失败时为相应的错误信息。

示例代码如下：

```go
  func main() {
      str1 := "110"
      str2 := "s100"
      num1, err := strconv.Atoi(str1)
      if err != nil {
          fmt.Printf("%v 转换失败！", str1)
      } else {
          fmt.Printf("type:%T value:%#v\\n", num1, num1)
      }
      num2, err := strconv.Atoi(str2)
      if err != nil {
          fmt.Printf("%v 转换失败！", str2)
      } else {
          fmt.Printf("type:%T value:%#v\\n", num2, num2)
      }
  }
```

运行结果如下所示：

```go
type:int value:110 s100 转换失败！
```

#### Parse 系列函数

Parse 系列函数用于将字符串转换为指定类型的值，其中包括 ParseBool()、ParseFloat()、ParseInt()、ParseUint()。

##### ParseBool()

ParseBool() 函数用于将字符串转换为 bool 类型的值，它只能接受 1、0、t、f、T、F、true、false、True、False、TRUE、FALSE，其它的值均返回错误，函数签名如下。

func ParseBool(str string) (value bool, err error)

示例代码如下：

```go
  func main() {
      str1 := "110"
      boo1, err := strconv.ParseBool(str1)
      if err != nil {
          fmt.Printf("str1: %v\\n", err)
      } else {
          fmt.Println(boo1)
      }
      str2 := "t"
      boo2, err := strconv.ParseBool(str2)
      if err != nil {
          fmt.Printf("str2: %v\\n", err)
      } else {
          fmt.Println(boo2)
      }
  }
```

运行结果如下：

```go
str1: strconv.ParseBool: parsing “110”: invalid syntax true
```

##### ParseInt()

ParseInt() 函数用于返回字符串表示的整数值（可以包含正负号），函数签名如下：

```go
func ParseInt(s string, base int, bitSize int) (i int64, err error)
```

参数说明：

- base 指定进制，取值范围是 2 到 36。如果 base 为 0，则会从字符串前置判断，“0x” 是 16 进制，“0” 是 8 进制，否则是 10 进制。

- bitSize 指定结果必须能无溢出赋值的整数类型，0、8、16、32、64 分别代表 int、int8、int16、int32、int64。

- 返回的 err 是 *NumErr 类型的，如果语法有误，err.Error = ErrSyntax，如果结果超出类型范围 err.Error = ErrRange。

示例代码如下：

```go
  func main() {
      str := "-11"
      num, err := strconv.ParseInt(str, 10, 0)
      if err != nil {
          fmt.Println(err)
      } else {
          fmt.Println(num)
      }
  }
```

运行结果如下：

```go
11
```

##### ParseUnit()

ParseUint() 函数的功能类似于 ParseInt() 函数，但 ParseUint() 函数不接受正负号，用于无符号整型，函数签名如下：

```go
func ParseUint(s string, base int, bitSize int) (n uint64, err error)
```

示例代码如下：

```go
  func main() {
      str := "11"
      num, err := strconv.ParseUint(str, 10, 0)
      if err != nil {
          fmt.Println(err)
      } else {
          fmt.Println(num)
      }
  }
```

运行结果如下：

```go
11
```

##### ParseFloat()

ParseFloat() 函数用于将一个表示浮点数的字符串转换为 float 类型，函数签名如下。

```go
func ParseFloat(s string, bitSize int) (f float64, err error)
```

参数说明：

- 如果 s 合乎语法规则，函数会返回最为接近 s 表示值的一个浮点数（使用 IEEE754 规范舍入）。

- bitSize 指定了返回值的类型，32 表示 float32，64 表示 float64；

- 返回值 err 是 *NumErr 类型的，如果语法有误 err.Error=ErrSyntax，如果返回值超出表示范围，返回值 f 为 ±Inf，err.Error= ErrRange。

示例代码如下：

```go
  func main() {
      str := "3.1415926"
      num, err := strconv.ParseFloat(str, 64)
      if err != nil {
          fmt.Println(err)
      } else {
          fmt.Println(num)
      }
  }
```

运行结果如下：

```go
3.1415926
```

Parse 系列函数都有两个返回值，第一个返回值是转换后的值，第二个返回值为转化失败的错误信息。

#### Format 系列函数

Format 系列函数实现了将给定类型数据格式化为字符串类型的功能，其中包括 FormatBool()、FormatInt()、FormatUint()、FormatFloat()。

##### FormatBool()

FormatBool() 函数可以一个 bool 类型的值转换为对应的字符串类型，函数签名如下。

```go
func FormatBool(b bool) string
```

示例代码如下：

```go
  func main() {
      num := true
      str := strconv.FormatBool(num)
      fmt.Printf("type:%T,value:%v\\n ", str, str)
  }
```

运行结果如下：

```go
type:string,value:true
```

##### FormatInt()

FormatInt() 函数用于将整型数据转换成指定进制并以字符串的形式返回，函数签名如下：

```go
func FormatInt(i int64, base int) string
```

其中，参数 i 必须是 int64 类型，参数 base 必须在 2 到 36 之间，返回结果中会使用小写字母 “a” 到“z”表示大于 10 的数字。

示例代码如下：

```go
  func main() {
      var num int64 = 100
      str := strconv.FormatInt(num, 16)
      fmt.Printf("type:%T,value:%v\\n ", str, str)
  }
```

运行结果如下：

```go
type:string,value:64
```

##### FormatUint()

FormatUint() 函数与 FormatInt() 函数的功能类似，但是参数 i 必须是无符号的 uint64 类型，函数签名如下。

```go
func FormatUint(i uint64, base int) string
```

示例代码如下：

```go
  func main() {
      var num uint64 = 110
      str := strconv.FormatUint(num, 16)
      fmt.Printf("type:%T,value:%v\\n ", str, str)
  }
```

运行结果如下：

```go
type:string,value:6e
```

##### FormatFloat()

FormatFloat() 函数用于将浮点数转换为字符串类型，函数签名如下：

```go
func FormatFloat(f float64, fmt byte, prec, bitSize int) string
```

参数说明：

- bitSize 表示参数 f 的来源类型（32 表示 float32、64 表示 float64），会据此进行舍入。

- fmt 表示格式，可以设置为 “f” 表示 -ddd.dddd、“b”表示 -ddddp±ddd，指数为二进制、“e”表示 -d.dddde±dd 十进制指数、“E”表示 -d.ddddE±dd 十进制指数、“g”表示指数很大时用 “e” 格式，否则 “f” 格式、“G”表示指数很大时用 “E” 格式，否则 “f” 格式。

- prec 控制精度（排除指数部分）：当参数 fmt 为 “f”、“e”、“E” 时，它表示小数点后的数字个数；当参数 fmt 为 “g”、“G” 时，它控制总的数字个数。如果 prec 为 -1，则代表使用最少数量的、但又必需的数字来表示 f。

示例代码如下：

```go
  func main() {
      var num float64 = 3.1415926
      str := strconv.FormatFloat(num, 'E', -1, 64)
      fmt.Printf("type:%T,value:%v\\n ", str, str)
  }
```

运行结果如下：

```go
type:string,value:3.1415926E+00
```

#### Append 系列函数

Append 系列函数用于将指定类型转换成字符串后追加到一个切片中，其中包含 AppendBool()、AppendFloat()、AppendInt()、AppendUint()。

Append 系列函数和 Format 系列函数的使用方法类似，只不过是将转换后的结果追加到一个切片中。

示例代码如下：

```go
  package main
  import (
      "fmt"
      "strconv"
  )
  func main() {
      // 声明一个slice
      b10 := []byte("int (base 10):")

      // 将转换为10进制的string，追加到slice中
      b10 = strconv.AppendInt(b10, -42, 10)
      fmt.Println(string(b10))
      b16 := []byte("int (base 16):")
      b16 = strconv.AppendInt(b16, -42, 16)
      fmt.Println(string(b16))
  }
```

运行结果如下：

```go
int (base 10):-42 int (base 16):-2a 
```



## 第三章 容器

### 1. 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。

和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 slice 工作原理的话需要先理解数组，所以本节主要为大家讲解数组的使用，至于 Slice（切片）将在《[Go语言切片](http://c.biancheng.net/view/27.html)》一节中为大家讲解。

#### Go语言数组的声明

数组的声明语法如下：

```go
var 数组变量名 [元素数量]Type
```

语法说明如下所示：

- 数组变量名：数组声明及使用时的变量名。
- 元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。
- Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。


数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。

```go
var a [3]int             // 定义三个整数的数组
fmt.Println(a[0])        // 打印第一个元素
fmt.Println(a[len(a)-1]) // 打印最后一个元素
// 打印索引和元素
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}
// 仅打印元素
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```

默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：

```go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"
```

在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为：

```go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。

```go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int
```

#### 比较两个数组是否相等

如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（`==`和`!=`）来判断两个数组是否相等，只有当两个数组的所有元素都是相等的时候数组才是相等的，不能比较两个类型不同的数组，否则程序将无法完成编译。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int
```

#### 遍历数组——访问每一个数组元素

遍历数组也和遍历切片类似，代码如下所示：

```go
var team [3]string
team[0] = "hammer"
team[1] = "soldier"
team[2] = "mum"
for k, v := range team {
    fmt.Println(k, v)
}
```

代码输出结果：

```go
0 hammer
1 soldier
2 mum
```

代码说明如下：

- 第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。
- 第 7 行，将每个键值打印出来。

### 2. 多维数组

Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。

声明多维数组的语法如下所示：

```go
var array_name [size1][size2]...[sizen] array_type
```

其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。

结合上一节《[Go语言数组](http://c.biancheng.net/view/26.html)》中所学到的知识，下面以二维数组为例来简单讲解一下多维数组的使用。

二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。

【示例 1】声明二维数组

```go
// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
var array [4][2]int
// 使用数组字面量来声明并初始化一个二维整型数组
array = [4][2]int{{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化数组中索引为 1 和 3 的元素
array = [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化数组中指定的元素
array = [4][2]int{1: {0: 20}, 3: {1: 41}}
```

下图展示了上面示例中声明的二维数组在每次声明并初始化后包含的值。



![二维数组及其外层数组和内层数组的值](http://c.biancheng.net/uploads/allimg/190614/4-1Z614140501324.gif)
图：二维数组及其外层数组和内层数组的值


为了访问单个元素，需要反复组合使用`[ ]`方括号，如下所示。

【示例 2】为二维数组的每个元素赋值

```go
// 声明一个 2×2 的二维整型数组
var array [2][2]int
// 设置每个元素的整型值
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40
```

只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。

【示例 3】同样类型的多维数组赋值

```go
// 声明两个二维整型数组
var array1 [2][2]int
var array2 [2][2]int
// 为array2的每个元素赋值
array2[0][0] = 10
array2[0][1] = 20
array2[1][0] = 30
array2[1][1] = 40
// 将 array2 的值复制给 array1
array1 = array2
```

因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。

【示例 4】使用索引为多维数组赋值

```go
// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里
var array3 [2]int = array1[1]
// 将数组中指定的整型值复制到新的整型变量里
var value int = array1[1][0]
```

### 3. 切片

切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/[C++](http://c.biancheng.net/cplus/) 中的数组类型，或者 [Python](http://c.biancheng.net/python/) 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。

Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。

![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3154340Y9.jpg)
图：切片结构和内存分配

#### 从数组或切片生成新的切片

切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。

从连续内存区域生成切片是常见的操作，格式如下：

```go
slice [开始位置 : 结束位置]
```

语法说明如下：

- slice：表示目标切片对象；
- 开始位置：对应目标切片对象的索引；
- 结束位置：对应目标切片的结束索引。


从数组生成切片，代码如下：

```go
var a  = [3]int{1, 2, 3}
fmt.Println(a, a[1:2])
```

其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：

```go
[1 2 3]  [2]
```

其中 [2] 就是 a[1:2] 切片操作的结果。

从数组或切片生成新的切片拥有如下特性：

- 取出的元素数量为：结束位置 - 开始位置；
- 取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；
- 当缺省开始位置时，表示从连续区域开头到结束位置；
- 当缺省结束位置时，表示从开始位置到整个连续区域末尾；
- 两者同时缺省时，与切片本身等效；
- 两者同时为 0 时，等效于空切片，一般用于切片复位。


根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。

下面通过实例来熟悉切片的特性。

##### 1) 从指定范围中生成切片

切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下：

```go
var highRiseBuilding [30]int
for i := 0; i < 30; i++ {
        highRiseBuilding[i] = i + 1
}
// 区间
fmt.Println(highRiseBuilding[10:15])
// 中间到尾部的所有元素
fmt.Println(highRiseBuilding[20:])
// 开头到中间指定位置的所有元素
fmt.Println(highRiseBuilding[:2])
```

代码输出如下：

```go
[11 12 13 14 15]
[21 22 23 24 25 26 27 28 29 30]
[1 2]
```

代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。

代码说明如下：

- 第 8 行，尝试出租一个区间楼层。
- 第 11 行，出租 20 层以上。
- 第 14 行，出租 2 层以下，一般是商用铺面。


切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。

##### 2) 表示原有的切片

生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下：

```go
a := []int{1, 2, 3}
fmt.Println(a[:])
```

a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：

```go
[1 2 3]
```

##### 3) 重置切片，清空拥有的元素

把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：

```go
a := []int{1, 2, 3}
fmt.Println(a[0:0])
```

代码输出如下：

```go
[]
```

#### 直接声明新的切片

除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：

```go
var name []Type
```

其中 name 表示切片的变量名，Type 表示切片对应的元素类型。

下面代码展示了切片声明的使用过程：

```go
// 声明字符串切片
var strList []string
// 声明整型切片
var numList []int
// 声明一个空切片
var numListEmpty = []int{}
// 输出3个切片
fmt.Println(strList, numList, numListEmpty)
// 输出3个切片大小
fmt.Println(len(strList), len(numList), len(numListEmpty))
// 切片判定空的结果
fmt.Println(strList == nil)
fmt.Println(numList == nil)
fmt.Println(numListEmpty == nil)
```

代码输出结果：

```go
[] [] []
0 0 0
true
true
false
```

代码说明如下：

- 第 2 行，声明一个字符串切片，切片中拥有多个字符串。
- 第 5 行，声明一个整型切片，切片中拥有多个整型数值。
- 第 8 行，将 numListEmpty 声明为一个整型切片，本来会在`{}`中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。
- 第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。
- 第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。
- 第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。
- 第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。


切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 [append()](http://c.biancheng.net/view/28.html) 函数向切片中添加元素。

#### 使用 make() 函数构造切片

如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：

```go
make( []Type, size, cap )
```

其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。

示例如下：

```go
a := make([]int, 2)
b := make([]int, 2, 10)
fmt.Println(a, b)
fmt.Println(len(a), len(b))
```

代码输出如下：

```go
[0 0] [0 0]
2 2
```

其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。

容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。

##### 温馨提示

使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。

### 4. append()为切片添加元素

Go语言的内建函数 append() 可以为切片动态添加元素，代码如下所示：

```go
var a []int
a = append(a, 1) // 追加1个元素
a = append(a, 1, 2, 3) // 追加多个元素, 手写解包方式
a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
```

不过需要注意的是，在使用 append() 函数为切片动态添加元素时，如果空间不足以容纳足够多的元素，切片就会进行“扩容”，此时新切片的长度会发生改变。

切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充，例如 1、2、4、8、16……，代码如下：

```go
var numbers []int
for i := 0; i < 10; i++ {
    numbers = append(numbers, i)
    fmt.Printf("len: %d  cap: %d pointer: %p\n", len(numbers), cap(numbers), numbers)
}
```

代码输出如下：

```go
len: 1 cap: 1 pointer: 0xc0420080e8
len: 2 cap: 2 pointer: 0xc042008150
len: 3 cap: 4 pointer: 0xc04200e320
len: 4 cap: 4 pointer: 0xc04200e320
len: 5 cap: 8 pointer: 0xc04200c200
len: 6 cap: 8 pointer: 0xc04200c200
len: 7 cap: 8 pointer: 0xc04200c200
len: 8 cap: 8 pointer: 0xc04200c200
len: 9 cap: 16 pointer: 0xc042074000
len: 10 cap: 16 pointer: 0xc042074000
```

代码说明如下：

- 第 1 行，声明一个整型切片。
- 第 4 行，循环向 numbers 切片中添加 10 个数。
- 第 5 行，打印输出切片的长度、容量和指针变化，使用函数 len() 查看切片拥有的元素个数，使用函数 cap() 查看切片的容量情况。


通过查看代码输出，可以发现一个有意思的规律：切片长度 len 并不等于切片的容量 cap。

往一个切片中不断添加元素的过程，类似于公司搬家，公司发展初期，资金紧张，人员很少，所以只需要很小的房间即可容纳所有的员工，随着业务的拓展和收入的增加就需要扩充工位，但是办公地的大小是固定的，无法改变，因此公司只能选择搬家，每次搬家就需要将所有的人员转移到新的办公点。

- 员工和工位就是切片中的元素。
- 办公地就是分配好的内存。
- 搬家就是重新分配内存。
- 无论搬多少次家，公司名称始终不会变，代表外部使用切片的变量名不会修改。
- 由于搬家后地址发生变化，因此内存“地址”也会有修改。


除了在切片的尾部追加，我们还可以在切片的开头添加元素：

```go
var a = []int{1,2,3}
a = append([]int{0}, a...) // 在开头添加1个元素
a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
```

在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。

因为 append 函数返回新切片的特性，所以切片也支持链式操作，我们可以将多个 append 操作组合起来，实现在切片中间插入元素：

```go
var a []int
a = append(a[:i], append([]int{x}, a[i:]...)...) // 在第i个位置插入x
a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
```

每个添加操作中的第二个 append 调用都会创建一个临时切片，并将 a[i:] 的内容复制到新创建的切片中，然后将临时创建的切片再追加到 a[:i] 中。

### 5. copy()：切片复制

Go语言的内置函数 copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。

copy() 函数的使用格式如下：

```go
copy( destSlice, srcSlice []T) int
```

其中 srcSlice 为数据来源切片，destSlice 为复制的目标（也就是将 srcSlice 复制到 destSlice），目标切片必须分配过空间且足够承载复制的元素个数，并且来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。

下面的代码展示了使用 copy() 函数将一个切片复制到另一个切片的过程：

```go
slice1 := []int{1, 2, 3, 4, 5}
slice2 := []int{5, 4, 3}
copy(slice2, slice1) // 只会复制slice1的前3个元素到slice2中
copy(slice1, slice2) // 只会复制slice2的3个元素到slice1的前3个位置
```

虽然通过循环复制切片元素更直接，不过内置的 copy() 函数使用起来更加方便，copy() 函数的第一个参数是要复制的目标 slice，第二个参数是源 slice，两个 slice 可以共享同一个底层数组，甚至有重叠也没有问题。

【示例】通过代码演示对切片的引用和复制操作后对切片元素的影响。

```go
package main
import "fmt"
func main() {
    // 设置元素数量为1000
    const elementCount = 1000
    // 预分配足够多的元素切片
    srcData := make([]int, elementCount)
    // 将切片赋值
    for i := 0; i < elementCount; i++ {
        srcData[i] = i
    }
    // 引用切片数据
    refData := srcData
    // 预分配足够多的元素切片
    copyData := make([]int, elementCount)
    // 将数据复制到新的切片空间中
    copy(copyData, srcData)
    // 修改原始数据的第一个元素
    srcData[0] = 999
    // 打印引用切片的第一个元素
    fmt.Println(refData[0])
    // 打印复制切片的第一个和最后一个元素
    fmt.Println(copyData[0], copyData[elementCount-1])
    // 复制原始数据从4到6(不包含)
    copy(copyData, srcData[4:6])
    for i := 0; i < 5; i++ {
        fmt.Printf("%d ", copyData[i])
    }
}
```

代码说明如下：

- 第 8 行，定义元素总量为 1000。
- 第 11 行，预分配拥有 1000 个元素的整型切片，这个切片将作为原始数据。
- 第 14～16 行，将 srcData 填充 0～999 的整型值。
- 第 19 行，将 refData 引用 srcData，切片不会因为等号操作进行元素的复制。
- 第 22 行，预分配与 srcData 等大（大小相等）、同类型的切片 copyData。
- 第 24 行，使用 copy() 函数将原始数据复制到 copyData 切片空间中。
- 第 27 行，修改原始数据的第一个元素为 999。
- 第 30 行，引用数据的第一个元素将会发生变化。
- 第 33 行，打印复制数据的首位数据，由于数据是复制的，因此不会发生变化。
- 第 36 行，将 srcData 的局部数据复制到 copyData 中。
- 第 38～40 行，打印复制局部数据后的 copyData 元素。

### 6. 从切片中删除元素

Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。

#### 从开头位置删除

删除开头的元素可以直接移动数据指针：

```go
a = []int{1, 2, 3}
a = a[1:] // 删除开头1个元素
a = a[N:] // 删除开头N个元素
```

也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）：

```go
a = []int{1, 2, 3}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
```

还可以用 copy() 函数来删除开头的元素：

```go
a = []int{1, 2, 3}
a = a[:copy(a, a[1:])] // 删除开头1个元素
a = a[:copy(a, a[N:])] // 删除开头N个元素
```

#### 从中间位置删除

对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append 或 copy 原地完成：

```go
a = []int{1, 2, 3, ...}
a = append(a[:i], a[i+1:]...) // 删除中间1个元素
a = append(a[:i], a[i+N:]...) // 删除中间N个元素
a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素
a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素
```

#### 从尾部删除

```go
a = []int{1, 2, 3}
a = a[:len(a)-1] // 删除尾部1个元素
a = a[:len(a)-N] // 删除尾部N个元素
```


删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。

【示例】删除切片指定位置的元素。

```go
package main
import "fmt"
func main() {
    seq := []string{"a", "b", "c", "d", "e"}
    // 指定删除位置
    index := 2
    // 查看删除位置之前的元素和之后的元素
    fmt.Println(seq[:index], seq[index+1:])
    // 将删除点前后的元素连接起来
    seq = append(seq[:index], seq[index+1:]...)
    fmt.Println(seq)
}
```

代码输出结果：

```go
[a b] [d e]
[a b d e]
```

代码说明如下：

- 第 1 行，声明一个整型切片，保存含有从 a 到 e 的字符串。
- 第 4 行，为了演示和讲解方便，使用 index 变量保存需要删除的元素位置。
- 第 7 行，seq[:index] 表示的就是被删除元素的前半部分，值为 [1 2]，seq[index+1:] 表示的是被删除元素的后半部分，值为 [4 5]。
- 第 10 行，使用 append() 函数将两个切片连接起来。
- 第 12 行，输出连接好的新切片，此时，索引为 2 的元素已经被删除。


代码的删除过程可以使用下图来描述。

![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ3164544530.jpg)
图：切片删除元素的操作过程

Go语言中删除切片元素的本质是，以被删除元素为分界点，将前后两个部分的内存重新连接起来。

##### 提示

连续容器的元素删除无论在任何语言中，都要将删除点前后的元素移动到新的位置，随着元素的增加，这个过程将会变得极为耗时，因此，当业务需要大量、频繁地从一个切片中删除元素时，如果对性能要求较高的话，就需要考虑更换其他的容器了（如双链表等能快速从删除点删除元素）。

### 7. range关键字：循环迭代切片

通过前面的学习我们了解到切片其实就是多个相同类型元素的连续集合，既然切片是一个集合，那么我们就可以迭代其中的元素，Go语言有个特殊的关键字 range，它可以配合关键字 for 来迭代切片里的每一个元素，如下所示：

```go
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 迭代每一个元素，并显示其值
for index, value := range slice {
    fmt.Printf("Index: %d Value: %d\n", index, value)
}
```

第 4 行中的 index 和 value 分别用来接收 range 关键字返回的切片中每个元素的索引和值，这里的 index 和 value 不是固定的，读者也可以定义成其它的名字。

关于 for 的详细使用我们将在下一章《[Go语言流程控制](http://c.biancheng.net/golang/flow_control/)》中为大家详细介绍。

上面代码的输出结果为：

```go
Index: 0 Value: 10
Index: 1 Value: 20
Index: 2 Value: 30
Index: 3 Value: 40
```

当迭代切片时，关键字 range 会返回两个值，第一个值是当前迭代到的索引位置，第二个值是该位置对应元素值的一份副本，如下图所示。

![使用 range 迭代切片会创建每个元素的副本](http://c.biancheng.net/uploads/allimg/190614/4-1Z614115226164.gif)
图：使用 range 迭代切片会创建每个元素的副本

需要强调的是，range 返回的是每个元素的副本，而不是直接返回对该元素的引用，如下所示。

【示例 1】range 提供了每个元素的副本

```go
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 迭代每个元素，并显示值和地址
for index, value := range slice {
    fmt.Printf("Value: %d Value-Addr: %X ElemAddr: %X\n", value, &value, &slice[index])
}
```

输出结果为：

```go
Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100
Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104
Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108
Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C
```

因为迭代返回的变量是一个在迭代过程中根据切片依次赋值的新变量，所以 value 的地址总是相同的，要想获取每个元素的地址，需要使用切片变量和索引值（例如上面代码中的 &slice[index]）。

如果不需要索引值，也可以使用下划线`_`来忽略这个值，代码如下所示。

【示例 2】使用空白标识符（下划线）来忽略索引值

```go
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 迭代每个元素，并显示其值
for _, value := range slice {
    fmt.Printf("Value: %d\n", value)
}
```

输出结果为：

```go
Value: 10
Value: 20
Value: 30
Value: 40
```

关键字 range 总是会从切片头部开始迭代。如果想对迭代做更多的控制，则可以使用传统的 for 循环，代码如下所示。

【示例 3】使用传统的 for 循环对切片进行迭代

```go
// 创建一个整型切片，并赋值
slice := []int{10, 20, 30, 40}
// 从第三个元素开始迭代每个元素
for index := 2; index < len(slice); index++ {
    fmt.Printf("Index: %d Value: %d\n", index, slice[index])
}
```

输出结果为：

```go
Index: 2 Value: 30
Index: 3 Value: 40
```

在前面几节的学习中我们了解了两个特殊的内置函数 len() 和 cap()，可以用于处理数组、切片和通道，对于切片，函数 len() 可以返回切片的长度，函数 cap() 可以返回切片的容量，在上面的示例中，使用到了函数 len() 来控制循环迭代的次数。

当然，range 关键字不仅仅可以用来遍历切片，它还可以用来遍历数组、字符串、map 或者通道等，这些我们将在后面的学习中详细介绍。

### 8. 多维切片

Go语言中同样允许使用多维切片，声明一个多维数组的语法格式如下：

```go
var sliceName [][]...[]sliceType
```

其中，sliceName 为切片的名字，sliceType为切片的类型，每个`[ ]`代表着一个维度，切片有几个维度就需要几个`[ ]`。

下面以二维切片为例，声明一个二维切片并赋值，代码如下所示。

```go
//声明一个二维切片
var slice [][]int
//为二维切片赋值
slice = [][]int{{10}, {100, 200}}
```

上面的代码也可以简写为下面的样子。

```go
// 声明一个二维整型切片并赋值
slice := [][]int{{10}, {100, 200}}
```

上面的代码中展示了一个包含两个元素的外层切片，同时每个元素包又含一个内层的整型切片，切片 slice 的值如下图所示。



![整型切片的切片的值](http://c.biancheng.net/uploads/allimg/190614/4-1Z61416004D92.gif)
图：整型切片的切片的值


通过上图可以看到外层的切片包括两个元素，每个元素都是一个切片，第一个元素中的切片使用单个整数 10 来初始化，第二个元素中的切片包括两个整数，即 100 和 200。

这种组合可以让用户创建非常复杂且强大的[数据结构](http://c.biancheng.net/data_structure/)，前面介绍过的关于内置函数[ append() ](http://c.biancheng.net/view/28.html)的规则也可以应用到组合后的切片上，如下所示。

【示例】组合切片的切片

```go
// 声明一个二维整型切片并赋值
slice := [][]int{{10}, {100, 200}}
// 为第一个切片追加值为 20 的元素
slice[0] = append(slice[0], 20)
```

Go语言里使用 append() 函数处理追加的方式很简明，先增长切片，再将新的整型切片赋值给外层切片的第一个元素，当上面代码中的操作完成后，再将切片复制到外层切片的索引为 0 的元素，如下图所示。



![append 操作之后外层切片索引为 0 的元素的布局](http://c.biancheng.net/uploads/allimg/190614/4-1Z614160234963.gif)
图：append 操作之后外层切片索引为 0 的元素的布局


即便是这么简单的多维切片，操作时也会涉及众多的布局和值，在函数间这样传递数据结构会很复杂，不过切片本身结构很简单，可以用很小的成本在函数间传递。

### 9. map

Go语言中 map 是一种特殊的[数据结构](http://c.biancheng.net/data_structure/)，一种元素对（pair）的无序集合，pair 对应一个 key（索引）和一个 value（值），所以这个结构也称为关联数组或字典，这是一种能够快速寻找值的理想结构，给定 key，就可以迅速找到对应的 value。

map 这种数据结构在其他编程语言中也称为字典（[Python](http://c.biancheng.net/python/)）、hash 和 HashTable 等。

#### map 概念

map 是引用类型，可以使用如下方式声明：

```go
var mapname map[keytype]valuetype
```

其中：

- mapname 为 map 的变量名。
- keytype 为键类型。
- valuetype 是键对应的值类型。

> 提示：[keytype] 和 valuetype 之间允许有空格。

在声明的时候不需要知道 map 的长度，因为 map 是可以动态增长的，未初始化的 map 的值是 nil，使用函数 len() 可以获取 map 中 pair 的数目。

【示例】

```go
package main
import "fmt"
func main() {
    var mapLit map[string]int
    //var mapCreated map[string]float32
    var mapAssigned map[string]int
    mapLit = map[string]int{"one": 1, "two": 2}
    mapCreated := make(map[string]float32)
    mapAssigned = mapLit
    mapCreated["key1"] = 4.5
    mapCreated["key2"] = 3.14159
    mapAssigned["two"] = 3
    fmt.Printf("Map literal at \"one\" is: %d\n", mapLit["one"])
    fmt.Printf("Map created at \"key2\" is: %f\n", mapCreated["key2"])
    fmt.Printf("Map assigned at \"two\" is: %d\n", mapLit["two"])
    fmt.Printf("Map literal at \"ten\" is: %d\n", mapLit["ten"])
}
```

输出结果：

```go
Map literal at "one" is: 1
Map created at "key2" is: 3.14159
Map assigned at "two" is: 3
Map literal at "ten" is: 0
```

示例中 mapLit 演示了使用`{key1: value1, key2: value2}`的格式来初始化 map ，就像数组和结构体一样。

上面代码中的 mapCreated 的创建方式`mapCreated := make(map[string]float)`等价于`mapCreated := map[string]float{} `。

mapAssigned 是 mapList 的引用，对 mapAssigned 的修改也会影响到 mapLit 的值。

注意：可以使用 make()，但不能使用 new() 来构造 map，如果错误的使用 new() 分配了一个引用对象，会获得一个空引用的指针，相当于声明了一个未初始化的变量并且取了它的地址：

```go
mapCreated := new(map[string]float)
```

接下来当我们调用`mapCreated["key1"] = 4.5`的时候，编译器会报错：

```go
invalid operation: mapCreated["key1"] (index of type *map[string]float).
```

#### map 容量

和数组不同，map 可以根据新增的 key-value 动态的伸缩，因此它不存在固定长度或者最大限制，但是也可以选择标明 map 的初始容量 capacity，格式如下：

```go
make(map[keytype]valuetype, cap)
```

例如：

```go
map2 := make(map[string]float, 100)
```

当 map 增长到容量上限的时候，如果再增加新的 key-value，map 的大小会自动加 1，所以出于性能的考虑，对于大的 map 或者会快速扩张的 map，即使只是大概知道容量，也最好先标明。

这里有一个 map 的具体例子，即将音阶和对应的音频映射起来：

```go
noteFrequency := map[string]float32 {
"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
"G0": 24.50, "A0": 27.50, "B0": 30.87, "A4": 440}
```

#### 用切片作为 map 的值

既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理 unix 机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为 value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题，示例代码如下所示：

```go
mp1 := make(map[int][]int)
mp2 := make(map[int]*[]int)
```

### 10. 遍历map

map 的遍历过程使用 for range 循环完成，代码如下：

```go
scene := make(map[string]int)
scene["route"] = 66
scene["brazil"] = 4
scene["china"] = 960
for k, v := range scene {
    fmt.Println(k, v)
}
```

遍历对于Go语言的很多对象来说都是差不多的，直接使用 for range 语法即可，遍历时，可以同时获得键和值，如只遍历值，可以使用下面的形式：

```go
for _, v := range scene {
```

将不需要的键使用`_`改为匿名变量形式。

只遍历键时，使用下面的形式：

```go
for k := range scene {
```

无须将值改为匿名变量形式，忽略值即可。

> 注意：遍历输出元素的顺序与填充顺序无关，不能期望 map 在遍历时返回某种期望顺序的结果。

如果需要特定顺序的遍历结果，正确的做法是先排序，代码如下：

```go
scene := make(map[string]int)
// 准备map数据
scene["route"] = 66
scene["brazil"] = 4
scene["china"] = 960
// 声明一个切片保存map数据
var sceneList []string
// 将map数据遍历复制到切片中
for k := range scene {
    sceneList = append(sceneList, k)
}
// 对切片进行排序
sort.Strings(sceneList)
// 输出
fmt.Println(sceneList)
```

代码输出如下：

```go
[brazil china route]
```

代码说明如下：

- 第 1 行，创建一个 map 实例，键为字符串，值为整型。
- 第 4～6 行，将 3 个键值对写入 map 中。
- 第 9 行，声明 sceneList 为字符串切片，以缓冲和排序 map 中的所有元素。
- 第 12 行，将 map 中元素的键遍历出来，并放入切片中。
- 第 17 行，对 sceneList 字符串切片进行排序，排序时，sceneList 会被修改。
- 第 20 行，输出排好序的 map 的键。


sort.Strings 的作用是对传入的字符串切片进行字符串字符的升序排列，排序接口的使用将在后面的章节中介绍。

### 11. map元素的删除和清空

Go语言提供了一个内置函数 delete()，用于删除容器内的元素，下面我们简单介绍一下如何用 delete() 函数删除 map 内的元素。

#### 使用 delete() 函数从 map 中删除键值对

使用 delete() 内建函数从 map 中删除一组键值对，delete() 函数的格式如下：

```go
delete(map, 键)
```

其中 map 为要删除的 map 实例，键为要删除的 map 中键值对的键。

从 map 中删除一组键值对可以通过下面的代码来完成：

```go
scene := make(map[string]int)
// 准备map数据
scene["route"] = 66
scene["brazil"] = 4
scene["china"] = 960
delete(scene, "brazil")
for k, v := range scene {
    fmt.Println(k, v)
}
```

代码输出如下：

```go
route 66
china 960
```

这个例子中使用 delete() 函数将 brazil 从 scene 这个 map 中删除了。

#### 清空 map 中的所有元素

有意思的是，Go语言中并没有为 map 提供任何清空所有元素的函数、方法，清空 map 的唯一办法就是重新 make 一个新的 map，不用担心垃圾回收的效率，Go语言中的并行垃圾回收效率比写一个清空函数要高效的多。

### 12. map的多键索引(多个数值条件可以同时查询)

在大多数的编程语言中，映射容器的键必须以单一值存在。这种映射方法经常被用在诸如信息检索上，如根据通讯簿的名字进行检索。但随着查询条件越来越复杂，检索也会变得越发困难。下面例子中涉及通讯簿的结构，结构如下：

```go
  // 人员档案
  type Profile struct {
      Name    string   // 名字
      Age     int      // 年龄
      Married bool     // 已婚
  }
```

并且准备好了一堆原始数据，需要算法实现构建索引和查询的过程，代码如下：

```go
  func main() {

      list := \[\]\*Profile{
          {Name: "张三", Age: 30, Married: true},
          {Name: "李四", Age: 21},
          {Name: "王麻子", Age: 21},
      }

      buildIndex(list)

      queryData("张三", 30)
  }
```

需要用算法实现 buildIndex() 构建索引函数及 queryData() 查询数据函数，查询到结果后将数据打印出来。

下面，分别基于传统的基于哈希值的多键索引和利用 map 特性的多键索引进行查询。

#### 基于哈希值的多键索引及查询

传统的数据索引过程是将输入的数据做特征值。这种特征值有几种常见做法：

- 将特征使用某种算法转为整数，即哈希值，使用整型值做索引。

- 将特征转为字符串，使用字符串做索引。

数据都基于特征值构建好索引后，就可以进行查询。查询时，重复这个过程，将查询条件转为特征值，使用特征值进行查询得到结果。

基于哈希的传统多键索引和查询的完整代码位于`./src/chapter12/classic/classic.go`，下面是对各个部分的分析。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

##### 1) 字符串转哈希值

本例中，查询键（classicQueryKey）的特征值需要将查询键中每一个字段转换为整型，字符串也需要转换为整型值，这里使用一种简单算法将字符串转换为需要的哈希值，代码如下：

```go
  func simpleHash(str string) (ret int) {

      // 遍历字符串中的每一个ASCII字符
      for i := 0; i < len(str); i++ {
          // 取出字符
          c := str\[i\]

          // 将字符的ASCII码相加
          ret += int(c)
      }

      return
  }
```

代码说明如下：

- 第 1 行传入需要计算哈希值的字符串。

- 第 4 行，根据字符串的长度，遍历这个字符串的每一个字符，以 ASCII 码为单位。

- 第 9 行，c 变量的类型为 uint8，将其转为 int 类型并累加。

哈希算法有很多，这里只是选用一种大家便于理解的算法。哈希算法的选用的标准是尽量减少重复键的发生，俗称 “哈希冲撞”，即同样两个字符串的哈希值重复率降到最低。

##### 2) 查询键

有了哈希算法函数后，将哈希函数用在查询键结构中。查询键结构如下：

```go
  // 查询键
  type classicQueryKey struct {
      Name string  // 要查询的名字
      Age  int     // 要查询的年龄
  }

  // 计算查询键的哈希值
  func (c \*classicQueryKey) hash() int {
      // 将名字的Hash和年龄哈希合并
      return simpleHash(c.Name) + c.Age\*1000000
  }
```

代码说明如下：

- 第 2 行，声明查询键的结构，查询键包含需要索引和查询的字段。

- 第 8 行，查询键的成员方法哈希，通过调用这个方法获得整个查询键的哈希值。

- 第 10 行，查询键哈希的计算方法：使用 simpleHash() 函数根据给定的名字字符串获得其哈希值。同时将年龄乘以 1000000 与名字哈希值相加。

哈希值构建过程如下图所示

[![img](http://c.biancheng.net/uploads/allimg/180820/1-1PR0153942196.jpg)](http://c.biancheng.net/uploads/allimg/180820/1-1PR0153942196.jpg)

##### 3) 构建索引

本例需要快速查询，因此需要提前对已有的数据构建索引。前面已经准备好了数据查询键，使用查询键获得哈希即可对数据进行快速索引，参考下面的代码：

```go
  // 创建哈希值到数据的索引关系
  var mapper = make(map[int][]*Profile)

  // 构建数据索引
  func buildIndex(list []*Profile) {

      // 遍历所有的数据
      for _, profile := range list {

          // 构建数据的查询索引
          key := classicQueryKey{profile.Name, profile.Age}

          // 计算数据的哈希值, 取出已经存在的记录
          existValue := mapper[key.hash()]

          // 将当前数据添加到已经存在的记录切片中
          existValue = append(existValue, profile)

          // 将切片重新设置到映射中
          mapper[key.hash()] = existValue
      }
  }
```

代码说明如下：

- 第 2 行，实例化一个 map，键类型为整型，保存哈希值；值类型为 *Profile，为通讯簿的数据格式。

- 第 5 行，构建索引函数入口，传入数据切片。

- 第 8 行，遍历数据切片的所有数据元素。

- 第 11 行，使用查询键（classicQueryKey）来辅助计算哈希值，查询键需要填充两个字段，将数据中的名字和年龄赋值到查询键中进行保存。

- 第 14 行，使用查询键的哈希方法计算查询键的哈希值。通过这个值在 mapper 索引中查找相同哈希值的数据切片集合。因为哈希函数不能保证不同数据的哈希值一定完全不同，因此要考虑在发生哈希值重复时的处理办法。

- 第 17 行，将当前数据添加到可能存在的切片中。

- 第 20 行，将新添加好的数据切片重新赋值到相同哈希的 mapper 中。

具体哈希结构如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180820/1-1PR0154524421.jpg)](http://c.biancheng.net/uploads/allimg/180820/1-1PR0154524421.jpg)

图：哈希结构

这种多键的算法就是哈希算法。map 的多个元素对应哈希的 “桶”。哈希函数的选择决定桶的映射好坏，如果哈希冲撞很厉害，那么就需要将发生冲撞的相同哈希值的元素使用切片保存起来。

##### 4) 查询逻辑

从已经构建好索引的数据中查询需要的数据流程如下：

1. 给定查询条件（名字、年龄）。

1. 根据查询条件构建查询键。

1. 查询键生成哈希值。

1. 根据哈希值在索引中查找数据集合。

1. 遍历数据集合逐个与条件比对。

1. 获得结果。

```go
  func queryData(name string, age int) {

      // 根据给定查询条件构建查询键
      keyToQuery := classicQueryKey{name, age}

      // 计算查询键的哈希值并查询, 获得相同哈希值的所有结果集合
      resultList := mapper[keyToQuery.hash()]

      // 遍历结果集合
      for _, result := range resultList {

          // 与查询结果比对, 确认找到打印结果
          if result.Name == name && result.Age == age {
              fmt.Println(result)
              return
          }
      }

      // 没有查询到时, 打印结果
      fmt.Println("no found")

  }
```

代码说明如下：

- 第 1 行，查询条件（名字、年龄）。

- 第 4 行，根据查询条件构建查询键。

- 第 7 行，使用查询键计算哈希值，使用哈希值查询相同哈希值的所有数据集合。

- 第 10 行，遍历所有相同哈希值的数据集合。

- 第 13 行，将每个数据与查询条件进行比对，如果一致，表示已经找到结果，打印并返回。

- 第 20 行，没有找到记录时，打印 no found。

#### 利用 map 特性的多键索引及查询

使用结构体进行多键索引和查询比传统的写法更为简单，最主要的区别是无须准备哈希函数及相应的字段无须做哈希合并。看下面的实现流程。

利用 map 特性的多键索引和查询的代码位于`./src/chapter12/multikey/multikey.go`，下面是对各个部分的分析。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

##### 1) 构建索引

代码如下：

```go
  // 查询键
  type queryKey struct {
      Name string
      Age  int
  }

  // 创建查询键到数据的映射
  var mapper = make(map[queryKey]*Profile)

  // 构建查询索引
  func buildIndex(list []*Profile) {

      // 遍历所有数据
      for _, profile := range list {

          // 构建查询键
          key := queryKey{
              Name: profile.Name,
              Age:  profile.Age,
          }

          // 保存查询键
          mapper[key] = profile
      }
  }
```

代码说明如下：

- 第 2 行，与基于哈希值的查询键的结构相同。

- 第 8 行，在 map 的键类型上，直接使用了查询键结构体。注意，这里不使用查询键的指针。同时，结果只有 *Profile 类型，而不是 *Profile 切片，表示查到的结果唯一。

- 第 17 行，类似的，使用遍历到的数据的名字和年龄构建查询键。

- 第 23 行，更简单的，直接将查询键保存对应的数据。

##### 2) 查询逻辑

```go
  // 根据条件查询数据
  func queryData(name string, age int) {

      // 根据查询条件构建查询键
      key := queryKey{name, age}

      // 根据键值查询数据
      result, ok := mapper[key]

      // 找到数据打印出来
      if ok {
          fmt.Println(result)
      } else {
          fmt.Println("no found")
      }
  }
```

代码说明如下：

- 第 5 行，根据查询条件（名字、年龄）构建查询键。

- 第 8 行，直接使用查询键在 map 中查询结果。

- 第 12 行，找到结果直接打印。

- 第 14 行，没有找到结果打印 no found。

#### 总结

基于哈希值的多键索引查询和利用 map 特性的多键索引查询的代码复杂程度显而易见。聪明的程序员都会利用 Go 语言的特性进行快速的多键索引查询。

其实，利用 map 特性的例子中的 map 类型即便修改为下面的格式，也一样可以获得同样的结果：

```go
1.  var mapper = make(map[interface{}]*Profile)
```

代码量大大减少的关键是：Go 语言的底层会为 map 的键自动构建哈希值。能够构建哈希值的类型必须是非动态类型、非指针、函数、闭包。

- 非动态类型：可用数组，不能用切片。

- 非指针：每个指针数值都不同，失去哈希意义。

- 函数、闭包不能作为 map 的键。

### 13. sync.Map（在并发环境中使用的map）

Go语言中的 map 在并发情况下，只读是线程安全的，同时读写是线程不安全的。

下面来看下并发情况下读写 map 时会出现的问题，代码如下：

```go
// 创建一个int到int的映射
m := make(map[int]int)
// 开启一段并发代码
go func() {
    // 不停地对map进行写入
    for {
        m[1] = 1
    }
}()
// 开启一段并发代码
go func() {
    // 不停地对map进行读取
    for {
        _ = m[1]
    }
}()
// 无限循环, 让并发程序在后台执行
for {
}
```

运行代码会报错，输出如下：

```go
fatal error: concurrent map read and map write
```

错误信息显示，并发的 map 读和 map 写，也就是说使用了两个并发函数不断地对 map 进行读和写而发生了竞态问题，map 内部会对这种并发操作进行检查并提前发现。

需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 1.9 版本中提供了一种效率较高的并发安全的 sync.Map，sync.Map 和 map 不同，不是以语言原生形态提供，而是在 sync 包下的特殊结构。

sync.Map 有以下特性：

- 无须初始化，直接声明即可。
- sync.Map 不能使用 map 的方式进行取值和设置等操作，而是使用 sync.Map 的方法进行调用，Store 表示存储，Load 表示获取，Delete 表示删除。
- 使用 Range 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，Range 参数中回调函数的返回值在需要继续迭代遍历时，返回 true，终止迭代遍历时，返回 false。


并发安全的 sync.Map 演示代码如下：

```go
package main
import (
      "fmt"
      "sync"
)
func main() {
    var scene sync.Map
    // 将键值对保存到sync.Map
    scene.Store("greece", 97)
    scene.Store("london", 100)
    scene.Store("egypt", 200)
    // 从sync.Map中根据键取值
    fmt.Println(scene.Load("london"))
    // 根据键删除对应的键值对
    scene.Delete("london")
    // 遍历所有sync.Map中的键值对
    scene.Range(func(k, v interface{}) bool {
        fmt.Println("iterate:", k, v)
        return true
    })
}
```

代码输出如下：

```go
100 true
iterate: egypt 200
iterate: greece 97
```

代码说明如下：

- 第 10 行，声明 scene，类型为 sync.Map，注意，sync.Map 不能使用 make 创建。
- 第 13～15 行，将一系列键值对保存到 sync.Map 中，sync.Map 将键和值以 interface{} 类型进行保存。
- 第 18 行，提供一个 sync.Map 的键给 scene.Load() 方法后将查询到键对应的值返回。
- 第 21 行，sync.Map 的 Delete 可以使用指定的键将对应的键值对删除。
- 第 24 行，Range() 方法可以遍历 sync.Map，遍历需要提供一个匿名函数，参数为 k、v，类型为 interface{}，每次 Range() 在遍历一个元素时，都会调用这个匿名函数把结果返回。


sync.Map 没有提供获取 map 数量的方法，替代方法是在获取 sync.Map 时遍历自行计算数量，sync.Map 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 map 相比使用 sync.Map 会有更好的性能。

### 14. list（列表）

列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。

列表的原理可以这样理解：假设 A、B、C 三个人都有电话号码，如果 A 把号码告诉给 B，B 把号码告诉给 C，这个过程就建立了一个单链表结构，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ31I54a30.jpg)
图：三人单向通知电话号码形成单链表结构


如果在这个基础上，再从 C 开始将自己的号码告诉给自己所知道号码的主人，这样就形成了双链表结构，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ31IJRI.jpg)
图：三人相互通知电话号码形成双链表结构


那么如果需要获得所有人的号码，只需要从 A 或者 C 开始，要求他们将自己的号码发出来，然后再通知下一个人如此循环，这样就构成了一个列表遍历的过程。

如果 B 换号码了，他需要通知 A 和 C，将自己的号码移除，这个过程就是列表元素的删除操作，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180813/1-1PQ31J0524T.jpg)
图：从双链表中删除一人的电话号码


在Go语言中，列表使用 container/list 包来实现，内部的实现原理是双链表，列表能够高效地进行任意位置的元素插入和删除操作。

#### 初始化列表

list 的初始化有两种方法：分别是使用 New() 函数和 var 关键字声明，两种方法的初始化效果都是一致的。

1) 通过 container/list 包的 New() 函数初始化 list

```go
变量名 := list.New()
```

2) 通过 var 关键字声明初始化 list

```go
var 变量名 list.List
```

列表与切片和 map 不同的是，列表并没有具体元素类型的限制，因此，列表的元素可以是任意类型，这既带来了便利，也引来一些问题，例如给列表中放入了一个 interface{} 类型的值，取出值后，如果要将 interface{} 转换为其他类型将会发生宕机。

#### 在列表中插入元素

双链表支持从队列前方或后方插入元素，分别对应的方法是 PushFront 和 PushBack。

##### 提示

这两个方法都会返回一个 *list.Element 结构，如果在以后的使用中需要删除插入的元素，则只能通过 *list.Element 配合 Remove() 方法进行删除，这种方法可以让删除更加效率化，同时也是双链表特性之一。

下面代码展示如何给 list 添加元素：

```go
l := list.New()
l.PushBack("fist")
l.PushFront(67)
```

代码说明如下：

- 第 1 行，创建一个列表实例。
- 第 3 行，将 fist 字符串插入到列表的尾部，此时列表是空的，插入后只有一个元素。
- 第 4 行，将数值 67 放入列表，此时，列表中已经存在 fist 元素，67 这个元素将被放在 fist 的前面。


列表插入元素的方法如下表所示。

| 方  法                                                | 功  能                                            |
| ----------------------------------------------------- | ------------------------------------------------- |
| InsertAfter(v interface {}, mark * Element) * Element | 在 mark 点之后插入元素，mark 点由其他插入函数提供 |
| InsertBefore(v interface {}, mark * Element) *Element | 在 mark 点之前插入元素，mark 点由其他插入函数提供 |
| PushBackList(other *List)                             | 添加 other 列表元素到尾部                         |
| PushFrontList(other *List)                            | 添加 other 列表元素到头部                         |

#### 从列表中删除元素

列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。

列表操作元素：

```go
package main
import "container/list"
func main() {
    l := list.New()
    // 尾部添加
    l.PushBack("canon")
    // 头部添加
    l.PushFront(67)
    // 尾部添加后保存元素句柄
    element := l.PushBack("fist")
    // 在fist之后添加high
    l.InsertAfter("high", element)
    // 在fist之前添加noon
    l.InsertBefore("noon", element)
    // 使用
    l.Remove(element)
}
```

代码说明如下：
第 6 行，创建列表实例。
第 9 行，将字符串 canon 插入到列表的尾部。
第 12 行，将数值 67 添加到列表的头部。
第 15 行，将字符串 fist 插入到列表的尾部，并将这个元素的内部结构保存到 element 变量中。
第 18 行，使用 element 变量，在 element 的位置后面插入 high 字符串。
第 21 行，使用 element 变量，在 element 的位置前面插入 noon 字符串。
第 24 行，移除 element 变量对应的元素。

下表中展示了每次操作后列表的实际元素情况。

| 操作内容                        | 列表元素                    |
| ------------------------------- | --------------------------- |
| l.PushBack("canon")             | canon                       |
| l.PushFront(67)                 | 67, canon                   |
| element := l.PushBack("fist")   | 67, canon, fist             |
| l.InsertAfter("high", element)  | 67, canon, fist, high       |
| l.InsertBefore("noon", element) | 67, canon, noon, fist, high |
| l.Remove(element)               | 67, canon, noon, high       |

#### 遍历列表——访问列表的每一个元素

遍历双链表需要配合 Front() 函数获取头元素，遍历时只要元素不为空就可以继续进行，每一次遍历都会调用元素的 Next() 函数，代码如下所示。

```go
l := list.New()
// 尾部添加
l.PushBack("canon")
// 头部添加
l.PushFront(67)
for i := l.Front(); i != nil; i = i.Next() {
    fmt.Println(i.Value)
}
```

代码输出如下：

```go
67
canon
```

代码说明如下：

- 第 1 行，创建一个列表实例。
- 第 4 行，将 canon 放入列表尾部。
- 第 7 行，在队列头部放入 67。
- 第 9 行，使用 for 语句进行遍历，其中 i:=l.Front() 表示初始赋值，只会在一开始执行一次，每次循环会进行一次 i != nil 语句判断，如果返回 false，表示退出循环，反之则会执行 i = i.Next()。
- 第 10 行，使用遍历返回的 *list.Element 的 Value 成员取得放入列表时的原值。

### 15. nil：空值/零值

在Go语言中，布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串`""`，而指针、切片、映射、通道、函数和接口的零值则是 nil。

nil 是Go语言中一个预定义好的标识符，有过其他编程语言开发经验的开发者也许会把 nil 看作其他语言中的 null（NULL），其实这并不是完全正确的，因为Go语言中的 nil 和其他语言中的 null 有很多不同点。

下面通过几个方面来介绍一下Go语言中 nil。

#### nil 标识符是不能比较的

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println(nil==nil)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
\# command-line-arguments
.\main.go:8:21: invalid operation: nil == nil (operator == not defined on nil)
```

这点和 python 等动态语言是不同的，在 python 中，两个 None 值永远相等。

```go
>>> None == None
True
```

从上面的运行结果不难看出，`==`对于 nil 来说是一种未定义的操作。

#### nil 不是关键字或保留字

nil 并不是Go语言的关键字或者保留字，也就是说我们可以定义一个名称为 nil 的变量，比如下面这样：

```go
var nil = errors.New("my god")
```

虽然上面的声明语句可以通过编译，但是并不提倡这么做。

#### nil 没有默认类型

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Printf("%T", nil)
    print(nil)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
\# command-line-arguments
.\main.go:9:10: use of untyped nil
```

#### 不同类型 nil 的指针是一样的

```go
package main
import (
    "fmt"
)
func main() {
    var arr []int
    var num *int
    fmt.Printf("%p\n", arr)
    fmt.Printf("%p", num)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
0x0
0x0
```

通过运行结果可以看出 arr 和 num 的指针都是 0x0。

#### 不同类型的 nil 是不能比较的

```go
package main
import (
    "fmt"
)
func main() {
    var m map[int]string
    var ptr *int
    fmt.Printf(m == ptr)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
\# command-line-arguments
.\main.go:10:20: invalid operation: arr == ptr (mismatched types []int and *int)
```

#### 两个相同类型的 nil 值也可能无法比较

在Go语言中 map、slice 和 function 类型的 nil 值不能比较，比较两个无法比较类型的值是非法的，下面的语句无法编译。

```go
package main
import (
    "fmt"
)
func main() {
    var s1 []int
    var s2 []int
    fmt.Printf(s1 == s2)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
\# command-line-arguments
.\main.go:10:19: invalid operation: s1 == s2 (slice can only be compared to nil)
```

通过上面的错误提示可以看出，能够将上述不可比较类型的空值直接与 nil 标识符进行比较，如下所示：

```go
package main
import (
    "fmt"
)
func main() {
    var s1 []int
    fmt.Println(s1 == nil)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
true
```

#### nil 是 map、slice、pointer、channel、func、interface 的零值

```go
package main
import (
    "fmt"
)
func main() {
    var m map[int]string
    var ptr *int
    var c chan int
    var sl []int
    var f func()
    var i interface{}
    fmt.Printf("%#v\n", m)
    fmt.Printf("%#v\n", ptr)
    fmt.Printf("%#v\n", c)
    fmt.Printf("%#v\n", sl)
    fmt.Printf("%#v\n", f)
    fmt.Printf("%#v\n", i)
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
map[int]string(nil)
(*int)(nil)
(chan int)(nil)
[]int(nil)
(func())(nil)
<nil>
```

零值是Go语言中变量在声明之后但是未初始化被赋予的该类型的一个默认值。

#### 不同类型的 nil 值占用的内存大小可能是不一样的

一个类型的所有的值的内存布局都是一样的，nil 也不例外，nil 的大小与同类型中的非 nil 类型的大小是一样的。但是不同类型的 nil 值的大小可能不同。

```go
package main
import (
    "fmt"
    "unsafe"
)
func main() {
    var p *struct{}
    fmt.Println( unsafe.Sizeof( p ) ) // 8
    var s []int
    fmt.Println( unsafe.Sizeof( s ) ) // 24
    var m map[int]bool
    fmt.Println( unsafe.Sizeof( m ) ) // 8
    var c chan string
    fmt.Println( unsafe.Sizeof( c ) ) // 8
    var f func()
    fmt.Println( unsafe.Sizeof( f ) ) // 8
    var i interface{}
    fmt.Println( unsafe.Sizeof( i ) ) // 16
}
```

运行结果如下所示：

```go
PS D:\code> go run .\main.go
8
24
8
8
8
1
```

具体的大小取决于编译器和架构，上面打印的结果是在 64 位架构和标准编译器下完成的，对应 32 位的架构的，打印的大小将减半。

### 16. make和new关键字的区别及实现原理

Go 语言中 new 和 make 是两个内置函数，主要用来创建并分配类型的内存。在我们定义变量的时候，可能会觉得有点迷惑，不知道应该使用哪个函数来声明变量，其实他们的规则很简单，new 只分配内存，而 make 只能用于 slice、map 和 channel 的初始化，下面我们就来具体介绍一下。

#### new

在 Go 语言中，new 函数描述如下：

```go
  // The new built-in function allocates memory. The first argument is a type,
  // not a value, and the value returned is a pointer to a newly
  // allocated zero value of that type.
  func new(Type) \*Type
```

从上面的代码可以看出，new 函数只接受一个参数，这个参数是一个类型，并且返回一个指向该类型内存地址的指针。同时 new 函数会把分配的内存置为零，也就是类型的零值。

【示例】使用 new 函数为变量分配内存空间。

```go
  var sum \*int
  sum = new(int) //分配空间
  \*sum = 98
  fmt.Println(\*sum)
```

当然，new 函数不仅仅能够为系统默认的数据类型，分配空间，自定义类型也可以使用 new 函数来分配空间，如下所示：

```go
  type Student struct {
     name string
     age int
  }

  var s \*Student
  s = new(Student) //分配空间
  s.name ="dequan"

  fmt.Println(s)
```

这里如果我们不使用 new 函数为自定义类型分配空间（将第 7 行注释），就会报错：

panic: runtime error: invalid memory address or nil pointer dereference [signal SIGSEGV: segmentation violation code=0x1 addr=0x0 pc=0x80bd277] goroutine 1 [running]:

这就是 new 函数，它返回的永远是类型的指针，指针指向分配类型的内存地址。

#### make

make 也是用于内存分配的，但是和 new 不同，它只用于 chan、map 以及 slice 的内存创建，而且它返回的类型就是这三个类型本身，而不是他们的指针类型，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了。

在 Go 语言中，make 函数的描述如下：

```go
  // The make built-in function allocates and initializes an object of type
  // slice, map, or chan (only). Like new, the first argument is a type, not a
  // value. Unlike new, make's return type is the same as the type of its
  // argument, not a pointer to it. The specification of the result depends on
  // the type:
  // Slice: The size specifies the length. The capacity of the slice is
  // equal to its length. A second integer argument may be provided to
  // specify a different capacity; it must be no smaller than the
  // length, so make(\[\]int, 0, 10) allocates a slice of length 0 and
  // capacity 10.
  // Map: An empty map is allocated with enough space to hold the
  // specified number of elements. The size may be omitted, in which case
  // a small starting size is allocated.
  // Channel: The channel's buffer is initialized with the specified
  // buffer capacity. If zero, or the size is omitted, the channel is
  // unbuffered.
  func make(t Type, size ...IntegerType) Type
```

通过上面的代码可以看出 make 函数的 t 参数必须是 chan（通道）、map（字典）、slice（切片）中的一个，并且返回值也是类型本身。

注意：make 函数只用于 map，slice 和 channel，并且不返回指针。如果想要获得一个显式的指针，可以使用 new 函数进行分配，或者显式地使用一个变量的地址。

Go 语言中的 new 和 make 主要区别如下：

- make 只能用来分配及初始化类型为 slice、map、chan 的数据。new 可以分配任意类型的数据；

- new 分配返回的是指针，即类型 *Type。make 返回引用，即 Type；

- new 分配的空间被清零。make 分配空间后，会进行初始化。

#### 实现原理

接下来我们将分别介绍一下 make 和 new 在初始化不同数据结构时的具体过程，我们会从编译期间和运行时两个不同的阶段理解这两个关键字的原理。

##### make

我们已经了解了 make 在创建 slice、map 和 channel 的具体过程，所以在这里我们也只是会简单提及 make 相关的数据结构初始化原理。

[![img](http://c.biancheng.net/uploads/allimg/190903/4-1ZZ31I35HJ.gif)](http://c.biancheng.net/uploads/allimg/190903/4-1ZZ31I35HJ.gif)

在编译期的类型检查阶段，Go 语言其实就将代表 make 关键字的 OMAKE 节点根据参数类型的不同转换成了 OMAKESLICE、OMAKEMAP 和 OMAKECHAN 三种不同类型的节点，这些节点最终也会调用不同的运行时函数来初始化数据结构。

##### new

内置函数 new 会在编译期的 SSA 代码生成阶段经过 callnew 函数的处理，如果请求创建的类型大小是 0，那么就会返回一个表示空指针的 zerobase 变量，在遇到其他情况时会将关键字转换成 newobject：

```go
  func callnew(t *types.Type) *Node {
      if t.NotInHeap() {
          yyerror("%v is go:notinheap; heap allocation disallowed", t)
      }
      dowidth(t)

      if t.Size() == 0 {
          z := newname(Runtimepkg.Lookup("zerobase"))
          z.SetClass(PEXTERN)
          z.Type = t
          return typecheck(nod(OADDR, z, nil), ctxExpr)
      }

      fn := syslook("newobject")
      fn = substArgTypes(fn, t)
      v := mkcall1(fn, types.NewPtr(t), nil, typename(t))
      v.SetNonNil(true)
      return v
  }
```

需要提到的是，哪怕当前变量是使用 var 进行初始化，在这一阶段也可能会被转换成 newobject 的函数调用并在堆上申请内存：

```go
  func walkstmt(n *Node) *Node {
      switch n.Op {
      case ODCL:
          v := n.Left
          if v.Class() == PAUTOHEAP {
              if prealloc[v] == nil {
                  prealloc[v] = callnew(v.Type)
              }
              nn := nod(OAS, v.Name.Param.Heapaddr, prealloc[v])
              nn.SetColas(true)
              nn = typecheck(nn, ctxStmt)
              return walkstmt(nn)
          }
      case ONEW:
          if n.Esc == EscNone {
              r := temp(n.Type.Elem())
              r = nod(OAS, r, nil)
              r = typecheck(r, ctxStmt)
              init.Append(r)
              r = nod(OADDR, r.Left, nil)
              r = typecheck(r, ctxExpr)
              n = r
          } else {
              n = callnew(n.Type.Elem())
          }
      }
  }
```

当然这也不是绝对的，如果当前声明的变量或者参数不需要在当前作用域外生存，那么其实就不会被初始化在堆上，而是会初始化在当前函数的栈中并随着函数调用的结束而被销毁。

newobject 函数的工作就是获取传入类型的大小并调用 mallocgc 在堆上申请一片大小合适的内存空间并返回指向这片内存空间的指针：

```go
func newobject(typ *_type) unsafe.Pointer {
    return mallocgc(typ.size, typ, true)
}
```

#### 总结

最后，简单总结一下 Go 语言中 make 和 new 关键字的实现原理，make 关键字的主要作用是创建 slice、map 和 Channel 等内置的数据结构，而 new 的主要作用是为类型申请一片内存空间，并返回指向这片内存的指针。

## 第四章 流程控制

### 1. 分支结构

在Go语言中，关键字 if 是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行 if 后由大括号`{}`括起来的代码块，否则就忽略该代码块继续执行后续的代码。

```go
if condition {
    // do something
}
```

如果存在第二个分支，则可以在上面代码的基础上添加 else 关键字以及另一代码块，这个代码块中的代码只有在条件不满足时才会执行，if 和 else 后的两个代码块是相互独立的分支，只能执行其中一个。

```go
if condition {
    // do something
} else {
    // do something
}
```

如果存在第三个分支，则可以使用下面这种三个独立分支的形式：

```go
if condition1 {
    // do something
} else if condition2 {
    // do something else
}else {
    // catch-all or default
}
```

else if 分支的数量是没有限制的，但是为了代码的可读性，还是不要在 if 后面加入太多的 else if 结构，如果必须使用这种形式，则尽可能把先满足的条件放在前面。

关键字 if 和 else 之后的左大括号`{`必须和关键字在同一行，如果你使用了 else if 结构，则前段代码块的右大括号`}`必须和 else if 关键字在同一行，这两条规则都是被编译器强制规定的。

非法的 Go 代码:

```go
if x{
}
else { // 无效的
}
```

要注意的是，在使用 gofmt 格式化代码之后，每个分支内的代码都会缩进 4 个或 8 个空格，或者是 1 个 tab，并且右大括号`}`与对应的 if 关键字垂直对齐。

在有些情况下，条件语句两侧的括号是可以被省略的，当条件比较复杂时，则可以使用括号让代码更易读，在使用 &&、|| 或 ! 时可以使用括号来提升某个表达式的运算优先级，并提高代码的可读性。

#### 举例

通过下面的例子来了解 if 的写法：

```go
var ten int = 11
if ten > 10 {
    fmt.Println(">10")
} else {
    fmt.Println("<=10")
}
```

代码输出如下：

```go
>10
```

代码说明如下：

- 第 1 行，声明整型变量并赋值 11。
- 第 2 行，判断当 ten 的值大于 10 时执行第 3 行，否则执行第 4 行。
- 第 3 和第 5 行，分别打印大于 10 和小于等于 10 时的输出。

#### 特殊写法

if 还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，代码如下：

```go
if err := Connect(); err != nil {
    fmt.Println(err)
    return
}
```

Connect 是一个带有返回值的函数，err:=Connect() 是一个语句，执行 Connect 后，将错误保存到 err 变量中。

err != nil 才是 if 的判断表达式，当 err 不为空时，打印错误并返回。

这种写法可以将返回值与判断放在一行进行处理，而且返回值的作用范围被限制在 if、else 语句组合中。

#### 提示

在编程中，变量的作用范围越小，所造成的问题可能性越小，每一个变量代表一个状态，有状态的地方，状态就会被修改，函数的局部变量只会影响一个函数的执行，但全局变量可能会影响所有代码的执行状态，因此限制变量的作用范围对代码的稳定性有很大的帮助。

### 2. 循环结构

与多数语言不同的是，Go语言中的循环语句只支持 for 关键字，而不支持 while 和 do-while 结构，关键字 for 的基本使用方法与C语言和 [C++](http://c.biancheng.net/cplus/) 中非常接近：

```go
sum := 0
for i := 0; i < 10; i++ {
    sum += i
}
```

可以看到比较大的一个不同在于 for 后面的条件表达式不需要用圆括号`()`括起来，Go语言还进一步考虑到无限循环的场景，让开发者不用写无聊的 `for(;;){}`和`do{} while(1);`，而直接简化为如下的写法：

```go
sum := 0
for {
    sum++
    if sum > 100 {
        break
    }
```

使用循环语句时，需要注意的有以下几点：

- 左花括号`{`必须与 for 处于同一行。
- Go语言中的 for 循环与C语言一样，都允许在循环条件中定义和初始化变量，唯一的区别是，Go语言不支持以逗号为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量。
- Go语言的 for 循环同样支持 continue 和 break 来控制循环，但是它提供了一个更高级的 break，可以选择中断哪一个循环，如下例：

```go
for j := 0; j < 5; j++ {
    for i := 0; i < 10; i++ {
        if i > 5 {
            break JLoop
        }
        fmt.Println(i)
    }
}
JLoop:
// ...
```

上述代码中，break 语句终止的是 JLoop 标签处的外层循环。

#### for 中的初始语句——开始循环时执行的语句

初始语句是在第一次循环前执行的语句，一般使用初始语句执行变量初始化，如果变量在此处被声明，其作用域将被局限在这个 for 的范围内。

初始语句可以被忽略，但是初始语句之后的分号必须要写，代码如下：

```go
step := 2
for ; step > 0; step-- {
    fmt.Println(step)
}
```

这段代码将 step 放在 for 的前面进行初始化，for 中没有初始语句，此时 step 的作用域就比在初始语句中声明 step 要大。

#### for 中的条件表达式——控制是否循环的开关

每次循环开始前都会计算条件表达式，如果表达式为 true，则循环继续，否则结束循环，条件表达式可以被忽略，忽略条件表达式后默认形成无限循环。

##### 1) 结束循环时带可执行语句的无限循环

下面代码忽略条件表达式，但是保留结束语句，代码如下：

```go
var i int
for ; ; i++ {
    if i > 10 {
        break
    }
}
```

代码说明如下：

- 第 3 行，无须设置 i 的初始值，因此忽略 for 的初始语句，两个分号之间是条件表达式，也被忽略，此时循环会一直持续下去，for 的结束语句为 i++，每次结束循环前都会调用。
- 第 5 行，判断 i 大于 10 时，通过 break 语句跳出 for 循环到第 9 行。

##### 2) 无限循环

上面的代码还可以改写为更美观的写法，代码如下：

```go
var i int
for {
    if i > 10 {
        break
    }
    i++
}
```

代码说明如下：

- 第 3 行，忽略 for 的所有语句，此时 for 执行无限循环。
- 第 9 行，将 i++ 从 for 的结束语句放置到函数体的末尾是等效的，这样编写的代码更具有可读性。


无限循环在收发处理中较为常见，但需要无限循环有可控的退出方式来结束循环。

##### 3) 只有一个循环条件的循环

在上面代码的基础上进一步简化代码，将 if 判断整合到 for 中，变为下面的代码：

```go
var i int
for i <= 10 {
    i++
}
```

在代码第 3 行中，将之前使用`if i>10{}`判断的表达式进行取反，变为判断 i 小于等于 10 时持续进行循环。

上面这段代码其实类似于其他编程语言中的 while，在 while 后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。

#### for 中的结束语句——每次循环结束时执行的语句

在结束每次循环前执行的语句，如果循环被 break、goto、return、panic 等语句强制退出，结束语句不会被执行。

### 3. 输出九九乘法表

熟悉了Go语言的基本循环格式后，让我们用一个例子来温习一遍吧。

输出九九乘法表：

```go
package main
import "fmt"
func main() {
    // 遍历, 决定处理第几行
    for y := 1; y <= 9; y++ {
        // 遍历, 决定这一行有多少列
        for x := 1; x <= y; x++ {
            fmt.Printf("%d*%d=%d ", x, y, x*y)
        }
        // 手动生成回车
        fmt.Println()
    }
}
```

结果输出如下：

```go
1*1=1
1*2=2 2*2=4
1*3=3 2*3=6   3*3=9
1*4=4 2*4=8   3*4=12 4*4=16
1*5=5 2*5=10  3*5=15 4*5=20 5*5=25
1*6=6 2*6=12  3*6=18 4*6=24 5*6=30 6*6=36
1*7=7 2*7=14  3*7=21 4*7=28 5*7=35 6*7=42 7*7=49
1*8=8 2*8=16  3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64
1*9=9 2*9=18  3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81
```

代码说明如下：

- 第 8 行，生成 1～9 的数字，对应乘法表的每一行，也就是被乘数。
- 第 11 行，乘法表每一行中的列数随着行数的增加而增加，这一行的 x 表示该行有多少列。
- 第 16 行，打印一个空行，实际作用就是换行。


这段程序按行优先打印，打印完一行，换行（第 16 行），接着执行下一行乘法表直到整个数值循环完毕。

### 4. for range（键值循环）

for range 结构是Go语言特有的一种的迭代结构，在许多情况下都非常有用，for range 可以遍历数组、切片、字符串、map 及通道（channel），for range 语法上类似于其它语言中的 foreach 语句，一般形式为：

```go
for key, val := range coll {
  ...
}
```

需要要注意的是，val 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值。一个字符串是 Unicode 编码的字符（或称之为 rune ）集合，因此也可以用它来迭代字符串：

```go
for pos, char := range str {
  ...
}
```

每个 rune 字符和索引在 for range 循环中是一一对应的，它能够自动根据 UTF-8 规则识别 Unicode 编码的字符。

通过 for range 遍历的返回值有一定的规律：

- 数组、切片、字符串返回索引和值。
- map 返回键和值。
- 通道（channel）只返回通道内的值。

#### 遍历数组、切片——获得索引和值

在遍历代码中，key 和 value 分别代表切片的下标及下标对应的值，下面的代码展示如何遍历切片，数组也是类似的遍历方法：

```go
for key, value := range []int{1, 2, 3, 4} {
    fmt.Printf("key:%d  value:%d\n", key, value)
}
```

代码输出如下：

```go
key:0 value:1
key:1 value:2
key:2 value:3
key:3 value:4
```

#### 遍历字符串——获得字符

Go语言和其他语言类似，可以通过 for range 的组合，对字符串进行遍历，遍历时，key 和 value 分别代表字符串的索引和字符串中的每一个字符。

下面这段代码展示了如何遍历字符串：

```go
var str = "hello 你好"
for key, value := range str {
    fmt.Printf("key:%d value:0x%x\n", key, value)
}
```

代码输出如下：

```go
key:0 value:0x68
key:1 value:0x65
key:2 value:0x6c
key:3 value:0x6c
key:4 value:0x6f
key:5 value:0x20
key:6 value:0x4f60
key:9 value:0x597d
```

代码中的变量 value，实际类型是 rune 类型，以十六进制打印出来就是字符的编码。

#### 遍历 map——获得 map 的键和值

对于 map 类型来说，for range 遍历时，key 和 value 分别代表 map 的索引键 key 和索引对应的值，一般被称为 map 的键值对，因为它们是一对一对出现的，下面的代码演示了如何遍历 map。

```go
m := map[string]int{
    "hello": 100,
    "world": 200,
}
for key, value := range m {
    fmt.Println(key, value)
}
```

代码输出如下：

```go
hello 100
world 200
```

#### 注意

对 map 遍历时，遍历输出的键值是无序的，如果需要有序的键值对输出，需要对结果进行排序。

#### 遍历通道（channel）——接收通道数据

for range 可以遍历通道（channel），但是通道在遍历时，只输出一个值，即管道内的类型对应的数据。

下面代码为我们展示了通道的遍历：

```go
c := make(chan int)
go func() {
    c <- 1
    c <- 2
    c <- 3
    close(c)
}()
for v := range c {
    fmt.Println(v)
}
```

代码说明如下：

- 第 1 行创建了一个整型类型的通道。
- 第 3 行启动了一个 goroutine，其逻辑的实现体现在第 5～8 行，实现功能是往通道中推送数据 1、2、3，然后结束并关闭通道。
- 这段 goroutine 在声明结束后，在第 9 行马上被执行。
- 从第 11 行开始，使用 for range 对通道 c 进行遍历，其实就是不断地从通道中取数据，直到通道被关闭。

#### 在遍历中选择希望获得的变量

在使用 for range 循环遍历某个对象时，一般不会同时需要 key 或者 value，这个时候可以采用一些技巧，让代码变得更简单，下面将前面的例子修改一下，参考下面的代码示例：

```go
m := map[string]int{
    "hello": 100,
    "world": 200,
}
for _, value := range m {
    fmt.Println(value)
}
```

代码输出如下：

```go
100
200
```

在上面的例子中将 key 变成了下划线`_`，这里的下划线就是匿名变量。

- 可以理解为一种占位符。
- 匿名变量本身不会进行空间分配，也不会占用一个变量的名字。
- 在 for range 可以对 key 使用匿名变量，也可以对 value 使用匿名变量。


再看一个匿名变量的例子：

```go
for key, _ := range []int{1, 2, 3, 4} {
    fmt.Printf("key:%d \n", key)
}
```

代码输出如下：

```go
key:0
key:1
key:2
key:3
```

在该例子中，value 被设置为匿名变量，只使用 key，而 key 本身就是切片的索引，所以例子输出索引。

我们总结一下 for 的功能：

- Go语言的 for 包含初始化语句、条件表达式、结束语句，这 3 个部分均可缺省。
- for range 支持对数组、切片、字符串、map、通道进行遍历操作。
- 在需要时，可以使用匿名变量对 for range 的变量进行选取。

### 5. switch case语句

Go语言的 switch 要比C语言的更加通用，表达式不需要为常量，甚至不需要为整数，case 按照从上到下的顺序进行求值，直到找到匹配的项，如果 switch 没有表达式，则对 true 进行匹配，因此，可以将 if else-if else 改写成一个 switch。

相对于C语言和 [Java](http://c.biancheng.net/java/) 等其它语言来说，Go语言中的 switch 结构使用上更加灵活，语法设计尽量以使用方便为主。

#### 基本写法

Go语言改进了 switch 的语法设计，case 与 case 之间是独立的代码块，不需要通过 break 语句跳出当前 case 代码块以避免执行到下一行，示例代码如下：

```go
var a = "hello"
switch a {
case "hello":
    fmt.Println(1)
case "world":
    fmt.Println(2)
default:
    fmt.Println(0)
}
```

代码输出如下：

```go
1
```

上面例子中，每一个 case 均是字符串格式，且使用了 default 分支，Go语言规定每个 switch 只能有一个 default 分支。

##### 1) 一分支多值

当出现多个 case 要放在一起的时候，可以写成下面这样：

```go
var a = "mum"
switch a {
case "mum", "daddy":
    fmt.Println("family")
}
```

不同的 case 表达式使用逗号分隔。

##### 2) 分支表达式

case 后不仅仅只是常量，还可以和 if 一样添加表达式，代码如下：

```go
var r int = 11
switch {
case r > 10 && r < 20:
    fmt.Println(r)
}
```

注意，这种情况的 switch 后面不再需要跟判断变量。

#### 跨越 case 的 fallthrough——兼容C语言的 case 设计

在Go语言中 case 是一个独立的代码块，执行完毕后不会像C语言那样紧接着执行下一个 case，但是为了兼容一些移植代码，依然加入了 fallthrough 关键字来实现这一功能，代码如下：

```go
var s = "hello"
switch {
case s == "hello":
    fmt.Println("hello")
    fallthrough
case s != "world":
    fmt.Println("world")
}
```

代码输出如下：

```go
hello
world
```

新编写的代码，不建议使用 fallthrough。

### 6. goto语句(跳转到指定的标签)

Go语言中 goto 语句通过标签进行代码间的无条件跳转，同时 goto 语句在快速跳出循环、避免重复退出上也有一定的帮助，使用 goto 语句能简化一些代码的实现过程。

#### 使用 goto 退出多层循环

下面这段代码在满足条件时，需要连续退出两层循环，使用传统的编码方式如下：

```go
package main
import "fmt"
func main() {
    var breakAgain bool
    // 外循环
    for x := 0; x < 10; x++ {
        // 内循环
        for y := 0; y < 10; y++ {
            // 满足某个条件时, 退出循环
            if y == 2 {
                // 设置退出标记
                breakAgain = true
                // 退出本次循环
                break
            }
        }
        // 根据标记, 还需要退出一次循环
        if breakAgain {
                break
        }
    }
    fmt.Println("done")
}
```

代码说明如下：

- 第 10 行，构建外循环。
- 第 13 行，构建内循环。
- 第 16 行，当 y==2 时需要退出所有的 for 循环。
- 第 19 行，默认情况下循环只能一层一层退出，为此就需要设置一个状态变量 breakAgain，需要退出时，设置这个变量为 true。
- 第 22 行，使用 break 退出当前循环，执行后，代码调转到第 28 行。
- 第 28 行，退出一层循环后，根据 breakAgain 变量判断是否需要再次退出外层循环。
- 第 34 行，退出所有循环后，打印 done。


将上面的代码使用Go语言的 goto 语句进行优化：

```go
package main
import "fmt"
func main() {
    for x := 0; x < 10; x++ {
        for y := 0; y < 10; y++ {
            if y == 2 {
                // 跳转到标签
                goto breakHere
            }
        }
    }
    // 手动返回, 避免执行进入标签
    return
    // 标签
breakHere:
    fmt.Println("done")
}
```

代码说明如下：

- 第 13 行，使用 goto 语句跳转到指明的标签处，标签在第 23 行定义。
- 第 20 行，标签只能被 goto 使用，但不影响代码执行流程，此处如果不手动返回，在不满足条件时，也会执行第 24 行代码。
- 第 23 行，定义 breakHere 标签。


使用 goto 语句后，无须额外的变量就可以快速退出所有的循环。

#### 使用 goto 集中处理错误

多处错误处理存在代码重复时是非常棘手的，例如：

```go
err := firstCheckError()
if err != nil {
    fmt.Println(err)
    exitProcess()
    return
}
err = secondCheckError()
if err != nil {
    fmt.Println(err)
    exitProcess()
    return
}
fmt.Println("done")
```

代码说明如下：

- 第 1 行，执行某逻辑，返回错误。
- 第 2～6 行，如果发生错误，打印错误退出进程。
- 第 8 行，执行某逻辑，返回错误。
- 第 10～14 行，发生错误后退出流程。
- 第 16 行，没有任何错误，打印完成。


在上面代码中，有一部分都是重复的错误处理代码，如果后期在这些代码中添加更多的判断，就需要在这些雷同的代码中依次修改，极易造成疏忽和错误。

使用 goto 语句来实现同样的逻辑：

```go
 err := firstCheckError()
    if err != nil {
        goto onExit
    }
    err = secondCheckError()
    if err != nil {
        goto onExit
    }
    fmt.Println("done")
    return
onExit:
    fmt.Println(err)
    exitProcess()
```

代码说明如下：

- 第 3 行和第 9 行，发生错误时，跳转错误标签 onExit。
- 第 17 行和第 18 行，汇总所有流程进行错误打印并退出进程。

### 7. break（跳出循环）

Go语言中 break 语句可以结束 for、switch 和 select 的代码块，另外 break 语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的 for、switch 和 select 的代码块上。

跳出指定循环：

```go
package main
import "fmt"
func main() {
OuterLoop:
    for i := 0; i < 2; i++ {
        for j := 0; j < 5; j++ {
            switch j {
            case 2:
                fmt.Println(i, j)
                break OuterLoop
            case 3:
                fmt.Println(i, j)
                break OuterLoop
            }
        }
    }
}
```

代码输出如下：

```go
0 2
```

代码说明如下：

- 第 7 行，外层循环的标签。
- 第 8 行和第 9 行，双层循环。
- 第 10 行，使用 switch 进行数值分支判断。
- 第 13 和第 16 行，退出 OuterLoop 对应的循环之外，也就是跳转到第 20 行。

### 8. continue（继续下一次循环）

Go语言中 continue 语句可以结束当前循环，开始下一次的循环迭代过程，仅限在 for 循环内使用，在 continue 语句后添加标签时，表示开始标签对应的循环，例如：

```go
package main
import "fmt"
func main() {
OuterLoop:
    for i := 0; i < 2; i++ {
        for j := 0; j < 5; j++ {
            switch j {
            case 2:
                fmt.Println(i, j)
                continue OuterLoop
            }
        }
    }
}
```

代码输出结果如下：

```go
0 2
1 2
```

代码说明：第 14 行将结束当前循环，开启下一次的外层循环，而不是第 10 行的循环。

### 9. 聊天机器人

结合咱们之前的学习，本节带领大家来编写一个聊天机器人的雏形，下面的代码中展示了一个简单的聊天程序。

```go
  package main

  import (
      "bufio"
      "fmt"
      "os"
      "strings"
  )

  func main() {
      // 准备从标准输入读取数据。
      inputReader := bufio.NewReader(os.Stdin)
      fmt.Println("Please input your name:")
      // 读取数据直到碰到 \\n 为止。
      input, err := inputReader.ReadString('\n')
      if err != nil {
          fmt.Printf("An error occurred: %s\n", err)
          // 异常退出。
          os.Exit(1)
      } else {
          // 用切片操作删除最后的 \\n 。
          name := input\[:len(input)-2\]
          fmt.Printf("Hello, %s! What can I do for you?\n", name)
      }
      for {
          input, err = inputReader.ReadString('\n')
          if err != nil {
              fmt.Printf("An error occurred: %s\n", err)
              continue
          }
          input = input[:len(input)-2]
          // 全部转换为小写。
          input = strings.ToLower(input)
          switch input {
          case "":
              continue
          case "nothing", "bye":
              fmt.Println("Bye!")
              // 正常退出。
              os.Exit(0)
          default:
              fmt.Println("Sorry, I didn't catch you.")
          }
      }
  }
```

这个聊天程序在问候用户之后会不断地询问 “是否可以帮忙”，但是实际上它什么忙也帮不上，因为它现在什么也听不懂，除了 nothing 和 bye，一看到这两个词，它就会与用户 “道别”，停止运行，现在试运行一下这个命令源码文件：

```go
D:\code>go run test.go
Please input your name:
->Robert
Hello, Robert! What can I do for you?
->A piece of cake, please.
Sorry, I didn’t catch you.
->Bye
Bye!
```

注意，其中的 “->” 符号之后的内容是我们输入的。

### 10. 词频统计

从数据挖掘到语言学习本身，文本分析功能的应用非常广泛，本一节我们来分析一个例子，它是文本分析最基本的一种形式：统计出一个文件里单词出现的频率。

示例中频率统计后的结果以两种不同的方式显示，一种是将单词按照字母顺序把单词和频率排列出来，另一种是按照有序列表的方式把频率和对应的单词显示出来，完整的示例代码如下所示：

```go
  package main

  import (
      "bufio"
      "fmt"
      "io"
      "log"
      "os"
      "path/filepath"
      "runtime"
      "sort"
      "strings"
      "unicode"
      "unicode/utf8"
  )

  func main() {
      if len(os.Args) == 1 || os.Args\[1\] == "-h" || os.Args[1] == "--help" {
          fmt.Printf("usage: %s <file1> [<file2> [... <fileN>]]\n",
              filepath.Base(os.Args\[0\]))
          os.Exit(1)
      }

      frequencyForWord := map[string]int{} // 与:make(map\[string\]int)相同
      for _, filename := range commandLineFiles(os.Args[1:]) {
          updateFrequencies(filename, frequencyForWord)
      }
      reportByWords(frequencyForWord)
      wordsForFrequency := invertStringIntMap(frequencyForWord)
      reportByFrequency(wordsForFrequency)
  }

  func commandLineFiles(files []string) []string {
      if runtime.GOOS == "windows" {
          args := make([]string, 0, len(files))
          for _, name := range files {
              if matches, err := filepath.Glob(name); err != nil {
                  args = append(args, name) // 无效模式
              } else if matches != nil {
                  args = append(args, matches...)
              }
          }
          return args
      }
      return files
  }

  func updateFrequencies(filename string, frequencyForWord map[string]int) {
      var file *os.File
      var err error
      if file, err = os.Open(filename); err != nil {
          log.Println("failed to open the file: ", err)
          return
      }
      defer file.Close()
      readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)
  }

  func readAndUpdateFrequencies(reader *bufio.Reader,
      frequencyForWord map[string]int) {
      for {
          line, err := reader.ReadString('\n')
          for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {
              if len(word) > utf8.UTFMax ||
                  utf8.RuneCountInString(word) > 1 {
                  frequencyForWord[strings.ToLower(word)] += 1
              }
          }
          if err != nil {
              if err != io.EOF {
                  log.Println("failed to finish reading the file: ", err)
              }
              break
          }
      }
  }

  func SplitOnNonLetters(s string) []string {
      notALetter := func(char rune) bool { return !unicode.IsLetter(char) }
      return strings.FieldsFunc(s, notALetter)
  }

  func invertStringIntMap(intForString map[string]int) map[int][]string {
      stringsForInt := make(map[int][]string, len(intForString))
      for key, value := range intForString {
          stringsForInt[value] = append(stringsForInt[value], key)
      }
      return stringsForInt
  }

  func reportByWords(frequencyForWord map[string]int) {
     words := make([]string, 0, len(frequencyForWord))
      wordWidth, frequencyWidth := 0, 0
      for word, frequency := range frequencyForWord {
          words = append(words, word)
          if width := utf8.RuneCountInString(word); width > wordWidth {
              wordWidth = width
          }
          if width := len(fmt.Sprint(frequency)); width > frequencyWidth {
              frequencyWidth = width
          }
      }
      sort.Strings(words)
      gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")
      fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")
      for _, word := range words {
          fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,
              frequencyForWord[word])
      }
  }

  func reportByFrequency(wordsForFrequency map[int][]string) {
      frequencies := make([]int, 0, len(wordsForFrequency))
      for frequency := range wordsForFrequency {
          frequencies = append(frequencies, frequency)
      }
      sort.Ints(frequencies)
      width := len(fmt.Sprint(frequencies[len(frequencies)-1]))
      fmt.Println("Frequency → Words")
      for _, frequency := range frequencies {
          words := wordsForFrequency[frequency]
          sort.Strings(words)
          fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))
      }
  }
```

程序的运行结果如下所示。

```go
PS D:\code> go run .\main.go small-file.txt
Word       Frequency
ability                     1
about                     1
above                     3
years                      1
you                    128

Frequency → Words
    1 ability, about, absence, absolute, absolutely, abuse, accessible, …
    2 accept, acquired, after, against, applies, arrange, assumptions, …
…
128    you
151    or
192    to
221    of
345    the
```

其中，small-file.txt 为待统计的文件名，它不是固定的，可以根据实际情况自行调整。由于输出的结果太多，所以上面只截取了部分内容。

通过上面的输出结果可以看出，第一种输出是比较直接的，我们可以使用一个 `map[string]int` 类型的结构来保存每一个单词的频率，但是要得到第二种输出结果我们需要将整个映射反转成多值类型的映射，如 `map[int][]string`，也就是说，键是频率而值则是所有具有这个频率的单词。

接下来我们将从程序的 main() 函数开始，从上到下分析。

```go
  func main() {
      if len(os.Args) == 1 || os.Args[1] == "-h" || os.Args[1] == "--help" {
          fmt.Printf("usage: %s <file1> [<file2> [... <fileN>]]\n",
              filepath.Base(os.Args[0]))
          os.Exit(1)
      }

      frequencyForWord := map[string]int{} // 与:make(map\[string\]int)相同

      for _, filename := range commandLineFiles(os.Args[1:]) {
          updateFrequencies(filename, frequencyForWord)
      }
      reportByWords(frequencyForWord)
      wordsForFrequency := invertStringIntMap(frequencyForWord)
      reportByFrequency(wordsForFrequency)
  }
```

main() 函数首先分析命令行参数，之后再进行相应处理。

我们使用复合语法创建一个空的映射，用来保存从文件读到的每一个单词和对应的频率，接着我们遍历从命令行得到的每一个文件，分析每一个文件后更新 frequencyForWord 的数据。

得到第一个映射之后，我们就可以输出第一个报告了（按照字母顺序排列的列表），然后我们创建一个反转的映射，输出第二个报告（按出现频率统计并排序的列表）。

```go
  func commandLineFiles(files []string) []string {
      if runtime.GOOS == "windows" {
          args := make([]string, 0, len(files))
          for _, name := range files {
              if matches, err := filepath.Glob(name); err != nil {
                  args = append(args, name) // 无效模式
              } else if matches != nil {
                  args = append(args, matches...)
              }
          }
          return args
      }
      return files
  }
```

因为 Unix 类系统（如 Linux 或 Mac OS X 等）的命令行工具默认会自动处理通配符（也就是说，*.txt 能匹配任意后缀为 .txt 的文件，如 README.txt 和 INSTALL.txt 等），而 Windows 平台的命令行工具（CMD）不支持通配符，所以如果用户在命令行输入 *.txt，那么程序只能接收到 *.txt。

为了保持平台之间的一致性，这里使用 commandLineFiles() 函数来实现跨平台的处理，当程序运行在 Windows 平台时，实现文件名通配功能。

```go
  func updateFrequencies(filename string, frequencyForWord map[string]int) {
      var file *os.File
      var err error
      if file, err = os.Open(filename); err != nil {
          log.Println("failed to open the file: ", err)
          return
      }
      defer file.Close()
      readAndUpdateFrequencies(bufio.NewReader(file), frequencyForWord)
  }
```

updateFrequencies() 函数纯粹就是用来处理文件的，它打开给定的文件，并使用 defer 在函数返回时关闭文件，这里我们将文件作为一个 *bufio.Reader（使用 bufio.NewReader() 函数创建）传给 readAndUpdateFrequencies() 函数，因为这个函数是以字符串的形式一行一行地读取数据的，所以实际的工作都是在 readAndUpdateFrequencies() 函数里完成的，代码如下。

```go
  func readAndUpdateFrequencies(reader *bufio.Reader, frequencyForWord map[string]int) {
      for {
          line, err := reader.ReadString('\n')
          for _, word := range SplitOnNonLetters(strings.TrimSpace(line)) {
              if len(word) > utf8.UTFMax || utf8.RuneCountInString(word) > 1 {
                  frequencyForWord[strings.ToLower(word)] += 1
              }
          }
          if err != nil {
              if err != io.EOF {
                  log.Println("failed to finish reading the file: ", err)
              }
              break
          }
      }
  }
```

第一部分的代码我们应该很熟悉了，用了一个无限循环来一行一行地读一个文件，当读到文件结尾或者出现错误的时候就退出循环，将错误报告给用户但并不退出程序，因为还有很多其他的文件需要去处理。

任意一行都可能包括标点、数字、符号或者其他非单词字符，所以我们需要逐个单词地去读，将每一行分隔成若干个单词并使用 SplitOnNonLetters() 函数忽略掉非单词的字符，并且过滤掉字符串开头和结尾的空白。

只需要记录含有两个以上（包括两个）字母的单词，可以通过使用 if 语句，如 utf8.RuneCountlnString(word) > 1 来完成。

上面描述的 if 语句有一点性能损耗，因为它会分析整个单词，所以在这个程序里我们增加了一个判断条件，用来检査这个单词的字节数是否大于 utf8.UTFMax（utf8.UTFMax 是一个常量，值为 4，用来表示一个 UTF-8 字符最多需要几个字节）。

```go
  func SplitOnNonLetters(s string) \[\]string {
      notALetter := func(char rune) bool { return !unicode.IsLetter(char) }
      return strings.FieldsFunc(s, notALetter)
  }
```

SplitOnNonLetters() 函数用来在非单词字符上对一个字符串进行切分，首先我们为 strings.FieldsFunc() 函数创建一个匿名函数 notALetter，如果传入的是字符那就返回 false，否则返回 true，然后返回调用函数 strings.FieldsFunc() 的结果，调用的时候将给定的字符串和 notALetter 作为它的参数。

```go
  func reportByWords(frequencyForWord map[string]int) {
      words := make([]string, 0, len(frequencyForWord))
      wordWidth, frequencyWidth := 0, 0
      for word, frequency := range frequencyForWord {
          words = append(words, word)
          if width := utf8.RuneCountInString(word); width > wordWidth {
              wordWidth = width
          }
          if width := len(fmt.Sprint(frequency)); width > frequencyWidth {
              frequencyWidth = width
          }
      }
      sort.Strings(words)
      gap := wordWidth + frequencyWidth - len("Word") - len("Frequency")
      fmt.Printf("Word %*s%s\n", gap, " ", "Frequency")
      for _, word := range words {
          fmt.Printf("%-*s %*d\n", wordWidth, word, frequencyWidth,
              frequencyForWord[word])
      }
  }
```

计算出了 frequencyForWord 之后，调用 reportByWords() 将它的数据打印出来，因为我们需要将输出结果按照字母顺序排序好，所以首先要创建一个空的容量足够大的 []string 切片来保存所有在 frequencyForWord 里的单词。

第一个循环遍历映射里的所有项，把每个单词追加到 words 字符串切片里去，使用 append() 函数只需要把给定的单词追加到第 len(words) 个索引位置上即可，words 的长度会自动增加 1。

得到了 words 切片之后，对它进行排序，这个在 readAndUpdateFrequencies() 函数中已经处理好了。

经过排序之后我们打印两列标题，第一个是 “Word”，为了能让 Frequency 最后一个字符 y 右对齐，需要在 “Word” 后打印一些空格，通过 `%*s` 可以实现的打印固定长度的空白，也可以使用 `%s` 来打印 strings.Repeat(" ", gap) 返回的字符串。

最后，我们将单词和它们的频率用两列方式按照字母顺序打印出来。

```go
  func invertStringIntMap(intForString map[string]int) map[int][]string {
      stringsForInt := make(map[int][]string, len(intForString))
      for key, value := range intForString {
          stringsForInt[value] = append(stringsForInt[value], key)
      }
      return stringsForInt
  }
```

上面的函数首先创建一个空的映射，用来保存反转的结果，但是我们并不知道它到底要保存多少个项，因此我们假设它和原来的映射容量一样大，然后简单地遍历原来的映射，将它的值作为键保存到反转的映射里，并将键增加到对应的值里去，新的映射的值就是一个字符串切片，即使原来的映射有多个键对应同一个值，也不会丢掉任何数据。

```go
  func reportByFrequency(wordsForFrequency map[int][]string) {
      frequencies := make([]int, 0, len(wordsForFrequency))
      for frequency := range wordsForFrequency {
          frequencies = append(frequencies, frequency)
      }
      sort.Ints(frequencies)
      width := len(fmt.Sprint(frequencies[len(frequencies)-1]))
      fmt.Println("Frequency → Words")
      for _, frequency := range frequencies {
          words := wordsForFrequency[frequency]
          sort.Strings(words)
          fmt.Printf("%*d %s\n", width, frequency, strings.Join(words, ", "))
      }
  }
```

这个函数的结构和 reportByWords() 函数很相似，它首先创建一个切片用来保存频率，并按照频率升序排列，然后再计算需要容纳的最大长度并以此作为第一列的宽度，之后输出报告的标题，最后，遍历输出所有的频率并按照字母升序输出对应的单词，如果一个频率有超过两个对应的单词则单词之间使用逗号分隔开。

### 11. 缩进排序

本节将通过实例为大家演示如何将字符串按照等级（缩进级别）进行排序，完整代码如下所示。

```go
  package main

  import (
      "fmt"
      "sort"
      "strings"
  )

  var original = []string{
      "Nonmetals",
      "    Hydrogen",
      "    Carbon",
      "    Nitrogen",
      "    Oxygen",
      "Inner Transitionals",
      "    Lanthanides",
      "        Europium",
      "        Cerium",
      "    Actinides",
      "        Uranium",
      "        Plutonium",
      "        Curium",
      "Alkali Metals",
      "    Lithium",
      "    Sodium",
      "    Potassium",
  }

  func main() {
      fmt.Println("|     Original      |       Sorted      |")
      fmt.Println("|-------------------|-------------------|")
      sorted := SortedIndentedStrings(original) // 最初是 \[\]string
      for i := range original {                 // 在全局变量中设置
          fmt.Printf("|%-19s|%-19s|\n", original[i], sorted[i])
      }
  }

  func SortedIndentedStrings(slice []string) []string {
      entries := populateEntries(slice)
      return sortedEntries(entries)
  }

  func populateEntries(slice []string) Entries {
      indent, indentSize := computeIndent(slice)
      entries := make(Entries, 0)
      for _, item := range slice {
          i, level := 0, 0
          for strings.HasPrefix(item[i:], indent) {
              i += indentSize
              level++
          }
          key := strings.ToLower(strings.TrimSpace(item))
          addEntry(level, key, item, &entries)
      }
      return entries
  }

  func computeIndent(slice []string) (string, int) {
      for _, item := range slice {
          if len(item) > 0 && (item[0] == ' ' || item[0] == '\t') {
              whitespace := rune(item[0])
              for i, char := range item[1:] {
                  if char != whitespace {
                      i++
                      return strings.Repeat(string(whitespace), i), i
                  }
              }
          }
      }
      return "", 0
  }

  func addEntry(level int, key, value string, entries *Entries) {
      if level == 0 {
          *entries = append(*entries, Entry{key, value, make(Entries, 0)})
      } else {
          addEntry(level-1, key, value,
              &((*entries)[entries.Len()-1].children))
      }
  }

  func sortedEntries(entries Entries) []string {
      var indentedSlice []string
      sort.Sort(entries)
      for _, entry := range entries {
          populateIndentedStrings(entry, &indentedSlice)
      }
      return indentedSlice
  }

  func populateIndentedStrings(entry Entry, indentedSlice *[]string) {
      *indentedSlice = append(*indentedSlice, entry.value)
      sort.Sort(entry.children)
      for _, child := range entry.children {
          populateIndentedStrings(child, indentedSlice)
      }
  }

  type Entry struct {
      key      string
      value    string
      children Entries
  }
  type Entries []Entry

  func (entries Entries) Len() int { return len(entries) }

  func (entries Entries) Less(i, j int) bool {
      return entries[i].key < entries[j].key
  }
  func (entries Entries) Swap(i, j int) {
      entries[i], entries[j] = entries[j], entries[i]
  }
```

注意 SortedIndentedStrings() 函数有一个很重要的前提就是，字符串的缩进是通过读到的空格或缩进的个数来决定的，下面来看一下输出结果，为了方便对比，这里将排序前的结果放在左边，排序后的结果放在右边。

```go
|     Original      |       Sorted      |
|-------------------|-------------------|
|Nonmetals          |Alkali Metals      |
|    Hydrogen       |    Lithium        |
|    Carbon         |    Potassium      |
|    Nitrogen       |    Sodium         |
|    Oxygen         |Inner Transitionals|
|Inner Transitionals|    Actinides      |
|    Lanthanides    |        Curium     |
|        Europium   |        Plutonium  |
|        Cerium     |        Uranium    |
|    Actinides      |    Lanthanides    |
|        Uranium    |        Cerium     |
|        Plutonium  |        Europium   |
|        Curium     |Nonmetals          |
|Alkali Metals      |    Carbon         |
|    Lithium        |    Hydrogen       |
|    Sodium         |    Nitrogen       |
|    Potassium      |    Oxygen         |
```

其中，SortedIndentedStrings() 函数和它的辅助函数使用到了递归、函数引用以及指向切片的指针等。

```go
  type Entry struct {
      key      string
      value    string
      children Entries
  }
  type Entries []Entry

  func (entries Entries) Len() int { return len(entries) }

  func (entries Entries) Less(i, j int) bool {
      return entries[i].key < entries[j].key
  }
  func (entries Entries) Swap(i, j int) {
      entries[i], entries[j] = entries[j], entries[i]
  }
```

sort.Interface 接口定义了 3 个方法 Len()、Less() 和 Swap()，它们的函数签名和 Entries 中的同名方法是一样的，这就意味着我们可以使用标准库里的 sort.Sort() 函数来对一个 Entries 进行排序。

```go
  func SortedIndentedStrings(slice []string) []string {
      entries := populateEntries(slice)
      return sortedEntries(entries)
  }
```

导出的函数 SortedIndentedStrings() 就做了这个工作，虽然我们已经对它进行了重构，让它把所有东西都传递给辅助函数，函数 populateEntries() 传入一个 []string 并返回一个对应的 Entries（[]Entry 类型）。

而函数 sortedEntries() 需要传入一个 Entries，然后返回一个排过序的 []string（根据缩进的级别进行排序）。

```go
  func populateEntries(slice []string) Entries {
      indent, indentSize := computeIndent(slice)
      entries := make(Entries, 0)
      for _, item := range slice {
          i, level := 0, 0
          for strings.HasPrefix(item[i:], indent) {
              i += indentSize
              level++
          }
          key := strings.ToLower(strings.TrimSpace(item))
          addEntry(level, key, item, &entries)
      }
      return entries
  }
```

populateEntries() 函数首先以字符串的形式得到给定切片里的一级缩进（如有 4 个空格的字符串）和它占用的字节数，然后创建一个空的 Entries，并遍历切片里的每一个字符串，判断该字符串的缩进级别，再创建一个用于排序的键。

下一步，调用自定义函数 addEntry()，将当前字符串的级别、键、字符串本身，以及指向 entries 的地址作为参数，这样 addEntry() 就能创建一个新的 Entry 并能够正确地将它追加到 entries 里去，最后返回 entries。

```go
  func computeIndent(slice []string) (string, int) {
      for _, item := range slice {
          if len(item) > 0 && (item[0] == ' ' || item[0] == '\t') {
              whitespace := rune(item[0])
              for i, char := range item[1:] {
                  if char != whitespace {
                      i++
                      return strings.Repeat(string(whitespace), i), i
                  }
              }
          }
      }
      return "", 0
  }
```

computeIndent() 函数主要是用来判断缩进使用的是什么字符，例如空格或者缩进符等，以及一个缩进级别占用多少个这样的字符。

因为第一级的字符串可能没有缩进，所以函数必须迭代所有的字符串，一旦它发现某个字符串的行首是空格或者缩进，函数马上返回表示缩进的字符以及一个缩进所占用的字符数。

```go
  func addEntry(level int, key, value string, entries *Entries) {
      if level == 0 {
          *entries = append(*entries, Entry{key, value, make(Entries, 0)})
      } else {
          addEntry(level-1, key, value,
              &((*entries)[entries.Len()-1].children))
      }
  }
```

addEntry() 是一个递归函数，它创建一个新的 Entry，如果这个 Entry 的 level 是 0，那就直接增加到 entries 里去，否则，就将它作为另一个 Entry 的子集。

我们必须确定这个函数传入的是一个 *Entries 而不是传递一个 entries 引用（切片的默认行为），因为我们是要将数据追加到 entries 里，追加到一个引用会导致无用的本地副本且原来的数据实际上并没有被修改。

如果 level 是 0，表明这个字符串是顶级项，因此必须将它直接追加到 *entries，实际上情况要更复杂一些，因为 level 是相对传入的 *entries 而言的，第一次调用 addEntry() 时，*entries 是一个第一级的 Entries，但函数进入递归后，*entries 就可能是某个 Entry 的子集。

我们使用内置的 append() 函数来追加新的 Entry，并使用 * 操作符获得 entries 指针指向的值，这就保证了任何改变对调用者来说都是可见的，新增的 Entry 包含给定的 key 和 value，以及一个空的子 Entries，这是递归的结束条件。

如果 level 大于 0，则我们必须将它追加到上一级 Entry 的 children 字段里去，这里我们只是简单地递归调用 addEntry() 函数，最后一个参数可能是我们目前为止见到的最复杂的表达式了。

子表达式 entries.Len() - 1 产生一个 int 型整数，表示 *entries 指向的 Entries 值的最后一个条目的索引位置（注意 Entries.Len() 传入的是一个 Entries 值而不是 *Entries 指针，不过 Go 语言也可以自动对 entries 指针进行解引用并调用相应的方法）。

完整的表达式（&(…) 除外）访问了 Entries 最后一个 Entry 的 children 字段（这也是一个 Entries 类型），所以如果把这个表达式作为一个整体，实际上我们是将 Entries 里最后一个 Entry 的 children 字段的内存地址作为递归调用的参数，因为 addEntry() 最后一个参数是 *Entries 类型的。

为了帮助大家弄清楚到底发生了什么，下面的代码和上述代码中 else 代码块中的那个调用是一样的。

theEntries := *entries lastEntry := &theEntries[theEntries.Len()-1] addEntry(level-1, key, value, &lastEntry.children)

首先，我们创建 theEntries 变量用来保存 *entries 指针指向的值，这里没有什么开销因为不会产生复制，实际上 theEntries 相当于一个指向 Entries 值的别名。

然后我们取得最后一项的内存地址（即一个指针），如果不取地址的话就会取到最后一项的副本，最后递归调用 addEntry() 函数，并将最后一项的 children 字段的地址作为参数传递给它。

```go
  func sortedEntries(entries Entries) []string {
      var indentedSlice []string
      sort.Sort(entries)
      for _, entry := range entries {
          populateIndentedStrings(entry, &indentedSlice)
      }
      return indentedSlice
  }
```

当调用 sortedEntries() 函数的时候，Entries 显示的结构和原先程序输出的字符串是一样的，每一个缩进的字符串都是上一级缩进的子级，而且还可能有下一级的缩进，依次类推。

创建了 Entries 之后，SortedIndentedStrings() 函数调用上面这个函数去生成一个排好序的字符串切片 []string，这个函数首先创建一个空的 []string 用来保存最后的结果，然后对 entries 进行排序。

Entries 实现了 sort.Interface 接口，因此我们可以直接使用 sort.Sort() 函数根据 Entry 的 key 字段来对 Entries 进行排序（这是 Entries.Less() 的实现方式），这个排序只是作用于第一级的 Entry，对其他未排序的子集是没有任何影响的。

为了能够对 children 字段以及 children 的 children 等进行递归排序，函数遍历第一级的每一个项并调用 populateIndentedStrings() 函数，传入这个 Entry 类型的项和一个指向 []string 切片的指针。

切片可以传递给函数并由函数更新内容（如替换切片里的某些项），但是这里需要往切片里新增一些数据，所以这里将一个指向切片的指针（也就是指针的指针）作为参数传进去，并将指针指向的内容设置为 append() 函数的返回结果，可能是一个新的切片，也可能是原先的切片。

另一种办法就是传入切片的值，然后返回 append() 之后的切片，但是必须将返回的结果赋值给原来的切片变量（例如 slice = function(slice)），不过这么做的话，很难正确地使用递归函数。

```go
  func populateIndentedStrings(entry Entry, indentedSlice *[]string) {
      *indentedSlice = append(*indentedSlice, entry.value)
      sort.Sort(entry.children)
      for _, child := range entry.children {
          populateIndentedStrings(child, indentedSlice)
      }
  }
```

populateIndentedStrings() 函数将顶级项追加到创建的切片，然后对顶级项的子项进行排序，并递归调用自身对每一个子项做同样的处理，这就相当于对每一项的子项以及子项的子项等都做了排序，所以整个字符串切片就是已经排好序的了。

### 12. 二分查找

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找算法的前提是传入的序列是有序的（降序或升序），并且有一个目标值。

二分查找的核心思想是将 n 个元素分成大致相等的两部分，取中间值 a[n/2] 与 x 做比较，如果 x=a[n/2]，则找到 x，算法中止，如果 x<a[n/2]，则只要在数组 a 的左半部分继续搜索 x，如果 x>a[n/2]，则只要在数组 a 的右半部搜索 x。

二分查找虽然性能比较优秀，但应用场景也比较有限，底层必须依赖数组，并且还要求数据是有序的，对于较小规模的数据查找，我们直接使用顺序遍历就可以了，二分查找的优势并不明显，二分查找更适合处理静态数据，也就是没有频繁插入、删除操作的数据。

#### 思路：

1. 先找到中间的下标 middle = (leftIndex + RightIndex) /2 ，然后用中间的下标值和需要查找的值（ FindVal）比较。

a：如果 arr[middle] > FindVal，那么就向 LeftIndex ~ (midlle-1) 区间找 b：如果 arr[middle] < FindVal，那么就向 middle+1 ~ RightIndex 区间找 c：如果 arr[middle] == FindVal，那么直接返回

1. 从第一步的 a、b、c 递归执行，直到找到位置。

1. 如果 LeftIndex > RightIndex，则表示找不到，退出。

#### 代码 / 举例：

定义一个包含（1, 2, 5, 7, 15, 25, 30, 36, 39, 51, 67, 78, 80, 82, 85, 91, 92, 97）等值的数组，假设说要查找 30 这个值，如果按照循环的查找方法，找到 30 这个值要执行 7 次，那么如果是按照二分查找呢？二分查找的过程如下：

left = 1, right = 18; mid = (1+18)/2 = 9; 51 > 30 left = 1, right = mid - 1 = 8; mid = (1+8)/2 = 4; 15 < 30 left = mid + 1 = 5, right = 8; mid = (5+8)/2 = 6; 30 = 30 查找完毕

如上所示只需要执行 3 次，大大减少了执行时间，具体代码实现如下所示：

```go
  package main

  import (
      "fmt"
  )
  //二分查找函数 //假设有序数组的顺序是从小到大（很关键，决定左右方向）
  func BinaryFind(arr *[]int, leftIndex int, rightIndex int, findVal int)  {
      //判断 leftIndex是否大于rightIndex
      if leftIndex > rightIndex {
          fmt.Println("找不到")
          return
      }
      //先找到 中间的下标
      middle := (leftIndex + rightIndex) / 2

      if (*arr)[middle] > findVal {
          //要查找的数，范围应该在 leftIndex 到 middle+1
          BinaryFind(arr, leftIndex, middle-1, findVal)
      } else if (*arr)[middle] < findVal {
          //要查找的数，范围应该在 middle+1 到 rightIndex
          BinaryFind(arr, middle+1, rightIndex, findVal)
      } else {
          fmt.Printf("找到了，下标为：%v \n", middle)
      }
  }

  func main() {
      //定义一个数组
      arr := []int{1, 2, 5, 7, 15, 25, 30, 36, 39, 51, 67, 78, 80, 82, 85, 91, 92, 97}
      BinaryFind(&arr, 0, len(arr) - 1, 30)
      fmt.Println("main arr=",arr)
  }
```

执行结果如下所示：

D:\code>go run main.go 找到了，下标为：6 main arr= [1 2 5 7 15 25 30 36 39 51 67 78 80 82 85 91 92 97]

### 13. 冒泡排序

冒泡排序法是一种最简单的交换类排序方法，它是通过相邻数据的交换逐步将无序列表排列为有序列表。

冒泡排序的基本原理是重复地循环遍历要排序的元素列，依次比较两个相邻的元素，如果顺序（如从小到大或者首字母从 Z 到 A）错误就把两个元素的位置交换过来，直到没有相邻元素需要交换，也就是说该元素列已经排序完成。

冒泡排序的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端（升序或降序排列），就如同气泡最终会上浮到顶端一样，故名“冒泡排序”。

下面通过一个实例来演示一下冒泡排序，完整代码如下：

```go
  package main

  import (
     "fmt"
  )

  //冒泡排序
  func main() {
      arr := [...]int{21,32,12,33,34,34,87,24}
      var n = len(arr)
      fmt.Println("--------没排序前--------\n",arr)
      for i := 0; i <= n-1; i++ {
          fmt.Println("--------第",i+1,"次冒泡--------")
          for j := i; j <= n-1; j++ {
              if arr[i] > arr[j] {
                  t := arr[i]
                  arr[i] = arr[j]
                  arr[j] = t
              }
              fmt.Println(arr)

          }
      }
      fmt.Println("--------最终结果--------\\n",arr)
  }
```

执行结果如下所示：

```go
执行结果如下所示：

D:\code>go run main.go
——– 没排序前 ——–
[21 32 12 33 34 34 87 24]
——– 第 1 次冒泡 ——–
[21 32 12 33 34 34 87 24]
[21 32 12 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
[12 32 21 33 34 34 87 24]
——– 第 2 次冒泡 ——–
[12 32 21 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
——– 第 3 次冒泡 ——–
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 32 33 34 34 87 24]
[12 21 24 33 34 34 87 32]
——– 第 4 次冒泡 ——–
[12 21 24 33 34 34 87 32]
[12 21 24 33 34 34 87 32]
[12 21 24 33 34 34 87 32]
[12 21 24 33 34 34 87 32]
[12 21 24 32 34 34 87 33]
——– 第 5 次冒泡 ——–
[12 21 24 32 34 34 87 33]
[12 21 24 32 34 34 87 33]
[12 21 24 32 34 34 87 33]
[12 21 24 32 33 34 87 34]
——– 第 6 次冒泡 ——–
[12 21 24 32 33 34 87 34]
[12 21 24 32 33 34 87 34]
[12 21 24 32 33 34 87 34]
——– 第 7 次冒泡 ——–
[12 21 24 32 33 34 87 34]
[12 21 24 32 33 34 34 87]
——– 第 8 次冒泡 ——–
[12 21 24 32 33 34 34 87]
——– 最终结果 ——–
[12 21 24 32 33 34 34 87]
```

### 14.  分布式ID生成器

有时我们需要能够⽣成类似 MySQL 自增 ID 这样不断增大，同时又不会重复的 ID。以支持业务中的⾼并发场景。比较典型的是电商促销时短时间内会有大量的订单涌入到系统，比如每秒 10w+。明星出轨时会有大量热情的粉丝发微博以表心意，同样会在短时间内产生大量的消息。

在插入数据库之前，我们需要给这些消息、订单先打上一个 ID，然后再插⼊到我们的数据库。对这个 ID 的要求是希望其中能带有一些时间信息，这样即使我们后端的系统对消息进行了分库分表，也能够以时间顺序对这些消息进⾏排序。

Twitter 的 snowflake 算法是这种场景下的一个典型解法。先来看看 snowflake 是怎么回事，如下图所示：

[![img](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3110KJ.gif)](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3110KJ.gif)

图：snowflake 中的比特位分布

⾸先确定我们的数值是 64 位的 int64 类型，被划分为了四部分，不含开头的第一个 bit，因为这个 bit 是符号位。用 41 位来表示收到请求时的时间戳，单位为毫秒，然后五位来表示数据中心的 ID，然后再五位来表示机器的实例 ID，最后是 12 位的循环自增 ID（到达 1111,1111,1111 后会归 0）。

这样的机制可以⽀持我们在同一台机器上，同一毫秒内产⽣ 2 ^ 12 = 4096 条消息。一秒共 409.6 万条消息。从值域上来讲完全够⽤了。

数据中心加上实例 ID 共有 10 位，可以⽀持我们每数据中心部署 32 台机器，所有数据中心共 1024 台实例。

表示 timestamp 的 41 位，可以⽀持我们使用 69 年。当然，我们的时间毫秒计数不会真的从 1970 年开始记，那样我们的系统跑到 2039/9/7 23:47:35 就不能用了，所以这里的 timestamp 实际上只是相对于某个时间的增量，比如我们的系统上线是 2018-08-01，那么我们可以把这个 timestamp 当作是从 2018-08-01 00:00:00.000 的偏移量。

#### worker_id 分配

timestamp、datacenter_id、worker_id 和 sequence_id 这四个字段中，timestamp 和 sequence_id 是由程序在运⾏期⽣成的。但 datacenter_id 和 worker_id 需要我们在部署阶段就能够获取得到，并且一旦程序启动之后，就是不可更改的了（想想，如果可以随意更改，可能被不慎修改，造成最终生成的 ID 有冲突）。

一般不同数据中⼼的机器，会提供对应的获取数据中心 ID 的 API，所以 datacenter_id 我们可以在部署阶段轻松地获取到。而 worker_id 是我们逻辑上给机器分配的一个 ID，这个要怎么办呢？比较简单的想法是由能够提供这种自增 ID 功能的工具来支持，比如 MySQL:

mysql> insert into a (ip) values(“10.1.2.101”); Query OK, 1 row affected (0.00 sec) mysql> select last_insert_id(); +——————+ | last_insert_id()   | +——————+ | 2             | +——————+ 1 row in set (0.00 sec)

从 MySQL 中获取到 worker_id 之后，就把这个 worker_id 直接持久化到本地，以避免每次上线时都需要获取新的 worker_id，让单实例的 worker_id 可以始终保持不变。

当然，使用 MySQL 相当于给我们简单的 id 生成服务增加了一个外部依赖，依赖越多，我们的服务的可运维性就越差。

考虑到集群中即使有单个 ID 生成服务的实例挂了，也就是损失一段时间的一部分 ID，所以我们也可以更简单暴力一些，把 worker_id 直接写在 worker 的配置中，上线时由部署脚本完成 worker_id 字段替换。

#### 标准 snowflake 实现

github.com/bwmarrin/snowflake 是一个相当轻量化的 snowflake 的 Go 实现。其文档对各位使用的定义如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3115T20.gif)](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3115T20.gif)

图：snowflake 库

和标准的 snowflake 完全一致。使用上比较简单：

```go
  package main

  import (
      "fmt"
      "os"
      "github.com/bwmarrin/snowflake"
  )

  func main() {
      n, err := snowflake.NewNode(1)
      if err != nil {
          println(err)
          os.Exit(1)
      }
      for i := 0; i < 3; i++ {
          id := n.Generate()
          fmt.Println("id", id)
          fmt.Println(
              "node: ", id.Node(),
              "step: ", id.Step(),
              "time: ", id.Time(),
              "\n",
          )
      }
  }
```

运行结果如下：

go run main.go id 1218796327232606208 node: 1 step: 0 time: 1579418663210

id 1218796327232606209 node: 1 step: 1 time: 1579418663210

id 1218796327232606210 node: 1 step: 2 time: 1579418663210

当然，这个库也给我们留好了定制的后路，其中预留了一些可定制字段：

// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC // You may customize this to set a different epoch for your application. Epoch int64 = 1288834974657

// Number of bits to use for Node // Remember, you have a total 22 bits to share between Node/Step NodeBits uint8 = 10

// Number of bits to use for Step // Remember, you have a total 22 bits to share between Node/Step StepBits uint8 = 12

Epoch 就是本节开头讲的起始时间，NodeBits 指的是机器编号的位⻓，StepBits 指的是自增序列的位⻓。

#### sonyflake

sonyflake 是 Sony 公司的一个开源项目，基本思路和 snowflake 差不多，不过位分配上稍有不同，如下图所示：

[![img](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3124IN.gif)](http://c.biancheng.net/uploads/allimg/190828/4-1ZRQ3124IN.gif)

图：sonyflake

这⾥的时间只用了 39 个 bit，但时间的单位变成了 10ms，所以理论上比 41 位表示的时间还要久（174 年）。

Sequence ID 和之前的定义一致，Machine ID 其实就是节点 ID。sonyflake 与众不同的地方在于其在启动阶段的参数配置：

func NewSonyflake(st Settings) *Sonyflake

Settings 数据结构如下：

type Settings struct {   StartTime time.Time   MachineID func() (uint16, error)   CheckMachineID func(uint16) bool }

StartTime 选项和我们之前的 Epoch 差不多，如果不设置的话，默认是从 2014-09-01 00:00:00 +0000 UTC 开始。

MachineID 可以由用户自定义的函数，如果用户不定义的话，会默认将本机 IP 的低 16 位作为 machineid。

CheckMachineID 是由用户提供的检查 MachineID 是否冲突的函数。这里的设计还是比较巧秒的，如果有另外的中心化存储并支持检查重复的存储，那我们就可以按照自己的想法随意定制这个检查 MachineID 是否冲突的逻辑。如果公司有现成的 Redis 集群，那么我们可以很轻松地用 Redis 的集合类型来检查冲突。

redis 127.0.0.1:6379> SADD base64_encoding_of_last16bits MzI0Mgo= (integer) 1 redis 127.0.0.1:6379> SADD base64_encoding_of_last16bits MzI0Mgo= (integer) 0

使用起来也比较简单，这里省略了一些逻辑简单的函数：

```go
  package main

  import (
      "fmt"
      "os"
      "time"
      "github.com/sony/sonyflake"
  )

  func getMachineID() (uint16, error) {
      var machineID uint16
      var err error
      machineID = readMachineIDFromLocalFile()
      if machineID == 0 {
          machineID, err = generateMachineID()
          if err != nil {
              return 0, err
          }
      }
      return machineID, nil
  }
  func checkMachineID(machineID uint16) bool {
      saddResult, err := saddMachineIDToRedisSet()
      if err != nil || saddResult == 0 {
          return true
      }
      err := saveMachineIDToLocalFile(machineID)
      if err != nil {
          return true
      }
      return false
  }
  func main() {
      t, _ := time.Parse("2006-01-02", "2018-01-01")
      settings := sonyflake.Settings{
          StartTime: t,
          MachineID: getMachineID,
          CheckMachineID: checkMachineID,
      }
      sf := sonyflake.NewSonyflake(settings)
      id, err := sf.NextID()
      if err != nil {
      fmt.Println(err)
          os.Exit(1)
      }
      fmt.Println(id)
  }
```



## 第五章 函数

### 1. 函数定义

函数构成了代码执行的逻辑结构，在Go语言中，函数的基本组成为：关键字 func、函数名、参数列表、返回值、函数体和返回语句，每一个程序都包含很多的函数，函数是基本的代码块。

因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的，鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。

编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务来解决，而且，同一个任务（函数）可以被多次调用，有助于代码重用（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don't Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次）。

当函数执行到代码块最后一行`}`之前或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数，这些参数将作为返回值供调用者使用，简单的 return 语句也可以用来结束 for 的死循环，或者结束一个协程（goroutine）。

Go语言里面拥三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者 lambda 函数
- 方法

#### 普通函数声明（定义）

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。

```go
func 函数名(形式参数列表)(返回值列表){
  函数体
}
```

形式参数列表描述了函数的参数名以及参数类型，这些参数作为局部变量，其值由参数调用者提供，返回值列表描述了函数返回值的变量名以及类型，如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值，在下面的 hypot 函数中：

```go
func hypot(x, y float64) float64 {
    return math.Sqrt(x*x + y*y)
}
fmt.Println(hypot(3,4)) // "5"
```

x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值，返回值也可以像形式参数一样被命名，在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。

如果一个函数在声明时，包含返回值列表，那么该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处，例如函数在结尾时调用了 panic 异常或函数中存在无限循环。

正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型，下面 2 个声明是等价的：

```go
func f(i, j, k int, s, t string) { /* ... */ }
func f(i int, j int, k int, s string, t string) { /* ... */ }
```

下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符`_`可以强调某个参数未被使用。

```go
func add(x int, y int) int {return x + y}
func sub(x, y int) (z int) { z = x - y; return}
func first(x int, _ int) int { return x }
func zero(int, int) int { return 0 }
fmt.Printf("%T\n", add) // "func(int, int) int"
fmt.Printf("%T\n", sub) // "func(int, int) int"
fmt.Printf("%T\n", first) // "func(int, int) int"
fmt.Printf("%T\n", zero) // "func(int, int) int"
```

函数的类型被称为函数的标识符，如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符，形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。

每一次函数在调用时都必须按照声明顺序为所有参数提供实参（参数值），在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

在函数中，实参通过值传递的方式进行传递，因此函数的形参是实参的拷贝，对形参进行修改不会影响实参，但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel 等类型，实参可能会由于函数的间接引用被修改。

#### 函数的返回值

Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误，示例代码如下：

```go
conn, err := connectToNetwork()
```

在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误信息。

##### 其它编程语言中函数的返回值

- C/[C++](http://c.biancheng.net/cplus/) 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果，C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。
- [C#](http://c.biancheng.net/csharp/) 语言也没有多返回值特性，C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。
- lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。


Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。

##### 1) 同一种类型返回值

如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。

使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致，示例代码如下：

```go
func typedTwoValues() (int, int) {
    return 1, 2
}
func main() {
    a, b := typedTwoValues()
    fmt.Println(a, b)
}
```

代码输出结果：

```go
1 2
```

纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。

##### 2) 带有变量名的返回值

Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。

命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。

下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值，在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：

```go
func namedRetValues() (a, b int) {
    a = 1
    b = 2
    return
}
```

代码说明如下：

- 第 1 行，对两个整型返回值进行命名，分别为 a 和 b。

- 第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。

- 第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的，下面代码的执行效果和上面代码的效果一样。

  ```go
  func namedRetValues() (a, b int) {
      a = 1
      return a, 2
  }
  ```

##### 提示

同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：

```go
func namedRetValues() (a, b int, int)
```

编译报错提示：

```go
mixed named and unnamed function parameters
```

意思是：在函数参数中混合使用了命名和非命名参数。

#### 调用函数

函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行，调用前的函数局部变量都会被保存起来不会丢失，被调用的函数运行结束后，恢复到调用函数的下一行继续执行代码，之前的局部变量也能继续访问。

函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。

Go语言的函数调用格式如下：

返回值变量列表 = 函数名(参数列表)

下面是对各个部分的说明：

- 函数名：需要调用的函数名。
- 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。
- 返回值变量列表：多个返回值使用逗号分隔。


例如，加法函数调用样式如下：

```go
result := add(1,1)
```

### 2. 将秒转换为具体的时间

在本例中，使用一个数值表示时间中的 “秒” 值，然后使用 resolveTime() 函数将传入的秒数转换为天、小时和分钟等时间单位。

【示例】将秒解析为时间单位：

```go
  package main

  import "fmt"

  const (
      // 定义每分钟的秒数
      SecondsPerMinute = 60

      // 定义每小时的秒数
      SecondsPerHour = SecondsPerMinute * 60

      // 定义每天的秒数
      SecondsPerDay = SecondsPerHour * 24
  )

  // 将传入的“秒”解析为3种时间单位
  func resolveTime(seconds int) (day int, hour int, minute int) {

      day = seconds / SecondsPerDay
      hour = seconds / SecondsPerHour
      minute = seconds / SecondsPerMinute

      return
  }

  func main() {

      // 将返回值作为打印参数
      fmt.Println(resolveTime(1000))

      // 只获取消息和分钟
      _, hour, minute := resolveTime(18000)
      fmt.Println(hour, minute)

      // 只获取天
      day, _, _ := resolveTime(90000)
      fmt.Println(day)
  }
```

代码输出结果：

```go
0 0 16 5 300 1
```

代码说明如下：

- 第 7 行，定义每分钟的秒数。

- 第 10 行，定义每小时的秒数，SecondsPerHour 常量值会在编译期间计算出结果。

- 第 13 行，定义每天的秒数。

- 第 17 行，定义 resolveTime() 函数，根据输入的秒数，返回 3 个整型值，含义分别是秒数对应的天数、小时数和分钟数（取整）。

- 第 29 行中，给定 1000 秒，对应是 16（16.6667 取整）分钟的秒数，resolveTime() 函数返回的 3 个变量会传递给 fmt.Println() 函数进行打印，因为 fmt.Println() 使用了可变参数，可以接收不定量的参数。

- 第 32 行，将 resolveTime() 函数中的 3 个返回值使用变量接收，但是第一个返回参数使用匿名函数接收，表示忽略这个变量。

- 第 36 行，忽略后两个返回值，只使用第一个返回值。

### 3. 函数中参数传递效果测试

Go 语言中传入与返回参数在调用和返回时都使用值传递，这里需要注意的是指针、切片和 map 等引用型对象在参数传递中不会发生复制，而是将指针进行复制，类似于创建一次引用。

下面通过一个例子来详细了解 Go 语言的参数值传递，完整的示例代码如下所示：

```go
  package main

  import "fmt"

  // 用于测试值传递效果的结构体
  type Data struct {
      complax []int // 测试切片在参数传递中的效果

      instance InnerData // 实例分配的innerData

      ptr *InnerData // 将ptr声明为InnerData的指针类型
  }

  // 代表各种结构体字段
  type InnerData struct {
      a int
  }

  // 值传递测试函数
  func passByValue(inFunc Data) Data {

      // 输出参数的成员情况
      fmt.Printf("inFunc value: %+v\n", inFunc)

      // 打印inFunc的指针
      fmt.Printf("inFunc ptr: %p\n", &inFunc)

      return inFunc
  }

  func main() {

      // 准备传入函数的结构
      in := Data{
          complax: []int{1, 2, 3},
          instance: InnerData{
                5,
          },

          ptr: &InnerData{1},
      }

      // 输入结构的成员情况
      fmt.Printf("in value: %+v\n", in)

      // 输入结构的指针地址
      fmt.Printf("in ptr: %p\n", &in)

      // 传入结构体，返回同类型的结构体
      out := passByValue(in)

      // 输出结构的成员情况
      fmt.Printf("out value: %+v\n", out)

      // 输出结构的指针地址
      fmt.Printf("out ptr: %p\n", &out)
  }
```

#### 1) 测试数据类型

为了测试结构体、切片、指针及结构体中嵌套的结构体在值传递中会发生的情况，需要定义一些结构，代码如下：

```go
  // 用于测试值传递效果的结构体
  type Data struct {
      complax []int    // 测试切片在参数传递中的效果

      instance InnerData    // 实例分配的innerData

      ptr *InnerData    // 将ptr声明为InnerData的指针类型
  }

  // 代表各种结构体字段
  type InnerData struct {
      a int
  }
```

代码说明如下：

- 第 2 行，将 Data 声明为结构体类型，结构体是拥有多个字段的复杂结构。

- 第 3 行，complax 为整型切片类型，切片是一种动态类型，内部以指针存在。

- 第 5 行，instance 成员以 InnerData 类型作为 Data 的成员。

- 第 7 行，将 ptr 声明为 InnerData 的指针类型。

- 第 11 行，声明一个内嵌的结构 InnerData。

#### 2) 值传递的测试函数

示例代码中定义的 passByValue() 函数用于值传递的测试，该函数的参数和返回值都是 Data 类型，在调用过程中，Data 的内存会被复制后传入函数，当函数返回时，又会将返回值复制一次，赋给函数返回值的接收变量，代码如下：

```go
  // 值传递测试函数
  func passByValue(inFunc Data) Data {

      // 输出参数的成员情况
      fmt.Printf("inFunc value: %+v\n", inFunc)

      // 打印inFunc的指针
      fmt.Printf("inFunc ptr: %p\n", &inFunc)

      return inFunc
  }
```

代码说明如下：

- 第 5 行，使用格式化的`%+v`动词输出 inFunc 变量的详细结构，以便观察 Data 结构在传递前后内部数值的变化情况。

- 第 8 行，打印传入参数 inFunc 的指针地址，在计算机中，拥有相同地址且类型相同的变量，表示的是同一块内存区域。

- 第 10 行，将传入的变量作为返回值返回，返回的过程将发生值复制。

#### 3) 测试流程

测试流程会准备一个 Data 格式的数据结构并填充所有成员，这些成员类型包括切片、结构体成员及指针，通过调用测试函数，传入 Data 结构数据，并获得返回值，对比输入和输出后的 Data 结构数值变化，特别是指针变化情况以及输入和输出整块数据是否被复制，代码如下：

```go
  // 准备传入函数的结构
  in := Data{
      complax: []int{1, 2, 3},
      instance: InnerData{
              5,
      },

      ptr: &InnerData{1},
  }

  // 输入结构的成员情况
  fmt.Printf("in value: %+v\n", in)

  // 输入结构的指针地址
  fmt.Printf("in ptr: %p\n", &in)

  // 传入结构体, 返回同类型的结构体
  out := passByValue(in)

  // 输出结构的成员情况
  fmt.Printf("out value: %+v\n", out)

  // 输出结构的指针地址
  fmt.Printf("out ptr: %p\n", &out)
```

代码说明如下：

- 第 2 行，创建一个 Data 结构的实例 in。

- 第 3 行，将切片数据赋值到 in 的 complax 成员。

- 第 4 行，为 in 的 instance 成员赋值 InnerData 结构的数据。

- 第 8 行，为 in 的 ptr 成员赋值 InnerData 的指针类型数据。

- 第 12 行，打印输入结构的成员情况。

- 第 15 行，打印输入结构的指针地址。

- 第 18 行，传入 in 结构，调用 passByvalue() 测试函数获得 out 返回，此时，passByValue() 函数会打印 in 传入后的数据成员情况。

- 第 21 行，打印返回值变量 out 的成员情况。

- 第 24 行，打印输出结构的地址。

运行代码，输出结果为：

```go
in value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
in ptr: 0xc042066060
inFunc value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
inFunc ptr: 0xc0420660f0
out value: {complax:[1 2 3] instance:{a:5} ptr:0xc042008100}
out ptr: 0xc0420660c0
```

从运行结果中发现：

- 所有的 Data 结构的指针地址都发生了变化，意味着所有的结构都是一块新的内存，无论是将 Data 结构传入函数内部，还是通过函数返回值传回 Data 都会发生复制行为。
- 所有的 Data 结构中的成员值都没有发生变化，原样传递，意味着所有参数都是值传递。
- Data 结构的 ptr 成员在传递过程中保持一致，表示指针在函数参数值传递中传递的只是指针值，不会复制指针指向的部分。

### 4. 函数变量（把函数作为值保存到变量中）

在Go语言中，函数也是一种类型，可以和其他类型一样保存在变量中，下面的代码定义了一个函数变量 f，并将一个函数名为 fire() 的函数赋给函数变量 f，这样调用函数变量 f 时，实际调用的就是 fire() 函数，代码如下：

```go
package main
import (
    "fmt"
)
func fire() {
    fmt.Println("fire")
}
func main() {
    var f func()
    f = fire
    f()
}
```

代码输出结果：

```go
fire
```

代码说明：

- 第 7 行，定义了一个 fire() 函数。
- 第 13 行，将变量 f 声明为 func() 类型，此时 f 就被俗称为“回调函数”，此时 f 的值为 nil。
- 第 15 行，将 fire() 函数作为值，赋给函数变量 f，此时 f 的值为 fire() 函数。
- 第 17 行，使用函数变量 f 进行函数调用，实际调用的是 fire() 函数。

### 5. 字符串的链式处理

使用 SQL 语言从数据库中获取数据时，可以对原始数据进行排序（sort by）、分组（group by）和去重（distinct）等操作，SQL 将数据的操作与遍历过程作为两个部分进行隔离，这样操作和遍历过程就可以各自独立地进行设计，这就是常见的数据与操作分离的设计。

对数据的操作进行多步骤的处理被称为链式处理，本例中使用多个字符串作为数据集合，然后对每个字符串进行一系列的处理，用户可以通过系统函数或者自定义函数对链式处理中的每个环节进行自定义。

首先给出本节完整代码：

```go
  package main

  import (
      "fmt"
      "strings"
  )

  // 字符串处理函数，传入字符串切片和处理链
  func StringProccess(list []string, chain []func(string) string) {

      // 遍历每一个字符串
      for index, str := range list {

          // 第一个需要处理的字符串
          result := str

          // 遍历每一个处理链
          for _, proc := range chain {

              // 输入一个字符串进行处理，返回数据作为下一个处理链的输入。
              result = proc(result)
          }

          // 将结果放回切片
          list[index] = result
      }
  }

  // 自定义的移除前缀的处理函数
  func removePrefix(str string) string {

      return strings.TrimPrefix(str, "go")
  }

  func main() {

      // 待处理的字符串列表
      list := []string{
          "go scanner",
          "go parser",
          "go compiler",
          "go printer",
          "go formater",
      }

      // 处理函数链
      chain := []func(string) string{
          removePrefix,
          strings.TrimSpace,
          strings.ToUpper,
      }

      // 处理字符串
      StringProccess(list, chain)

      // 输出处理好的字符串
      for _, str := range list {
          fmt.Println(str)
      }

  }
```

#### 1) 字符串处理函数

字符串处理函数（StringProccess）需要外部提供数据源，一个字符串切片（list[]string），另外还要提供一个链式处理函数的切片（chain[]func(string)string），链式处理切片中的一个处理函数的定义如下：

```go
func(string) string
```

这种处理函数能够接受一个字符串输入，处理后输出。

strings 包中将字符串变为小写就是一种处理函数的形式，strings.ToLower() 函数能够将传入的字符串的每一个字符变为小写，strings.ToLower 定义如下：

```go
func ToLower(s string) string
```

字符串处理函数（StringProccess）内部遍历每一个数据源提供的字符串，每个字符串都需要经过一系列链式处理函数处理后被重新放回切片，参见下面代码。

字符串的链式处理：

```go
  // 字符串处理函数, 传入字符串切片和处理链
  func StringProccess(list []string, chain []func(string) string) {

      // 遍历每一个字符串
      for index, str := range list {

          // 第一个需要处理的字符串
          result := str

          // 遍历每一个处理链
          for _, proc := range chain {

              // 输入一个字符串进行处理, 返回数据作为下一个处理链的输入
              result = proc(result)
          }

          // 将结果放回切片
          list[index] = result
      }
  }
```

代码说明如下：

- 第 2 行，传入字符串切片 list 作为数据源，一系列的处理函数作为 chain 处理链。

- 第 5 行，遍历字符串切片的每个字符串，依次对每个字符串进行处理。

- 第 8 行，将当前字符串保存到 result 变量中，作为第一个处理函数的参数。

- 第 11 行，遍历每一个处理函数，将字符串按顺序经过这些处理函数处理。

- 第 14 行，result 变量即是每个处理函数的输入变量，处理后的变量又会重新保存到 result 变量中。

- 第 18 行，将处理完的字符串保存回切片中。

#### 2) 自定义的处理函数

处理函数可以是系统提供的处理函数，如将字符串变大写或小写，也可以使用自定义函数，本例中的字符串处理的逻辑是使用一个自定义的函数实现移除指定 go 前缀的过程，参见下面代码：

```go
  // 自定义的移除前缀的处理函数
  func removePrefix(str string) string {
      return strings.TrimPrefix(str, "go")
  }
```

此函数使用了 strings.TrimPrefix() 函数实现移除字符串的指定前缀，处理后，移除前缀的字符串结果将通过 removePrefix() 函数的返回值返回。

#### 3) 字符串处理主流程

字符串处理的主流程包含以下几个步骤：

1. 准备要处理的字符串列表。

1. 准备字符串处理链。

1. 处理字符串列表。

1. 打印输出后的字符串列表。

详细流程参考下面的代码：

```go
  func main() {

      // 待处理的字符串列表
      list := []string{
          "go scanner",
          "go parser",
          "go compiler",
          "go printer",
          "go formater",
      }

      // 处理函数链
      chain := []func(string) string{
          removePrefix,
          strings.TrimSpace,
          strings.ToUpper,
      }

      // 处理字符串
      StringProccess(list, chain)

      // 输出处理好的字符串
      for _, str := range list {
          fmt.Println(str)
      }
  }
```

代码说明如下：

- 第 4 行，定义字符串切片，字符串包含 go 前缀及空格。

- 第 13 行，准备处理每个字符串的处理链，处理的顺序与函数在切片中的位置一致，removePrefix() 为自定义的函数，功能是移除 go 前缀，移除前缀的字符串左边有一个空格，使用 strings.TrimSpace 移除，这个函数的定义刚好符合处理函数的格式 func(string)string，strings.ToUpper 用于将字符串转为大写。

- 第 20 行，传入字符串切片和字符串处理链，通过 StringProcess() 函数对字符串进行处理。

- 第 23 行，遍历字符串切片的每一个字符串，打印处理好的字符串结果。

#### 提示

链式处理器是一种常见的编程设计，Netty 是使用 Java 语言编写的一款异步事件驱动的网络应用程序框架，支持快速开发可维护的高性能的面向协议的服务器和客户端，Netty 中就有类似的链式处理器的设计。

Netty 可以使用类似的处理链对封包进行收发编码及处理，Netty 的开发者可以分为 3 种：第一种是 Netty 底层开发者；第二种是每个处理环节的开发者；第三种是业务实现者。在实际开发环节中，后两种开发者往往是同一批开发者，链式处理的开发思想将数据和操作拆分、解耦，让开发者可以根据自己的技术优势和需求，进行系统开发，同时将自己的开发成果共享给其他的开发者。

### 6. 匿名函数

Go语言支持匿名函数，即在需要使用函数时再定义函数，匿名函数没有函数名只有函数体，函数可以作为一种类型被赋值给函数类型的变量，匿名函数也往往以变量方式传递，这与C语言的回调函数比较类似，不同的是，Go语言支持随时在代码里定义匿名函数。

匿名函数是指不需要定义函数名的一种函数实现方式，由一个不带函数名的函数声明和函数体组成，下面来具体介绍一下匿名函数的定义及使用。

#### 定义一个匿名函数

匿名函数的定义格式如下：

```go
func(参数列表)(返回参数列表){
  函数体
}
```

匿名函数的定义就是没有名字的普通函数定义。

##### 1) 在定义时调用匿名函数

匿名函数可以在声明后调用，例如：

```go
func(data int) {
    fmt.Println("hello", data)
}(100)
```

注意第3行`}`后的`(100)`，表示对匿名函数进行调用，传递参数为 100。

##### 2) 将匿名函数赋值给变量

匿名函数可以被赋值，例如：

```go
// 将匿名函数体保存到f()中
f := func(data int) {
    fmt.Println("hello", data)
}
// 使用f()调用
f(100)
```

匿名函数的用途非常广泛，它本身就是一种值，可以方便地保存在各种容器中实现回调函数和操作封装。

#### 匿名函数用作回调函数

下面的代码实现对切片的遍历操作，遍历中访问每个元素的操作使用匿名函数来实现，用户传入不同的匿名函数体可以实现对元素不同的遍历操作，代码如下：

```go
package main
import (
    "fmt"
)
// 遍历切片的每个元素, 通过给定函数进行元素访问
func visit(list []int, f func(int)) {
    for _, v := range list {
        f(v)
    }
}
func main() {
    // 使用匿名函数打印切片内容
    visit([]int{1, 2, 3, 4}, func(v int) {
        fmt.Println(v)
    })
}
```

代码说明如下：

- 第 8 行，使用 visit() 函数将整个遍历过程进行封装，当要获取遍历期间的切片值时，只需要给 visit() 传入一个回调参数即可。
- 第 18 行，准备一个整型切片 []int{1,2,3,4} 传入 visit() 函数作为遍历的数据。
- 第 19～20 行，定义了一个匿名函数，作用是将遍历的每个值打印出来。


匿名函数作为回调函数的设计在Go语言的系统包中也比较常见，strings 包中就有类似的设计，代码如下：

```go
func TrimFunc(s string, f func(rune) bool) string {
    return TrimRightFunc(TrimLeftFunc(s, f), f)
}
```

#### 使用匿名函数实现操作封装

下面这段代码将匿名函数作为 map 的键值，通过命令行参数动态调用匿名函数，代码如下：

```go
package main
import (
    "flag"
    "fmt"
)
var skillParam = flag.String("skill", "", "skill to perform")
func main() {
    flag.Parse()
    var skill = map[string]func(){
        "fire": func() {
            fmt.Println("chicken fire")
        },
        "run": func() {
            fmt.Println("soldier run")
        },
        "fly": func() {
            fmt.Println("angel fly")
        },
    }
    if f, ok := skill[*skillParam]; ok {
        f()
    } else {
        fmt.Println("skill not found")
    }
}
```

代码说明如下：

- 第 8 行，定义命令行参数 skill，从命令行输入 --skill 可以将`=`后的字符串传入 skillParam 指针变量。
- 第 12 行，解析命令行参数，解析完成后，skillParam 指针变量将指向命令行传入的值。
- 第 14 行，定义一个从字符串映射到 func() 的 map，然后填充这个 map。
- 第 15～23 行，初始化 map 的键值对，值为匿名函数。
- 第 26 行，skillParam 是一个 *string 类型的指针变量，使用 *skillParam 获取到命令行传过来的值，并在 map 中查找对应命令行参数指定的字符串的函数。
- 第 29 行，如果在 map 定义中存在这个参数就调用，否则打印“技能没有找到”。


运行代码，结果如下：

```go
PS D:\code> go run main.go --skill=fly
angel fly
PS D:\code> go run main.go --skill=run
soldier run 
```

### 7. 函数类型实现接口（把函数作为接口来调用）

函数和其他类型一样都属于“一等公民”，其他类型能够实现接口，函数也可以，本节将对结构体与函数实现接口的过程进行对比。

首先给出本节完整的代码：

```go
package main
import (
    "fmt"
)
// 调用器接口
type Invoker interface {
    // 需要实现一个Call方法
    Call(interface{})
}
// 结构体类型
type Struct struct {
}
// 实现Invoker的Call
func (s *Struct) Call(p interface{}) {
    fmt.Println("from struct", p)
}
// 函数定义为类型
type FuncCaller func(interface{})
// 实现Invoker的Call
func (f FuncCaller) Call(p interface{}) {
    // 调用f函数本体
    f(p)
}
func main() {
    // 声明接口变量
    var invoker Invoker
    // 实例化结构体
    s := new(Struct)
    // 将实例化的结构体赋值到接口
    invoker = s
    // 使用接口调用实例化结构体的方法Struct.Call
    invoker.Call("hello")
    // 将匿名函数转为FuncCaller类型，再赋值给接口
    invoker = FuncCaller(func(v interface{}) {
        fmt.Println("from function", v)
    })
    // 使用接口调用FuncCaller.Call，内部会调用函数本体
    invoker.Call("hello")
}
```

有如下一个接口：

```go
// 调用器接口
type Invoker interface {
    // 需要实现一个Call()方法
    Call(interface{})
}
```

这个接口需要实现 Call() 方法，调用时会传入一个 interface{} 类型的变量，这种类型的变量表示任意类型的值。

接下来，使用结构体进行接口实现。

#### 结构体实现接口

结构体实现 Invoker 接口的代码如下：

```go
// 结构体类型
type Struct struct {
}
// 实现Invoker的Call
func (s *Struct) Call(p interface{}) {
    fmt.Println("from struct", p)
}
```

代码说明如下：

- 第 2 行，定义结构体，该例子中的结构体无须任何成员，主要展示实现 Invoker 的方法。
- 第 6 行，Call() 为结构体的方法，该方法的功能是打印 from struct 和传入的 interface{} 类型的值。


将定义的 Struct 类型实例化，并传入接口中进行调用，代码如下：

```go
// 声明接口变量
var invoker Invoker
// 实例化结构体
s := new(Struct)
// 将实例化的结构体赋值到接口
invoker = s
// 使用接口调用实例化结构体的方法Struct.Call
invoker.Call("hello")
```

代码说明如下：

- 第 2 行，声明 Invoker 类型的变量。
- 第 5 行，使用 new 将结构体实例化，此行也可以写为 s:=&Struct。
- 第 8 行，s 类型为 *Struct，已经实现了 Invoker 接口类型，因此赋值给 invoker 时是成功的。
- 第 11 行，通过接口的 Call() 方法，传入 hello，此时将调用 Struct 结构体的 Call() 方法。


接下来，对比下函数实现结构体的差异。

代码输出如下：

```go
from struct hello
```

#### 函数体实现接口

函数的声明不能直接实现接口，需要将函数定义为类型后，使用类型实现结构体，当类型方法被调用时，还需要调用函数本体。

```go
// 函数定义为类型
type FuncCaller func(interface{})
// 实现Invoker的Call
func (f FuncCaller) Call(p interface{}) {
    // 调用f()函数本体
    f(p)
}
```

代码说明如下：

- 第 2 行，将 func(interface{}) 定义为 FuncCaller 类型。
- 第 5 行，FuncCaller 的 Call() 方法将实现 Invoker 的 Call() 方法。
- 第 8 行，FuncCaller 的 Call() 方法被调用与 func(interface{}) 无关，还需要手动调用函数本体。


上面代码只是定义了函数类型，需要函数本身进行逻辑处理，FuncCaller 无须被实例化，只需要将函数转换为 FuncCaller 类型即可，函数来源可以是命名函数、匿名函数或闭包，参见下面代码：

```go
// 声明接口变量
var invoker Invoker
// 将匿名函数转为FuncCaller类型, 再赋值给接口
invoker = FuncCaller(func(v interface{}) {
    fmt.Println("from function", v)
})
// 使用接口调用FuncCaller.Call, 内部会调用函数本体
invoker.Call("hello")
```

代码说明如下：

- 第 2 行，声明接口变量。
- 第 5 行，将 func(v interface{}){} 匿名函数转换为 FuncCaller 类型（函数签名才能转换），此时 FuncCaller 类型实现了 Invoker 的 Call() 方法，赋值给 invoker 接口是成功的。
- 第 10 行，使用接口方法调用。


代码输出如下：

```go
from function hello
```

#### HTTP包中的例子

HTTP 包中包含有 Handler 接口定义，代码如下：

```go
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
```

Handler 用于定义每个 HTTP 的请求和响应的处理过程。

同时，也可以使用处理函数实现接口，定义如下：

```go
type HandlerFunc func(ResponseWriter, *Request)
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
```

要使用闭包实现默认的 HTTP 请求处理，可以使用 http.HandleFunc() 函数，函数定义如下：

```go
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
```

而 DefaultServeMux 是 ServeMux 结构，拥有 HandleFunc() 方法，定义如下：

```go
func (mux *ServeMux) HandleFunc(pattern string, handler func
(ResponseWriter, *Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
```

上面代码将外部传入的函数 handler() 转为 HandlerFunc 类型，HandlerFunc 类型实现了 Handler 的 ServeHTTP 方法，底层可以同时使用各种类型来实现 Handler 接口进行处理。

### 8. 闭包 Closure（引用了外部变量的匿名函数）

Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：

```go
函数 + 引用环境 = 闭包
```

同一个函数与不同引用环境组合，可以形成不同的实例，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180814/1-1PQ41F62I51.jpg)
图：闭包与函数引用


一个函数类型就像结构体一样，可以被实例化，函数本身不存储任何信息，只有与引用环境结合后形成的闭包才具有“记忆性”，函数是编译期静态的概念，而闭包是运行期动态的概念。

#### 其它编程语言中的闭包

闭包（Closure）在某些编程语言中也被称为 Lambda 表达式。

闭包对环境中变量的引用过程也可以被称为“捕获”，在 [C++](http://c.biancheng.net/cplus/)11 标准中，捕获有两种类型，分别是引用和复制，可以改变引用的原值叫做“引用捕获”，捕获的过程值被复制到闭包中使用叫做“复制捕获”。

在 Lua 语言中，将被捕获的变量起了一个名字叫做 Upvalue，因为捕获过程总是对闭包上方定义过的自由变量进行引用。

闭包在各种语言中的实现也是不尽相同的，在 Lua 语言中，无论闭包还是函数都属于 Prototype 概念，被捕获的变量以 Upvalue 的形式引用到闭包中。

C++ 与 [C#](http://c.biancheng.net/csharp/) 中为闭包创建了一个类，而被捕获的变量在编译时放到类中的成员中，闭包在访问被捕获的变量时，实际上访问的是闭包隐藏类的成员。

#### 在闭包内部修改引用的变量

闭包对它作用域上部的变量可以进行修改，修改引用的变量会对变量进行实际修改，通过下面的例子来理解：

```go
// 准备一个字符串
str := "hello world"
// 创建一个匿名函数
foo := func() {
   
    // 匿名函数中访问str
    str = "hello dude"
}
// 调用匿名函数
foo()
```

代码说明如下：

- 第 2 行，准备一个字符串用于修改。
- 第 5 行，创建一个匿名函数。
- 第 8 行，在匿名函数中并没有定义 str，str 的定义在匿名函数之前，此时，str 就被引用到了匿名函数中形成了闭包。
- 第 12 行，执行闭包，此时 str 发生修改，变为 hello dude。


代码输出：

```go
hello dude
```

#### 示例：闭包的记忆效应

被捕获到闭包中的变量让闭包本身拥有了记忆效应，闭包中的逻辑可以修改闭包捕获的变量，变量会跟随闭包生命期一直存在，闭包本身就如同变量一样拥有了记忆效应。

累加器的实现：

```go
package main
import (
    "fmt"
)
// 提供一个值, 每次调用函数会指定对值进行累加
func Accumulate(value int) func() int {
    // 返回一个闭包
    return func() int {
        // 累加
        value++
        // 返回一个累加值
        return value
    }
}
func main() {
    // 创建一个累加器, 初始值为1
    accumulator := Accumulate(1)
    // 累加1并打印
    fmt.Println(accumulator())
    fmt.Println(accumulator())
    // 打印累加器的函数地址
    fmt.Printf("%p\n", &accumulator)
    // 创建一个累加器, 初始值为1
    accumulator2 := Accumulate(10)
    // 累加1并打印
    fmt.Println(accumulator2())
    // 打印累加器的函数地址
    fmt.Printf("%p\n", &accumulator2)
}
```

代码说明如下：

- 第 8 行，累加器生成函数，这个函数输出一个初始值，调用时返回一个为初始值创建的闭包函数。
- 第 11 行，返回一个闭包函数，每次返回会创建一个新的函数实例。
- 第 14 行，对引用的 Accumulate 参数变量进行累加，注意 value 不是第 11 行匿名函数定义的，但是被这个匿名函数引用，所以形成闭包。
- 第 17 行，将修改后的值通过闭包的返回值返回。
- 第 24 行，创建一个累加器，初始值为 1，返回的 accumulator 是类型为 func()int 的函数变量。
- 第 27 行，调用 accumulator() 时，代码从 11 行开始执行匿名函数逻辑，直到第 17 行返回。
- 第 32 行，打印累加器的函数地址。


对比输出的日志发现 accumulator 与 accumulator2 输出的函数地址不同，因此它们是两个不同的闭包实例。

每调用一次 accumulator 都会自动对引用的变量进行累加。

#### 示例：闭包实现生成器

闭包的记忆效应被用于实现类似于[设计模式](http://c.biancheng.net/design_pattern/)中工厂模式的生成器，下面的例子展示了创建一个玩家生成器的过程。

玩家生成器的实现：

```go
package main
import (
    "fmt"
)
// 创建一个玩家生成器, 输入名称, 输出生成器
func playerGen(name string) func() (string, int) {
    // 血量一直为150
    hp := 150
    // 返回创建的闭包
    return func() (string, int) {
        // 将变量引用到闭包中
        return name, hp
    }
}
func main() {
    // 创建一个玩家生成器
    generator := playerGen("high noon")
    // 返回玩家的名字和血量
    name, hp := generator()
    // 打印值
    fmt.Println(name, hp)
}
```

代码输出如下：

```go
high noon 150
```

代码说明如下：

- 第 8 行，playerGen() 需要提供一个名字来创建一个玩家的生成函数。
- 第 11 行，声明并设定 hp 变量为 150。
- 第 14～18 行，将 hp 和 name 变量引用到匿名函数中形成闭包。
- 第 24 行中，通过 playerGen 传入参数调用后获得玩家生成器。
- 第 27 行，调用这个玩家生成器函数，可以获得玩家的名称和血量。


闭包还具有一定的封装性，第 11 行的变量是 playerGen 的局部变量，playerGen 的外部无法直接访问及修改这个变量，这种特性也与面向对象中强调的封装性类似。

### 9. 可变参数（变参函数）

在C语言时代大家一般都用过 printf() 函数，从那个时候开始其实已经在感受可变参数的魅力和价值，如同C语言中的 printf() 函数，Go语言标准库中的 fmt.Println() 等函数的实现也依赖于语言的可变参数功能。

本节我们将介绍可变参数的用法。合适地使用可变参数，可以让代码简单易用，尤其是输入输出类函数，比如日志函数等。

#### 可变参数类型

可变参数是指函数传入的参数个数是可变的，为了做到这点，首先需要将函数定义为可以接受可变参数的类型：

```go
func myfunc(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
```

上面这段代码的意思是，函数 myfunc() 接受不定数量的参数，这些参数的类型全部是 int，所以它可以用如下方式调用：

```go
myfunc(2, 3, 4)
myfunc(1, 3, 7, 13)
```

形如`...type`格式的类型只能作为函数的参数类型存在，并且必须是最后一个参数，它是一个语法糖（syntactic sugar），即这种语法对语言的功能并没有影响，但是更方便程序员使用，通常来说，使用语法糖能够增加程序的可读性，从而减少程序出错的可能。

从内部实现机理上来说，类型`...type`本质上是一个数组切片，也就是`[]type`，这也是为什么上面的参数 args 可以用 for 循环来获得每个传入的参数。

假如没有`...type`这样的语法糖，开发者将不得不这么写：

```go
func myfunc2(args []int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
```

从函数的实现角度来看，这没有任何影响，该怎么写就怎么写，但从调用方来说，情形则完全不同：

```go
myfunc2([]int{1, 3, 7, 13})
```

大家会发现，我们不得不加上`[]int{}`来构造一个数组切片实例，但是有了`...type`这个语法糖，我们就不用自己来处理了。

#### 任意类型的可变参数

之前的例子中将可变参数类型约束为 int，如果你希望传任意类型，可以指定类型为 interface{}，下面是Go语言标准库中 fmt.Printf() 的函数原型：

```go
func Printf(format string, args ...interface{}) {
  // ...
}
```

用 interface{} 传递任意类型数据是Go语言的惯例用法，使用 interface{} 仍然是类型安全的，这和 C/[C++](http://c.biancheng.net/cplus/) 不太一样，下面通过示例来了解一下如何分配传入 interface{} 类型的数据。

```go
package main
import "fmt"
func MyPrintf(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
            case int:
                fmt.Println(arg, "is an int value.")
            case string:
                fmt.Println(arg, "is a string value.")
            case int64:
                fmt.Println(arg, "is an int64 value.")
            default:
                fmt.Println(arg, "is an unknown type.")
        }
    }
}
func main() {
    var v1 int = 1
    var v2 int64 = 234
    var v3 string = "hello"
    var v4 float32 = 1.234
    MyPrintf(v1, v2, v3, v4)
}
```

该程序的输出结果为：

```go
1 is an int value.
234 is an int64 value.
hello is a string value.
1.234 is an unknown type.
```

#### 遍历可变参数列表——获取每一个参数的值

可变参数列表的数量不固定，传入的参数是一个切片，如果需要获得每一个参数的具体值时，可以对可变参数变量进行遍历，参见下面代码：

```go
package main
import (
    "bytes"
    "fmt"
)
// 定义一个函数, 参数数量为0~n, 类型约束为字符串
func joinStrings(slist ...string) string {
    // 定义一个字节缓冲, 快速地连接字符串
    var b bytes.Buffer
    // 遍历可变参数列表slist, 类型为[]string
    for _, s := range slist {
        // 将遍历出的字符串连续写入字节数组
        b.WriteString(s)
    }
    // 将连接好的字节数组转换为字符串并输出
    return b.String()
}
func main() {
    // 输入3个字符串, 将它们连成一个字符串
    fmt.Println(joinStrings("pig ", "and", " rat"))
    fmt.Println(joinStrings("hammer", " mom", " and", " hawk"))
}
```

代码输出如下：

```go
pig and rat
hammer mom and hawk
```

代码说明如下：

- 第 8 行，定义了一个可变参数的函数，slist 的类型为 []string，每一个参数的类型都是 string，也就是说，该函数只接受字符串类型作为参数。
- 第 11 行，bytes.Buffer 在这个例子中的作用类似于 StringBuilder，可以高效地进行字符串连接操作。
- 第 13 行，遍历 slist 可变参数，s 为每个参数的值，类型为 string。
- 第 15 行，将每一个传入参数放到 bytes.Buffer 中。
- 第 19 行，将 bytes.Buffer 中的数据转换为字符串作为函数返回值返回。
- 第 24 行，输入 3 个字符串，使用 joinStrings() 函数将参数连接为字符串输出。
- 第 25 行，输入 4 个字符串，连接后输出。


如果要获取可变参数的数量，可以使用 len() 函数对可变参数变量对应的切片进行求长度操作，以获得可变参数数量。

#### 获得可变参数类型——获得每一个参数的类型

当可变参数为 interface{} 类型时，可以传入任何类型的值，此时，如果需要获得变量的类型，可以通过 switch 获得变量的类型，下面的代码演示将一系列不同类型的值传入 printTypeValue() 函数，该函数将分别为不同的参数打印它们的值和类型的详细描述。

打印类型及值：

```go
package main
import (
    "bytes"
    "fmt"
)
func printTypeValue(slist ...interface{}) string {
    // 字节缓冲作为快速字符串连接
    var b bytes.Buffer
    // 遍历参数
    for _, s := range slist {
        // 将interface{}类型格式化为字符串
        str := fmt.Sprintf("%v", s)
        // 类型的字符串描述
        var typeString string
        // 对s进行类型断言
        switch s.(type) {
        case bool:    // 当s为布尔类型时
            typeString = "bool"
        case string:    // 当s为字符串类型时
            typeString = "string"
        case int:    // 当s为整型类型时
            typeString = "int"
        }
        // 写字符串前缀
        b.WriteString("value: ")
        // 写入值
        b.WriteString(str)
        // 写类型前缀
        b.WriteString(" type: ")
        // 写类型字符串
        b.WriteString(typeString)
        // 写入换行符
        b.WriteString("\n")
    }
    return b.String()
}
func main() {
    // 将不同类型的变量通过printTypeValue()打印出来
    fmt.Println(printTypeValue(100, "str", true))
}
```

代码输出如下：

```go
value: 100 type: int
value: str type: string
value: true type: bool
```

代码说明如下：

- 第 8 行，printTypeValue() 输入不同类型的值并输出类型和值描述。
- 第 11 行，bytes.Buffer 字节缓冲作为快速字符串连接。
- 第 14 行，遍历 slist 的每一个元素，类型为 interface{}。
- 第 17 行，使用 fmt.Sprintf 配合`%v`动词，可以将 interface{} 格式的任意值转为字符串。
- 第 20 行，声明一个字符串，作为变量的类型名。
- 第 23 行，switch s.(type) 可以对 interface{} 类型进行类型断言，也就是判断变量的实际类型。
- 第 24～29 行为 s 变量可能的类型，将每种类型的对应类型字符串赋值到 typeString 中。
- 第 33～42 行为写输出格式的过程。

#### 在多个可变参数函数中传递参数

可变参数变量是一个包含所有参数的切片，如果要将这个含有可变参数的变量传递给下一个可变参数函数，可以在传递时给可变参数变量后面添加`...`，这样就可以将切片中的元素进行传递，而不是传递可变参数变量本身。

下面的例子模拟 print() 函数及实际调用的 rawPrint() 函数，两个函数都拥有可变参数，需要将参数从 print 传递到 rawPrint 中。

可变参数传递：

```go
package main
import "fmt"
// 实际打印的函数
func rawPrint(rawList ...interface{}) {
    // 遍历可变参数切片
    for _, a := range rawList {
        // 打印参数
        fmt.Println(a)
    }
}
// 打印函数封装
func print(slist ...interface{}) {
    // 将slist可变参数切片完整传递给下一个函数
    rawPrint(slist...)
}
func main() {
    print(1, 2, 3)
}
```

代码输出如下：

```go
1
2
3
```

对代码的说明：

- 第 9～13 行，遍历 rawPrint() 的参数列表 rawList 并打印。
- 第 20 行，将变量在 print 的可变参数列表中添加`...`后传递给 rawPrint()。
- 第 25 行，传入 1、2、3 这 3 个整型值并进行打印。


如果尝试将第 20 行修改为：

```go
rawPrint("fmt", slist)
```

再次执行代码，将输出：

```go
[1 2 3]
```

此时，slist（类型为 []interface{}）将被作为一个整体传入 rawPrint()，rawPrint() 函数中遍历的变量也就是 slist 的切片值。

可变参数使用`...`进行传递与切片间使用 append 连接是同一个特性。

### 10. defer（延迟执行语句）

Go语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，将延迟处理的语句按 defer 的逆序进行执行，也就是说，先被 defer 的语句最后被执行，最后被 defer 的语句，最先被执行。

关键字 defer 的用法类似于面向对象编程语言 [Java](http://c.biancheng.net/java/) 和 [C#](http://c.biancheng.net/csharp/) 的 finally 语句块，它一般用于释放某些已分配的资源，典型的例子就是对一个互斥解锁，或者关闭一个文件。

#### 多个延迟执行语句的处理顺序

当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出），下面的代码是将一系列的数值打印语句按顺序延迟处理，如下所示：

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println("defer begin")
    // 将defer放入延迟调用栈
    defer fmt.Println(1)
    defer fmt.Println(2)
    // 最后一个放入, 位于栈顶, 最先调用
    defer fmt.Println(3)
    fmt.Println("defer end")
}
```

代码输出如下：

```go
defer begin
defer end
3
2
1
```

结果分析如下：

- 代码的延迟顺序与最终的执行顺序是反向的。
- 延迟调用是在 defer 所在函数结束时进行，函数结束可以是正常返回时，也可以是发生宕机时。

#### 使用延迟执行语句在函数退出时释放资源

处理业务或逻辑中涉及成对的操作是一件比较烦琐的事情，比如打开和关闭文件、接收请求和回复请求、加锁和解锁等。在这些操作中，最容易忽略的就是在每个函数退出处正确地释放和关闭资源。

defer 语句正好是在函数退出时执行的语句，所以使用 defer 能非常方便地处理资源释放问题。

##### 1) 使用延迟并发解锁

在下面的例子中会在函数中并发使用 map，为防止竞态问题，使用 sync.Mutex 进行加锁，参见下面代码：

```go
var (
    // 一个演示用的映射
    valueByKey      = make(map[string]int)
    // 保证使用映射时的并发安全的互斥锁
    valueByKeyGuard sync.Mutex
)
// 根据键读取值
func readValue(key string) int {
    // 对共享资源加锁
    valueByKeyGuard.Lock()
    // 取值
    v := valueByKey[key]
    // 对共享资源解锁
    valueByKeyGuard.Unlock()
    // 返回值
    return v
}
```

代码说明如下：

- 第 3 行，实例化一个 map，键是 string 类型，值为 int。
- 第 5 行，map 默认不是并发安全的，准备一个 sync.Mutex 互斥量保护 map 的访问。
- 第 9 行，readValue() 函数给定一个键，从 map 中获得值后返回，该函数会在并发环境中使用，需要保证并发安全。
- 第 11 行，使用互斥量加锁。
- 第 13 行，从 map 中获取值。
- 第 15 行，使用互斥量解锁。
- 第 17 行，返回获取到的 map 值。


使用 defer 语句对上面的语句进行简化，参考下面的代码。

```go
func readValue(key string) int {
    valueByKeyGuard.Lock()
   
    // defer后面的语句不会马上调用, 而是延迟到函数结束时调用
    defer valueByKeyGuard.Unlock()
    return valueByKey[key]
}
```

上面的代码中第 6~8 行是对前面代码的修改和添加的代码，代码说明如下：

- 第 6 行在互斥量加锁后，使用 defer 语句添加解锁，该语句不会马上执行，而是等 readValue() 函数返回时才会被执行。
- 第 8 行，从 map 查询值并返回的过程中，与不使用互斥量的写法一样，对比上面的代码，这种写法更简单。

##### 2) 使用延迟释放文件句柄

文件的操作需要经过打开文件、获取和操作文件资源、关闭资源几个过程，如果在操作完毕后不关闭文件资源，进程将一直无法释放文件资源，在下面的例子中将实现根据文件名获取文件大小的函数，函数中需要打开文件、获取文件大小和关闭文件等操作，由于每一步系统操作都需要进行错误处理，而每一步处理都会造成一次可能的退出，因此就需要在退出时释放资源，而我们需要密切关注在函数退出处正确地释放文件资源，参考下面的代码：

```go
// 根据文件名查询其大小
func fileSize(filename string) int64 {
    // 根据文件名打开文件, 返回文件句柄和错误
    f, err := os.Open(filename)
    // 如果打开时发生错误, 返回文件大小为0
    if err != nil {
        return 0
    }
    // 取文件状态信息
    info, err := f.Stat()
   
    // 如果获取信息时发生错误, 关闭文件并返回文件大小为0
    if err != nil {
        f.Close()
        return 0
    }
    // 取文件大小
    size := info.Size()
    // 关闭文件
    f.Close()
   
    // 返回文件大小
    return size
}
```

代码说明如下：

- 第 2 行，定义获取文件大小的函数，返回值是 64 位的文件大小值。
- 第 5 行，使用 os 包提供的函数 Open()，根据给定的文件名打开一个文件，并返回操作文件用的句柄和操作错误。
- 第 8 行，如果打开的过程中发生错误，如文件没找到、文件被占用等，将返回文件大小为 0。
- 第 13 行，此时文件句柄 f 可以正常使用，使用 f 的方法 Stat() 来获取文件的信息，获取信息时，可能也会发生错误。
- 第 16～19 行对错误进行处理，此时文件是正常打开的，为了释放资源，必须要调用 f 的 Close() 方法来关闭文件，否则会发生资源泄露。
- 第 22 行，获取文件大小。
- 第 25 行，关闭文件、释放资源。
- 第 28 行，返回获取到的文件大小。


在上面的例子中，第 25 行是对文件的关闭操作，下面使用 defer 对代码进行简化，代码如下：

```go
func fileSize(filename string) int64 {
    f, err := os.Open(filename)
    if err != nil {
        return 0
    }
    // 延迟调用Close, 此时Close不会被调用
    defer f.Close()
    info, err := f.Stat()
    if err != nil {
        // defer机制触发, 调用Close关闭文件
        return 0
    }
    size := info.Size()
    // defer机制触发, 调用Close关闭文件
    return size
}
```

代码中加粗部分为对比前面代码而修改的部分，代码说明如下：

- 第 10 行，在文件正常打开后，使用 defer，将 f.Close() 延迟调用，注意，不能将这一句代码放在第 4 行空行处，一旦文件打开错误，f 将为空，在延迟语句触发时，将触发宕机错误。
- 第 16 行和第 22 行，defer 后的语句（f.Close()）将会在函数返回前被调用，自动释放资源。

### 11. 递归函数

很对编程语言都支持递归函数，Go语言也不例外，所谓递归函数指的是在函数内部调用函数自身的函数，从数学解题思路来说，递归就是把一个大问题拆分成多个小问题，再各个击破，在实际开发过程中，递归函数可以解决许多数学问题，如计算给定数字阶乘、产生斐波系列等。

构成递归需要具备以下条件：

- 一个问题可以被拆分成多个子问题；
- 拆分前的原问题与拆分后的子问题除了数据规模不同，但处理问题的思路是一样的；
- 不能无限制的调用本身，子问题需要有退出递归状态的条件。

注意：编写递归函数时，一定要有终止条件，否则就会无限调用下去，直到内存溢出。

下面通过几个示例来演示一下递归函数的使用。

#### 斐波那契数列

下面我们就以递归函数的经典示例 —— 斐波那契数列为例，演示如何通过Go语言编写的递归函数来打印斐波那契数列。

数列的形式如下所示：

```go
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, …
```

使用Go语言递归函数实现斐波那契数列的具体代码如下所示：

```go
package main
import "fmt"
func main() {
    result := 0
    for i := 1; i <= 10; i++ {
        result = fibonacci(i)
        fmt.Printf("fibonacci(%d) is: %d\n", i, result)
    }
}
func fibonacci(n int) (res int) {
    if n <= 2 {
        res = 1
    } else {
        res = fibonacci(n-1) + fibonacci(n-2)
    }
    return
}
```

输出结果为：

```go
fibonacci(1) is: 1
fibonacci(2) is: 1
fibonacci(3) is: 2
fibonacci(4) is: 3
fibonacci(5) is: 5
fibonacci(6) is: 8
fibonacci(7) is: 13
fibonacci(8) is: 21
fibonacci(9) is: 34
fibonacci(10) is: 55
```

#### 数字阶乘

一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且 0 的阶乘为 1，自然数 n 的阶乘写作`n!`，“基斯顿·卡曼”在 1808 年发明了`n!`这个运算符号。

例如，`n!=1×2×3×…×n`，阶乘亦可以递归方式定义：`0!=1，n!=(n-1)!×n`。

使用递归函数计算给定数的阶乘，示例代码如下所示：

```go
package main
import "fmt"
func Factorial(n uint64) (result uint64) {
    if n > 0 {
        result = n * Factorial(n-1)
        return result
    }
    return 1
}
func main() {
    var i int = 10
    fmt.Printf("%d 的阶乘是 %d\n", i, Factorial(uint64(i)))
}
```

输出结果为：

```go
10 的阶乘是 3628800
```

#### 多个函数组成递归

Go语言中也可以使用相互调用的递归函数，多个函数之间相互调用形成闭环，因为Go语言编译器的特殊性，这些函数的声明顺序可以是任意的，下面这个简单的例子展示了函数 odd 和 even 之间的相互调用：

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Printf("%d is even: is %t\n", 16, even(16)) // 16 is even: is true
    fmt.Printf("%d is odd: is %t\n", 17, odd(17))
    // 17 is odd: is true
    fmt.Printf("%d is odd: is %t\n", 18, odd(18))
    // 18 is odd: is false
}
func even(nr int) bool {
    if nr == 0 {
        return true
    }
    return odd(RevSign(nr) - 1)
}
func odd(nr int) bool {
    if nr == 0 {
        return false
    }
    return even(RevSign(nr) - 1)
}
func RevSign(nr int) int {
    if nr < 0 {
        return -nr
    }
    return nr
}
```

运行效果如下所示：

```go
16 is even: is true
17 is odd: is true
18 is odd: is false
```

### 12. 处理运行时错误

Go语言的错误处理思想及设计包含以下特征：

- 一个可能造成错误的函数，需要返回值中返回一个错误接口（error），如果调用是成功的，错误接口将返回 nil，否则返回错误。
- 在函数调用后需要检查错误，如果发生错误，则进行必要的错误处理。


Go语言没有类似 [Java](http://c.biancheng.net/java/) 或 .NET 中的异常处理机制，虽然可以使用 defer、panic、recover 模拟，但官方并不主张这样做，Go语言的设计者认为其他语言的异常机制已被过度使用，上层逻辑需要为函数发生的异常付出太多的资源，同时，如果函数使用者觉得错误处理很麻烦而忽略错误，那么程序将在不可预知的时刻崩溃。

Go语言希望开发者将错误处理视为正常开发必须实现的环节，正确地处理每一个可能发生错误的函数，同时，Go语言使用返回值返回错误的机制，也能大幅降低编译器、运行时处理错误的复杂度，让开发者真正地掌握错误的处理。

#### net 包中的例子

net.Dial() 是Go语言系统包 net 即中的一个函数，一般用于创建一个 Socket 连接。

net.Dial 拥有两个返回值，即 Conn 和 error，这个函数是阻塞的，因此在 Socket 操作后，会返回 Conn 连接对象和 error，如果发生错误，error 会告知错误的类型，Conn 会返回空。

根据Go语言的错误处理机制，Conn 是其重要的返回值，因此，为这个函数增加一个错误返回，类似为 error，参见下面的代码：

```go
func Dial(network, address string) (Conn, error) {
    var d Dialer
    return d.Dial(network, address)
}
```

在 io 包中的 Writer 接口也拥有错误返回，代码如下：

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

io 包中还有 Closer 接口，只有一个错误返回，代码如下：

```go
type Closer interface {
    Close() error
}
```

#### 错误接口的定义格式

error 是 Go 系统声明的接口类型，代码如下：

```go
type error interface {
    Error() string
}
```

所有符合 Error()string 格式的方法，都能实现错误接口，Error() 方法返回错误的具体描述，使用者可以通过这个字符串知道发生了什么错误。

#### 自定义一个错误

返回错误前，需要定义会产生哪些可能的错误，在Go语言中，使用 errors 包进行错误的定义，格式如下：

```go
var err = errors.New("this is an error")
```

错误字符串由于相对固定，一般在包作用域声明，应尽量减少在使用时直接使用 errors.New 返回。

##### 1) errors 包

Go语言的 errors 中对 New 的定义非常简单，代码如下：

```go
// 创建错误对象
func New(text string) error {
    return &errorString{text}
}
// 错误字符串
type errorString struct {
    s string
}
// 返回发生何种错误
func (e *errorString) Error() string {
    return e.s
}
```

代码说明如下：

- 第 2 行，将 errorString 结构体实例化，并赋值错误描述的成员。
- 第 7 行，声明 errorString 结构体，拥有一个成员，描述错误内容。
- 第 12 行，实现 error 接口的 Error() 方法，该方法返回成员中的错误描述。

##### 2) 在代码中使用错误定义

下面的代码会定义一个除法函数，当除数为 0 时，返回一个预定义的除数为 0 的错误。

```go
package main
import (
    "errors"
    "fmt"
)
// 定义除数为0的错误
var errDivisionByZero = errors.New("division by zero")
func div(dividend, divisor int) (int, error) {
    // 判断除数为0的情况并返回
    if divisor == 0 {
        return 0, errDivisionByZero
    }
    // 正常计算，返回空错误
    return dividend / divisor, nil
}
func main() {
    fmt.Println(div(1, 0))
}
```

代码输出如下：

```go
0 division by zero
```

代码说明：

- 第 9 行，预定义除数为 0 的错误。
- 第 11 行，声明除法函数，输入被除数和除数，返回商和错误。
- 第 14 行，在除法计算中，如果除数为 0，计算结果为无穷大，为了避免这种情况，对除数进行判断，并返回商为 0 和除数为 0 的错误对象。
- 第 19 行，进行正常的除法计算，没有发生错误时，错误对象返回 nil。

#### 示例：在解析中使用自定义错误

使用 errors.New 定义的错误字符串的错误类型是无法提供丰富的错误信息的，那么，如果需要携带错误信息返回，就需要借助自定义结构体实现错误接口。

下面代码将实现一个解析错误（ParseError），这种错误包含两个内容，分别是文件名和行号，解析错误的结构还实现了 error 接口的 Error() 方法，返回错误描述时，就需要将文件名和行号返回。

```go
package main
import (
    "fmt"
)
// 声明一个解析错误
type ParseError struct {
    Filename string // 文件名
    Line     int    // 行号
}
// 实现error接口，返回错误描述
func (e *ParseError) Error() string {
    return fmt.Sprintf("%s:%d", e.Filename, e.Line)
}
// 创建一些解析错误
func newParseError(filename string, line int) error {
    return &ParseError{filename, line}
}
func main() {
    var e error
    // 创建一个错误实例，包含文件名和行号
    e = newParseError("main.go", 1)
    // 通过error接口查看错误描述
    fmt.Println(e.Error())
    // 根据错误接口具体的类型，获取详细错误信息
    switch detail := e.(type) {
    case *ParseError: // 这是一个解析错误
        fmt.Printf("Filename: %s Line: %d\n", detail.Filename, detail.Line)
    default: // 其他类型的错误
        fmt.Println("other error")
    }
}
```

代码输出如下：

```go
main.go:1
Filename: main.go Line: 1
```

代码说明如下：

- 第 8 行，声明了一个解析错误的结构体，解析错误包含有 2 个成员，分别是文件名和行号。
- 第 14 行，实现了错误接口，将成员的文件名和行号格式化为字符串返回。
- 第 19 行，根据给定的文件名和行号创建一个错误实例。
- 第 25 行，声明一个错误接口类型。
- 第 27 行，创建一个实例，这个错误接口内部是 *ParserError 类型，携带有文件名 main.go 和行号 1。
- 第 30 行，调用 Error() 方法，通过第 15 行返回错误的详细信息。
- 第 33 行，通过错误断言，取出发生错误的详细类型。
- 第 34 行，通过分析这个错误的类型，得知错误类型为 *ParserError，此时可以获取到详细的错误信息。
- 第 36 行，如果不是我们能够处理的错误类型，会打印出其他错误做出其他的处理。


错误对象都要实现 error 接口的 Error() 方法，这样，所有的错误都可以获得字符串的描述，如果想进一步知道错误的详细信息，可以通过类型断言，将错误对象转为具体的错误类型进行错误详细信息的获取。

### 13. 宕机（panic）程序终止运行

Go语言的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等，这些运行时错误会引起宕机。

宕机不是一件很好的事情，可能造成体验停止、服务中断，就像没有人希望在取钱时遇到 ATM 机蓝屏一样，但是，如果在损失发生时，程序没有因为宕机而停止，那么用户将会付出更大的代价，这种代价可以是金钱、时间甚至生命，因此，宕机有时也是一种合理的止损方法。

一般而言，当宕机发生时，程序会中断运行，并立即执行在该 goroutine（可以先理解成线程）中被延迟的函数（defer 机制），随后，程序崩溃并输出日志信息，日志信息包括 panic value 和函数调用的堆栈跟踪信息，panic value 通常是某种错误信息。

对于每个 goroutine，日志信息中都会有与之相对的，发生 panic 时的函数调用堆栈跟踪信息，通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据，因此，在我们填写问题报告时，一般会将宕机和日志信息一并记录。

虽然Go语言的 panic 机制类似于其他语言的异常，但 panic 的适用场景有一些不同，由于 panic 会引起程序的崩溃，因此 panic 一般用于严重错误，如程序内部的逻辑不一致。任何崩溃都表明了我们的代码中可能存在漏洞，所以对于大部分漏洞，我们应该使用Go语言提供的错误机制，而不是 panic。

#### 手动触发宕机

Go语言可以在程序中手动触发宕机，让程序崩溃，这样开发者可以及时地发现错误，同时减少可能的损失。

Go语言程序在宕机时，会将堆栈和 goroutine 信息输出到控制台，所以宕机也可以方便地知晓发生错误的位置，那么我们要如何触发宕机呢，示例代码如下所示：

```go
package main
func main() {
    panic("crash")
}
```

代码运行崩溃并输出如下：

```go
panic: crash

goroutine 1 [running]:
main.main()
  D:/code/main.go:4 +0x40
exit status 2
```

以上代码中只用了一个内建的函数 panic() 就可以造成崩溃，panic() 的声明如下：

```go
func panic(v interface{})    //panic() 的参数可以是任意类型的。
```

#### 在运行依赖的必备资源缺失时主动触发宕机

regexp 是Go语言的正则表达式包，正则表达式需要编译后才能使用，而且编译必须是成功的，表示正则表达式可用。

编译正则表达式函数有两种，具体如下：

##### 1) func Compile(expr string) (*Regexp, error)

编译正则表达式，发生错误时返回编译错误同时返回 Regexp 为 nil，该函数适用于在编译错误时获得编译错误进行处理，同时继续后续执行的环境。

##### 2) func MustCompile(str string) *Regexp

当编译正则表达式发生错误时，使用 panic 触发宕机，该函数适用于直接使用正则表达式而无须处理正则表达式错误的情况。

MustCompile 的代码如下：

```go
func MustCompile(str string) *Regexp {
    regexp, error := Compile(str)
    if error != nil {
        panic(`regexp: Compile(` + quote(str) + `): ` + error.Error())
    }
    return regexp
}
```

代码说明如下：

- 第 1 行，编译正则表达式函数入口，输入包含正则表达式的字符串，返回正则表达式对象。
- 第 2 行，Compile() 是编译正则表达式的入口函数，该函数返回编译好的正则表达式对象和错误。
- 第 3 和第 4 行判断如果有错，则使用 panic() 触发宕机。
- 第 6 行，没有错误时返回正则表达式对象。


手动宕机进行报错的方式不是一种偷懒的方式，反而能迅速报错，终止程序继续运行，防止更大的错误产生，不过，如果任何错误都使用宕机处理，也不是一种良好的设计习惯，因此应根据需要来决定是否使用宕机进行报错。

#### 在宕机时触发延迟执行语句

当 panic() 触发的宕机发生时，panic() 后面的代码将不会被运行，但是在 panic() 函数前面已经运行过的 defer 语句依然会在宕机发生时发生作用，参考下面代码：

```go
package main
import "fmt"
func main() {
    defer fmt.Println("宕机后要做的事情1")
    defer fmt.Println("宕机后要做的事情2")
    panic("宕机")
}
```

代码输出如下：

```go
宕机后要做的事情2
宕机后要做的事情1
panic: 宕机

goroutine 1 [running]:
main.main()
  D:/code/main.go:8 +0xf8
exit status 2
```

对代码的说明：

- 第 6 行和第 7 行使用 defer 语句延迟了 2 个语句。
- 第 8 行发生宕机。


宕机前，defer 语句会被优先执行，由于第 7 行的 defer 后执行，因此会在宕机前，这个 defer 会优先处理，随后才是第 6 行的 defer 对应的语句，这个特性可以用来在宕机发生前进行宕机信息处理。

### 14. 宕机恢复（recover）防止程序崩溃

Recover 是一个Go语言的内建函数，可以让进入宕机流程中的 goroutine 恢复过来，recover 仅在延迟函数 defer 中有效，在正常的执行过程中，调用 recover 会返回 nil 并且没有其他任何效果，如果当前的 goroutine 陷入恐慌，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。

通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web 服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web 服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。

##### 提示

在其他语言里，宕机往往以异常的形式存在，底层抛出异常，上层逻辑通过 try/catch 机制捕获异常，没有被捕获的严重异常会导致宕机，捕获的异常可以被忽略，让代码继续运行。

Go语言没有异常系统，其使用 panic 触发宕机类似于其他语言的抛出异常，recover 的宕机恢复机制就对应其他语言中的 try/catch 机制。

#### 让程序在崩溃时继续执行

下面的代码实现了 ProtectRun() 函数，该函数传入一个匿名函数或闭包后的执行函数，当传入函数以任何形式发生 panic 崩溃后，可以将崩溃发生的错误打印出来，同时允许后面的代码继续运行，不会造成整个进程的崩溃。

保护运行函数：

```go
package main
import (
    "fmt"
    "runtime"
)
// 崩溃时需要传递的上下文信息
type panicContext struct {
    function string // 所在函数
}
// 保护方式允许一个函数
func ProtectRun(entry func()) {
    // 延迟处理的函数
    defer func() {
        // 发生宕机时，获取panic传递的上下文并打印
        err := recover()
        switch err.(type) {
        case runtime.Error: // 运行时错误
            fmt.Println("runtime error:", err)
        default: // 非运行时错误
            fmt.Println("error:", err)
        }
    }()
    entry()
}
func main() {
    fmt.Println("运行前")
    // 允许一段手动触发的错误
    ProtectRun(func() {
        fmt.Println("手动宕机前")
        // 使用panic传递上下文
        panic(&panicContext{
            "手动触发panic",
        })
        fmt.Println("手动宕机后")
    })
    // 故意造成空指针访问错误
    ProtectRun(func() {
        fmt.Println("赋值宕机前")
        var a *int
        *a = 1
        fmt.Println("赋值宕机后")
    })
    fmt.Println("运行后")
}
```

代码输出结果：

```go
运行前
手动宕机前
error: &{手动触发panic}
赋值宕机前
runtime error: runtime error: invalid memory address or nil pointer dereference
运行后
```

对代码的说明：

- 第 9 行声明描述错误的结构体，保存执行错误的函数。
- 第 17 行使用 defer 将闭包延迟执行，当 panic 触发崩溃时，ProtectRun() 函数将结束运行，此时 defer 后的闭包将会发生调用。
- 第 20 行，recover() 获取到 panic 传入的参数。
- 第 22 行，使用 switch 对 err 变量进行类型断言。
- 第 23 行，如果错误是有 Runtime 层抛出的运行时错误，如空指针访问、除数为 0 等情况，打印运行时错误。
- 第 25 行，其他错误，打印传递过来的错误数据。
- 第 44 行，使用 panic 手动触发一个错误，并将一个结构体附带信息传递过去，此时，recover 就会获取到这个结构体信息，并打印出来。
- 第 57 行，模拟代码中空指针赋值造成的错误，此时会由 Runtime 层抛出错误，被 ProtectRun() 函数的 recover() 函数捕获到。

#### panic 和 recover 的关系

panic 和 recover 的组合有如下特性：

- 有 panic 没 recover，程序宕机。
- 有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。

##### 提示

虽然 panic/recover 能模拟其他语言的异常机制，但并不建议在编写普通函数时也经常性使用这种特性。

在 panic 触发的 defer 函数内，可以继续调用 panic，进一步将错误外抛，直到程序整体崩溃。

如果想在捕获错误时设置当前函数的返回值，可以对返回值使用命名返回值方式直接进行设置。

### 15. 计算函数执行时间

函数的运行时间的长短是衡量这个函数性能的重要指标，特别是在对比和基准测试中，要得到函数的运行时间，最简单的办法就是在函数执行之前设置一个起始时间，并在函数运行结束时获取从起始时间到现在的时间间隔，这个时间间隔就是函数的运行时间。

在Go语言中我们可以使用 time 包中的 Since() 函数来获取函数的运行时间，Go语言官方文档中对 Since() 函数的介绍是这样的。

```go
func Since(t Time) Duration
```

Since() 函数返回从 t 到现在经过的时间，等价于`time.Now().Sub(t)`。

【示例】使用 Since() 函数获取函数的运行时间。

```go
package main
import (
    "fmt"
    "time"
)
func test() {
    start := time.Now() // 获取当前时间
    sum := 0
    for i := 0; i < 100000000; i++ {
        sum++
    }
    elapsed := time.Since(start)
    fmt.Println("该函数执行完成耗时：", elapsed)
}
func main() {
    test()
}
```

运行结果如下所示：

```go
该函数执行完成耗时： 39.8933ms
```

上面我们提到了 time.Now().Sub() 的功能类似于 Since() 函数，想要使用 time.Now().Sub() 获取函数的运行时间只需要把我们上面代码的第 14 行简单修改一下就行。

【示例 2】使用 time.Now().Sub() 获取函数的运行时间。

```go
package main
import (
    "fmt"
    "time"
)
func test() {
    start := time.Now() // 获取当前时间
    sum := 0
    for i := 0; i < 100000000; i++ {
        sum++
    }
    elapsed := time.Now().Sub(start)
    fmt.Println("该函数执行完成耗时：", elapsed)
}
func main() {
    test()
}
```

运行结果如下所示：

```go
该函数执行完成耗时： 36.8769ms
```

由于计算机 CPU 及一些其他因素的影响，在获取函数运行时间时每次的结果都有些许不同，属于正常现象。



### 16. 通过内存缓存来提升性能

前面我们介绍了[递归函数](http://c.biancheng.net/view/4193.html)，递归函数的缺点就是比较消耗内存，而且效率比较低，那么我们要怎样提高程序的执行效率呢？

当在进行大量计算的时候，提升性能最直接有效的一种方式是避免重复计算，通过在内存中缓存并重复利用缓存从而避免重复执行相同计算的方式称为内存缓存。

下面我们以经典的递归求斐波那契数列为例，来对比一下普通实现方法和加入内存缓存后程序的执行情况。

#### 普通的实现方法

普通方法的实现思路是，要计算数列中第 n 个数字，需要先得到它前面的两个数，以此类推。这么做的弊端是会产生大量的重复计算，代码如下所示：

```go
  package main

  import (
      "fmt"
      "time"
  )

  func main() {
      result := 0
      start := time.Now()
      for i := 1; i <= 40; i++ {
          result = fibonacci(i)
          fmt.Printf("数列第 %d 位: %d\n", i, result)
      }
      end := time.Now()
      delta := end.Sub(start)
      fmt.Printf("程序的执行时间为: %s\n", delta)
  }
  func fibonacci(n int) (res int) {
      if n <= 2 {
          res = 1
      } else {
          res = fibonacci(n-1) + fibonacci(n-2)
      }
      return
  }
```

运行结果如下所示：

数列第 1 位: 1 数列第 2 位: 1 数列第 3 位: 2 数列第 4 位: 3 … 数列第 39 位: 63245986 数列第 40 位: 102334155 程序的执行时间为: 2.2848865s

通过运行结果可以看出，获取第 40 位的数字所需要的时间是 2.2848865 秒（这个时间可能根据计算机性能的差异，略有不同）。

#### 内存缓存的实现方法

内存缓存的实现思路是在计算得到第 n 个数的同时，将它的值保存到数组中索引为 n 的位置上，在后续的计算中先在数组中查找所需要的值是否计算过，如果找到了，则直接从数组中获取，如果没找到，则再进行计算，代码如下所示：

```go
  package main

  import (
      "fmt"
      "time"
  )

  const LIM = 41

  var fibs [LIM]uint64

  func main() {
      var result uint64 = 0
      start := time.Now()
      for i := 1; i < LIM; i++ {
          result = fibonacci(i)
          fmt.Printf("数列第 %d 位: %d\n", i, result)
      }
      end := time.Now()
      delta := end.Sub(start)
      fmt.Printf("程序的执行时间为: %s\n", delta)
  }
  func fibonacci(n int) (res uint64) {
      // 记忆化：检查数组中是否已知斐波那契（n）
      if fibs[n] != 0 {
          res = fibs[n]
          return
      }
      if n <= 2 {
          res = 1
      } else {
          res = fibonacci(n-1) + fibonacci(n-2)
      }
      fibs[n] = res
      return
  }
```

运行结果如下所示：

数列第 1 位: 1 数列第 2 位: 1 数列第 3 位: 2 数列第 4 位: 3 … 数列第 39 位: 63245986 数列第 40 位: 102334155 程序的执行时间为: 0.0149603s

通过运行结果可以看出，同样获取数列第 40 位的数字，使用内存缓存后所用的时间为 0.0149603 秒，对比之前未使用内存缓存时的执行效率，可见内存缓存的优势还是相当明显的。

### 17. 哈希函数

Go 语言中提供了 MD5、SHA-1 等几种哈希函数，下面我们用例子做一个介绍，代码如下所示。

```go
  package main

  import (
      "crypto/md5"
      "crypto/sha1"
      "fmt"
  )

  func main() {
      TestString := "http://c.biancheng.net/golang/"
      Md5Inst := md5.New()
      Md5Inst.Write([]byte(TestString))
      Result := Md5Inst.Sum(\[\]byte(""))
      fmt.Printf("%x\n\n", Result)
      Sha1Inst := sha1.New()
      Sha1Inst.Write(\[\]byte(TestString))
      Result = Sha1Inst.Sum(\[\]byte(""))
      fmt.Printf("%x\n\n", Result)
  }
```

这个程序的执行结果为：

go run main.go 6dc42d81095839903edf352ef1ec0a6a 32313d69e3f0e4bbf6738858274e7e2c9a46d293

再举一个例子，对文件内容计算 SHA1，具体代码如下所示。

```go
  package main

  import (
      "crypto/md5"
      "crypto/sha1"
      "fmt"
      "io"
      "os"
  )

  func main() {
      TestFile := "123.txt"
      infile, inerr := os.Open(TestFile)
      if inerr == nil {
          md5h := md5.New()
          io.Copy(md5h, infile)
          fmt.Printf("%x %s\n", md5h.Sum([]byte("")), TestFile)
          sha1h := sha1.New()
          io.Copy(sha1h, infile)
          fmt.Printf("%x %s\n", sha1h.Sum([]byte("")), TestFile)
      } else {
          fmt.Println(inerr)
          os.Exit(1)
      }
  }
```

若要运行上面的代码，当前目录下需要包含一个 123.txt 文件，运行结果如下：

```go
go run main.go
6dc42d81095839903edf352ef1ec0a6a 123.txt
da39a3ee5e6b4b0d3255bfef95601890afd80709 123.txt
```

### 18. 函数的底层实现

基于堆栈式的程序执行模型决定了函数是语言的一个核心元素，分析 Go 语言函数的底层实现，对理解整个程序的执行过程有很大的帮助，研究底层实现有两种办法，一种是看语言编译器源码，分析其对函数的各个特性的处理逻辑，另一种是反汇编，将可执行程序反汇编出来。

本节使用反汇编这种短、平、快的方法，首先介绍 Go 语言的函数调用规约，接着介绍 Go 语言使用汇编语言的基本概念，然后通过反汇编技术来剖析 Go 语言函数某些特性的底层实现。

> 提示：阅读本节需要有一定的汇编基础，想学习汇编的同学，我们这里准备了一套《汇编语言入门教程》供大家学习。

#### 函数调用规约

Go 语言函数使用的是 caller-save 的模式，即由调用者负责保存寄存器，所以在函数的头尾不会出现`push ebp; mov esp ebp`这样的代码，相反其是在主调函数调用被调函数的前后有一个保存现场和恢复现场的动作。

主调函数保存和恢复现场的通用逻辑如下：

```go
  //开辟栈空间，压栈 BP 保存现场
      SUBQ $x, SP    //为函数开辟裁空间
      MOVQ BP, y(SP) //保存当前函数 BP 到 y(SP）位直， y 为相对 SP 的偏移量
      LEAQ y(SP), BP //重直 BP，使其指向刚刚保存 BP 旧值的位置，这里主要
                     //是方便后续 BP 的恢复

  //弹出栈，恢复 BP
      MOVQ y(SP), BP //恢复 BP 的值为调用前的值
      ADDQ $x, SP    //恢复 SP 的值为函数开始时的位
```

#### 汇编基础

Go 编译器产生的汇编代码是一种中间抽象态，它不是对机器码的映射，而是和平台无关的一个中间态汇编描述，所以汇编代码中有些寄存器是真实的，有些是抽象的，几个抽象的寄存器如下：

- SB (Static base pointer)：静态基址寄存器，它和全局符号一起表示全局变量的地址。

- FP (Frame pointer)：栈帧寄存器，该寄存器指向当前函数调用栈帧的栈底位置。

- PC (Program counter)：程序计数器，存放下一条指令的执行地址，很少直接操作该寄存器，一般是 CALL、RET 等指令隐式的操作。

- SP (Stack pointer)：栈顶寄存器，一般在函数调用前由主调函数设置 SP 的值对栈空间进行分配或回收。

##### Go 汇编简介

1. Go 汇编器采用 AT&T 风格的汇编，早期的实现来自 plan9 汇编器，源操作数在前，目的操作数在后。

1. Go 内嵌汇编和反汇编产生的代码并不是一一对应的，汇编编译器对内嵌汇编程序自动做了调整，主要差别就是增加了保护现场，以及函数调用前的保持 PC 、SP 偏移地址重定位等逻辑，反汇编代码更能反映程序的真实执行逻辑。

1. Go 的汇编代码并不是和具体硬件体系结构的机器码一一对应的，而是一种半抽象的描述，寄存器可能是抽象的，也可能是具体的。

下面代码的分析基于 AMD64 位架构下的 Linux 环境。

#### 多值返回分析

多值返回函数 swap 的源码如下：

```go
  package main

  func swap (a, b int) (x int, y int) {
      x = b
      y = a
      return
  }

  func main() {
      swap(10, 20)
  }
```

##### 编译生成汇编如下

//- S 产生汇编的代码 //- N 禁用优化 //- 1 禁用内联

GOOS=linux GOARCH=amd64 go tool compile -1 -N -S swap.go >swap.s 2>&1

##### 汇编代码分析

1. swap 函数和 main 函数汇编代码分析。例如：

```go
  "".swap STEXT nosplit size=39 args=0x20 locals=0x0
      0x0000 00000 (swap.go:4) TEXT  "".swap(SB), NOSPLIT, $0 - 32
      0x0000 00000 (swap.go:4) FUNCDATA  $0, gclocals.ff19ed39bdde8a01a800918ac3ef0ec7(SB)
      0x0000 00000 (swap.go:4) FUNCDATA  $1, gclocals.33cdeccccebe80329flfdbee7f5874cb(SB)
      0x0000 00000 (swap.go:4)  MOVQ  $0, "".x+24(SP)
      0x0009 00009 (swap.go:4)  MOVQ  $0, "".y+32(SP)
      0x0012 00018 (swap.go:5)  MOVQ  "".b+16(SP), AX
      0x0017 00023 (swap.go:5)  MOVQ  AX, "".x+24(SP)
      0xOO1c 00028 (swap.go:6)  MOVQ  "".a+8(SP), AX
      0x0021 00033 (swap.go:6)  MOVQ  AX, "".y+32(SP)
      0x0026 00038 (swap.go:7)  RET

  "".main STEXT size=68 args=0x0 locals=0x28
      0x0000 00000 (swap.go:10) TEXT "".main(SB), $40 - 0
      0x0000 00000 (swap.go:10) MOVQ (TLS), CX
      0x0009 00009 (swap.go:10) CMPQ SP, 16(CX)
      0x000d 00013 (swap.go:10) JLS 61
      0x000f 00015 (swap.go:10) SUBQ $40, SP
      0x0013 00019 (swap.go:10) MOVQ BP, 32 (SP)
      0x0018 00024 (swap.go:10) LEAQ 32(SP), BP
      0x001d 00029 (swap.go:10) FUNCDATA $0, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)
      0x001d 00029 (swap.go:10) FUNCDATA $1, gclocals ·33cdeccccebe80329flfdbee7f5874cb(SB)
      0x001d 00029 (swap.go:11) MOVQ $10, (SP)
      0x0025 00037 (swap.go:11) MOVQ $20 , 8 (SP)
      0x002e 00046 (swap.go:11) PCDATA $0 , $0
      0x002e 00046 (swap.go:11) CALL "". swap(SB)
      0x0033 00051 (swap.go:12) MOVQ 32(SP), BP
      0x0038 00056 (swap.go:12) ADDQ $40, SP
      0x003c 00060 (swap.go:12) RET
      0x003d 00061 (swap.go:12) NOP
      0x003d 00061 (swap.go:10) PCDATA $0, $ - 1
```

- 第 5 行初始化返回值 x 为 0。

- 第 6 行初始化返回值 y 为 0。

- 第 7～8 行取第 2 个参数赋值给返回值 x。

- 第 9～10 行取第 1 个参数赋值给返回值 y。

- 第 11 行函数返回，同时进行栈回收，FUNCDATA 和垃圾收集可以忽略。

- 第 15～24 行 main 函数堆栈初始化：开辟栈空间，保存 BP 寄存器。

- 第 25 行初始化 add 函数的调用参数 1 的值为 10。

- 第 26 行初始化 add 函数的调用参数 2 的值为 20。

- 第 28 行调用 swap 函数，注意 call 隐含一个将 swap 下一条指令地址压栈的动作，即 sp=sp+8。

- 所以可以看到在 swap 里面的所有变量的相对位置都发生了变化，都在原来的地址上 ＋8。

- 第 29～30 行恢复措空间。

从汇编的代码得知：

- 函数的调用者负责环境准备，包括为参数和返回值开辟栈空间。

- 寄存器的保存和恢复也由调用方负责。

- 函数调用后回收栈空间，恢复 BP 也由主调函数负责。

函数的多值返回实质上是在栈上开辟多个地址分别存放返回值，这个并没有什么特别的地方，如果返回值是存放到堆上的，则多了一个复制的动作。

main 调用 swap 函数栈的结构如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/190806/4-1ZP61620152L.gif)](http://c.biancheng.net/uploads/allimg/190806/4-1ZP61620152L.gif)

图：Go 函数栈

函数调用前己经为返回值和参数分配了栈空间，分配顺序是从右向左的，先是返回值，然后是参数，通用的栈模型如下：

＋———-＋ | 返回值 y  | |————| | 返回值 x  | |————| | 参数 b   | |————| | 参数 a   | ＋———-＋

函数的多返回值是主调函数预先分配好空间来存放返回值，被调函数执行时将返回值复制到该返回位置来实现的。

#### 闭包底层实现

下面通过汇编和源码对照的方式看一下 Go 闭包的内部实现。

程序源码如下：

```go
  package main
  //函数返回引用了外部变量 i 的闭包
  func a(i int) func () {
      return func() {
          print(i)
      }
  }
  func main() {
      f := a (1)
      f ()
  }
```

编译汇编如下：

GOOS=linux GOARCH=amd64 go tool compile -S c2_7_4a.go >c2_7_4a.s 2&1

关键汇编代码及分析如下：

// 函数 a 和函数 main 对应的汇编代码

```go
  "".a STEXT size=91 args=0x10 locals=0x18
      0x0000 00000 (c2\_7\_4a.go:3) TEXT "".a(SB), $24-16
      0x0000 00000 (c2\_7\_4a.go:3) MOVQ (TLS), CX
      0x0009 00009 (c2\_7\_4a.go:3) CMPQ SP, 16(CX)
      0x000d 00013 (c2\_7\_4a.go:3) JLS 84
      0x000f 00015 (c2\_7\_4a.go:3) SUBQ $24, SP
      0x0013 00019 (c2\_7\_4a.go:3) MOVQ BP , 16(SP)
      0x0018 00024 (c2\_7\_4a.go:3) LEAQ 16(SP), BP
      0x001d 00029 (c2\_7\_4a.go:3) FUNCDATA $0, gclocals·f207267fbf96a0178e8758c6e3e0ce28(SB)
      0x001d 00029 (c2\_7\_4a.go:3) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb (SB)
      0x001d 00029 (c2\_7\_4a.go:4) LEAQ type.noalg.struct{ F uintptr; "".i int}(SB), AX
      0x0024 00036 (c2\_7\_4a.go:4) MOVQ AX, (SP)
      0x0028 00040 (c2\_7\_4a.go:4) PCDATA $0, $0
      0x0028 00040 (c2\_7\_4a.go:4) CALL runtime.newobject(SB)
      0x002d 00045 (c2\_7\_4a.go:4) MOVQ 8(SP), AX
      0x0032 00050 (c2\_7\_4a.go:4) LEAQ "".a.funcl(SB), CX
      0x0039 00057 (c2\_7\_4a.go:4) MOVQ CX, (AX)
      0x003c 00060 (c2\_7\_4a.go:3) MOVQ "".i+32(SP), CX
      0x0041 00065 (c2\_7\_4a.go:4) MOVQ CX, 8(AX)
      0x0045 00069 (c2\_7\_4a.go:4) MOVQ AX, "".~r1+40(SP)
      0x004a 00074 (c2\_7\_4a.go:4) MOVQ 16(SP), BP
      0x004f 00079 (c2\_7\_4a.go:4) ADDQ $24, SP
  "".main STEXT size=69 args=0x0 locals=0x18
      0x0000 00000 (c2\_7\_4a.go:9) TEXT "".main(SB), $24-0
      0x0000 00000 (c2\_7\_4a.go:9) MOVQ (TLS), CX
      0x0009 00009 (c2\_7\_4a.go:9) CMPQ SP, 16(CX)
      0x000d 00013 (c2\_7\_4a.go:9) JLS 62
      0x000f 00015 (c2\_7\_4a.go:9) SUBQ $24, SP
      0x0013 00019 (c2\_7\_4a.go:9) MOVQ BP, 16(SP)
      0x0018 00024 (c2\_7\_4a.go:9) LEAQ 16(SP), BP
      0x00ld 00029 (c2\_7\_4a.go:9) FUNCDATA $0, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)
      0x00ld 00029 (c2\_7\_4a.go:9) FUNCDATA $1, gclocals·33cdeccccebe80329flfdbee7f5874cb(SB)
      0x00ld 00029 (c2\_7\_4a.go:10) MOVQ $1, (SP)
      0x0025 00037 (c2\_7\_4a.go:10) PCDATA $0, $0
      0x0025 00037 (c2\_7\_4a.go:10) CALL "".a(SB)
      0x002a 00042 (c2\_7\_4a.go:10) MOVQ 8(SP), DX
      0x002f 00047 (c2\_7\_4a.go:11) MOVQ (DX), AX
      0x0032 00050 (c2\_7\_4a.go:11) PCDATA $0, $0
      0x0032 00050 (c2\_7\_4a.go:11) CALL AX
      0x0034 00052 (c2\_7\_4a.go:15) MOVQ 16(SP), BP
      0x0039 00057 (c2\_7\_4a.go:15) ADDQ $24, SP
      0x003d 00061 (c2\_7\_4a.go:15) RET
```

##### func a() 函数分析

- 第 1～10 行环境准备。

- 第 11 行这里我们看到`type.noalg.struct {F uintptr; "".i int}(SB)`这个符号是一个闭包类型的数据，闭包类型的数据结构如下：

type Closure struct {   F uintptr   i int }

闭包的结构很简单，一个是函数指针，另一个是对外部环境的引用。注意，这里仅仅是打印 i，并没有修改 i，Go 语言编译器并没有传递地址而是传递值。

- 第 11 行将闭包类型元信息放到 (SP) 位置，(SP) 地址存放的是 CALL 函数调用的第一个参数。

- 第 14 行创建闭包对象，我们来看一下 runtime.newobject 的函数原型，该函数的输入参数是一个类型信息，返回值是根据该类型信息构造出来的对象地址。

// src/runtime/malloc.go func newobject(typ *_type) unsafe.Pointer

- 第 15 行将 newobject 返回的对象地址复制给 AX 寄存器。

- 第 16 行将 a 函数里面的匿名函数 a.func 指针复制到 CX 寄存器。

- 第 17 行将 CX 寄存器中存放的 a.func 函数指针复制到闭包对象的函数指针位置。

- 第 18、19 行将外部闭包变量 i 的值复制到闭包对象的 i 处。

- 第 20 行复制闭包对象指针值到函数返回值位置 "".～r1+40(SP)。

##### main() 函数分析

- 第 23～32 行准备环境。
- 第 33 行将立即数 1 复制到 (SP) 位置，为后续的 CALL 指令准备参数。
- 第 35 行调用函数 a()。
- 第 36 行复制函数返回值到 DX 寄存器。
- 第 37 行间接寻址，复制闭包对象中的函数指针到 AX 寄存器。
- 第 39 行调用 AX 寄存器指向的函数。
- 第 40～42 行恢复环境，并返回。



通过汇编代码的分析，我们清楚地看到 Go 实现闭包是通过返回一个如下的结构来实现的。

```go
type Closure struct {F uintptr env *Type }
```

F 是返回的匿名函数指针，env 是对外部环境变量的引用集合，如果闭包内没有修改外部变量，则 Go 编译器直接优化为值传递，如上面的例子中的代码所示，反之则是通过指针传递的。

### 19. Test功能测试函数详解

Go语言自带了 testing 测试包，可以进行自动化的单元测试，输出结果验证，并且可以测试性能。

#### 为什么需要测试

完善的测试体系，能够提高开发的效率，当项目足够复杂的时候，想要保证尽可能的减少 bug，有两种有效的方式分别是代码审核和测试，Go语言中提供了 testing 包来实现单元测试功能。

#### 测试规则

要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时文件名必须以`_test.go`结尾，单元测试源码文件可以由多个测试用例（可以理解为函数）组成，每个测试用例的名称需要以 Test 为前缀，例如：

```go
func TestXxx( t *testing.T ){
  //......
}
```

编写测试用例有以下几点需要注意：

- 测试用例文件不会参与正常源码的编译，不会被包含到可执行文件中；
- 测试用例的文件名必须以`_test.go`结尾；
- 需要使用 import 导入 testing 包；
- 测试函数的名称要以`Test`或`Benchmark`开头，后面可以跟任意字母组成的字符串，但第一个字母必须大写，例如 TestAbc()，一个测试用例文件中可以包含多个测试函数；
- 单元测试则以`(t *testing.T)`作为参数，性能测试以`(t *testing.B)`做为参数；
- 测试用例文件使用`go test`命令来执行，源码中不需要 main() 函数作为入口，所有以`_test.go`结尾的源码文件内以`Test`开头的函数都会自动执行。


Go语言的 testing 包提供了三种测试方式，分别是单元（功能）测试、性能（压力）测试和覆盖率测试。

#### 单元（功能）测试

在同一文件夹下创建两个Go语言文件，分别命名为 demo.go 和 demt_test.go，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/191015/4-19101516392LR.gif)


具体代码如下所示：

##### demo.go：

```go
package demo
// 根据长宽获取面积
func GetArea(weight int, height int) int {
    return weight * height
}
```

##### demo_test.go：

```go
package demo
import "testing"
func TestGetArea(t *testing.T) {
    area := GetArea(40, 50)
    if area != 2000 {
        t.Error("测试失败")
    }
}
```

执行测试命令，运行结果如下所示：

```go
PS D:\code> go test -v
=== RUN  TestGetArea
--- PASS: TestGetArea (0.00s)
PASS
ok   _/D_/code    0.435s
```

#### 性能（压力）测试

将 demo_test.go 的代码改造成如下所示的样子：

```go
package demo
import "testing"
func BenchmarkGetArea(t *testing.B) {
    for i := 0; i < t.N; i++ {
        GetArea(40, 50)
    }
}
```

执行测试命令，运行结果如下所示：

```go
PS D:\code> go test -bench="."
goos: windows
goarch: amd64
BenchmarkGetArea-4   2000000000        0.35 ns/op
PASS
ok   _/D_/code    1.166s
```

上面信息显示了程序执行 2000000000 次，共耗时 0.35 纳秒。

#### 覆盖率测试

覆盖率测试能知道测试程序总共覆盖了多少业务代码（也就是 demo_test.go 中测试了多少 demo.go 中的代码），可以的话最好是覆盖100%。

将 demo_test.go 代码改造成如下所示的样子：

```go
package demo
import "testing"
func TestGetArea(t *testing.T) {
    area := GetArea(40, 50)
    if area != 2000 {
        t.Error("测试失败")
    }
}
func BenchmarkGetArea(t *testing.B) {
    for i := 0; i < t.N; i++ {
        GetArea(40, 50)
    }
}
```

执行测试命令，运行结果如下所示：

```go
PS D:\code> go test -cover
PASS
coverage: 100.0% of statements
ok   _/D_/code    0.437s
```



## 第六章 结构体

### 1. 结构体定义

Go语言可以通过自定义的方式形成新的类型，结构体就是这些类型中的一种复合类型，结构体是由零个或多个任意类型的值聚合成的实体，每个值都可以称为结构体的成员。

结构体成员也可以称为“字段”，这些字段有以下特性：

- 字段拥有自己的类型和值；
- 字段名必须唯一；
- 字段的类型也可以是结构体，甚至是字段所在结构体的类型。


使用关键字 **type** 可以将各种基本类型定义为自定义类型，基本类型包括整型、字符串、布尔等。结构体是一种复合的基本类型，通过 type 定义为自定义类型后，使结构体更便于使用。

结构体的定义格式如下：

```go
type 类型名 struct {
  字段1 字段1类型
  字段2 字段2类型
  …
}
```

对各个部分的说明：

- 类型名：标识自定义结构体的名称，在同一个包内不能重复。
- struct{}：表示结构体类型，`type 类型名 struct{}`可以理解为将 struct{} 结构体定义为类型名的类型。
- 字段1、字段2……：表示结构体字段名，结构体中的字段名必须唯一。
- 字段1类型、字段2类型……：表示结构体各个字段的类型。


使用结构体可以表示一个包含 X 和 Y 整型分量的点结构，代码如下：

```go
type Point struct {
    X int
    Y int
}
```

同类型的变量也可以写在一行，颜色的红、绿、蓝 3 个分量可以使用 byte 类型表示，定义的颜色结构体如下：

```go
type Color struct {
    R, G, B byte
}
```

结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，我们将在下一节《[实例化结构体](http://c.biancheng.net/view/66.html)》中详细为大家介绍。

### 2. 实例化结构体——为结构体分配内存并初始化

结构体的定义只是一种内存布局的描述，只有当结构体实例化时，才会真正地分配内存，因此必须在定义结构体并实例化后才能使用结构体的字段。

实例化就是根据结构体定义的格式创建一份与格式一致的内存区域，结构体实例与实例间的内存是完全独立的。

Go语言可以通过多种方式实例化结构体，根据实际需要可以选用不同的写法。

#### 基本的实例化形式

结构体本身是一种类型，可以像整型、字符串等类型一样，以 var 的方式声明结构体即可完成实例化。

基本实例化格式如下：

```go
var ins T
```

其中，T 为结构体类型，ins 为结构体的实例。

用结构体表示的点结构（Point）的实例化过程请参见下面的代码：

```go
type Point struct {
    X int
    Y int
}
var p Point
p.X = 10
p.Y = 20
```

在例子中，使用`.`来访问结构体的成员变量，如`p.X`和`p.Y`等，结构体成员变量的赋值方法与普通变量一致。

#### 创建指针类型的结构体

Go语言中，还可以使用 new 关键字对类型（包括结构体、整型、浮点数、字符串等）进行实例化，结构体在实例化后会形成指针类型的结构体。

使用 new 的格式如下：

```go
ins := new(T)
```

其中：

- T 为类型，可以是结构体、整型、字符串等。
- ins：T 类型被实例化后保存到 ins 变量中，ins 的类型为 *T，属于指针。


Go语言让我们可以像访问普通结构体一样使用`.`来访问结构体指针的成员。

下面的例子定义了一个玩家（Player）的结构，玩家拥有名字、生命值和魔法值，实例化玩家（Player）结构体后，可对成员进行赋值，代码如下：

```go
type Player struct{
    Name string
    HealthPoint int
    MagicPoint int
}
tank := new(Player)
tank.Name = "Canon"
tank.HealthPoint = 300
```

经过 new 实例化的结构体实例在成员赋值上与基本实例化的写法一致。

##### Go语言和 C/[C++](http://c.biancheng.net/cplus/)

在 C/C++ 语言中，使用 new 实例化类型后，访问其成员变量时必须使用`->`操作符。

在Go语言中，访问结构体指针的成员变量时可以继续使用`.`，这是因为Go语言为了方便开发者访问结构体指针的成员变量，使用了语法糖（Syntactic sugar）技术，将 ins.Name 形式转换为 (*ins).Name。

#### 取结构体的地址实例化

在Go语言中，对结构体进行`&`取地址操作时，视为对该类型进行一次 new 的实例化操作，取地址格式如下：

```go
ins := &T{}
```

其中：

- T 表示结构体类型。
- ins 为结构体的实例，类型为 *T，是指针类型。


下面使用结构体定义一个命令行指令（Command），指令中包含名称、变量关联和注释等，对 Command 进行指针地址的实例化，并完成赋值过程，代码如下：

```go
type Command struct {
    Name    string    // 指令名称
    Var     *int      // 指令绑定的变量
    Comment string    // 指令的注释
}
var version int = 1
cmd := &Command{}
cmd.Name = "version"
cmd.Var = &version
cmd.Comment = "show version"
```

代码说明如下：

- 第 1 行，定义 Command 结构体，表示命令行指令
- 第 3 行，命令绑定的变量，使用整型指针绑定一个指针，指令的值可以与绑定的值随时保持同步。
- 第 7 行，命令绑定的目标整型变量：版本号。
- 第 9 行，对结构体取地址实例化。
- 第 10～12 行，初始化成员字段。


取地址实例化是最广泛的一种结构体实例化方式，可以使用函数封装上面的初始化过程，代码如下：

```go
func newCommand(name string, varref *int, comment string) *Command {
    return &Command{
        Name:    name,
        Var:     varref,
        Comment: comment,
    }
}
cmd = newCommand(
    "version",
    &version,
    "show version",
)
```



### 3. 初始化结构体的成员变量

结构体在实例化时可以直接对成员变量进行初始化，初始化有两种形式分别是以字段“键值对”形式和多个值的列表形式，键值对形式的初始化适合选择性填充字段较多的结构体，多个值的列表形式适合填充字段较少的结构体。

#### 使用“键值对”初始化结构体

结构体可以使用“键值对”（Key value pair）初始化字段，每个“键”（Key）对应结构体中的一个字段，键的“值”（Value）对应字段需要初始化的值。

键值对的填充是可选的，不需要初始化的字段可以不填入初始化列表中。

结构体实例化后字段的默认值是字段类型的默认值，例如 ，数值为 0、字符串为 ""（空字符串）、布尔为 false、指针为 nil 等。

##### 1) 键值对初始化结构体的书写格式

键值对初始化的格式如下：

```go
ins := 结构体类型名{
    字段1: 字段1的值,
    字段2: 字段2的值,
    …
}
```

下面是对各个部分的说明：

- 结构体类型：定义结构体时的类型名称。
- 字段1、字段2：结构体成员的字段名，结构体类型名的字段初始化列表中，字段名只能出现一次。
- 字段1的值、字段2的值：结构体成员字段的初始值。


键值之间以`:`分隔，键值对之间以`,`分隔。

##### 2) 使用键值对填充结构体的例子

下面示例中描述了家里的人物关联，正如儿歌里唱的：“爸爸的爸爸是爷爷”，人物之间可以使用多级的 child 来描述和建立关联，使用键值对形式填充结构体的代码如下：

```go
type People struct {
    name  string
    child *People
}
relation := &People{
    name: "爷爷",
    child: &People{
        name: "爸爸",
        child: &People{
                name: "我",
        },
    },
}
```

代码说明如下：

- 第 1 行，定义 People 结构体。
- 第 2 行，结构体的字符串字段。
- 第 3 行，结构体的结构体指针字段，类型是 *People。
- 第 6 行，relation 由 People 类型取地址后，形成类型为 *People 的实例。
- 第 8 行，child 在初始化时，需要 *People 类型的值，使用取地址初始化一个 People。

> 提示：结构体成员中只能包含结构体的指针类型，包含非指针类型会引起编译错误。

#### 使用多个值的列表初始化结构体

Go语言可以在“键值对”初始化的基础上忽略“键”，也就是说，可以使用多个值的列表初始化结构体的字段。

##### 1) 多个值列表初始化结构体的书写格式

多个值使用逗号分隔初始化结构体，例如：

```go
ins := 结构体类型名{
  字段1的值,
  字段2的值,
  …
}
```

使用这种格式初始化时，需要注意：

- 必须初始化结构体的所有字段。
- 每一个初始值的填充顺序必须与字段在结构体中的声明顺序一致。
- 键值对与值列表的初始化形式不能混用。

##### 2) 多个值列表初始化结构体的例子

下面的例子描述了一段地址结构，地址要求具有一定的顺序，例如：

```go
type Address struct {
    Province    string
    City        string
    ZipCode     int
    PhoneNumber string
}
addr := Address{
    "四川",
    "成都",
    610000,
    "0",
}
fmt.Println(addr)
```

运行代码，输出如下：

```json
{四川 成都 610000 0}
```

#### 初始化匿名结构体

匿名结构体没有类型名称，无须通过 type 关键字定义就可以直接使用。

##### 1) 匿名结构体定义格式和初始化写法

匿名结构体的初始化写法由结构体定义和键值对初始化两部分组成，结构体定义时没有结构体类型名，只有字段和类型定义，键值对初始化部分由可选的多个键值对组成，如下格式所示：

```go
ins := struct {
  // 匿名结构体字段定义
  字段1 字段类型1
  字段2 字段类型2
  …
}{
  // 字段值初始化
  初始化字段1: 字段1的值,
  初始化字段2: 字段2的值,
  …
}
```

下面是对各个部分的说明：

- 字段1、字段2……：结构体定义的字段名。
- 初始化字段1、初始化字段2……：结构体初始化时的字段名，可选择性地对字段初始化。
- 字段类型1、字段类型2……：结构体定义字段的类型。
- 字段1的值、字段2的值……：结构体初始化字段的初始值。


键值对初始化部分是可选的，不初始化成员时，匿名结构体的格式变为：

```go
ins := struct {
  字段1 字段类型1
  字段2 字段类型2
  …
}
```

##### 2) 使用匿名结构体的例子

在本示例中，使用匿名结构体的方式定义和初始化一个消息结构，这个消息结构具有消息标示部分（ID）和数据部分（data），打印消息内容的 printMsg() 函数在接收匿名结构体时需要在参数上重新定义匿名结构体，代码如下：

```go
package main
import (
    "fmt"
)
// 打印消息类型, 传入匿名结构体
func printMsgType(msg *struct {
    id   int
    data string
}) {
    // 使用动词%T打印msg的类型
    fmt.Printf("%T\n", msg)
}
func main() {
    // 实例化一个匿名结构体
    msg := &struct {  // 定义部分
        id   int
        data string
    }{  // 值初始化部分
        1024,
        "hello",
    }
    printMsgType(msg)
}
```

代码输出如下：

```go
*struct { id int; data string }
```

代码说明如下：

- 第 8 行，定义 printMsgType() 函数，参数为 msg，类型为`*struct{id int data string}`，因为类型没有使用 type 定义，所以需要在每次用到的地方进行定义。
- 第 14 行，使用字符串格式化中的`%T`动词，将 msg 的类型名打印出来。
- 第 20 行，对匿名结构体进行实例化，同时初始化成员。
- 第 21 和 22 行，定义匿名结构体的字段。
- 第 24 和 25 行，给匿名结构体字段赋予初始值。
- 第 28 行，将 msg 传入 printMsgType() 函数中进行函数调用。

匿名结构体的类型名是结构体包含字段成员的详细描述，匿名结构体在使用时需要重新定义，造成大量重复的代码，因此开发中较少使用。



### 4. 构造函数

Go语言的类型或结构体没有构造函数的功能，但是我们可以使用结构体初始化的过程来模拟实现构造函数。

其他编程语言构造函数的一些常见功能及特性如下：

- 每个类可以添加构造函数，多个构造函数使用函数重载实现。
- 构造函数一般与类名同名，且没有返回值。
- 构造函数有一个静态构造函数，一般用这个特性来调用父类的构造函数。
- 对于 [C++](http://c.biancheng.net/cplus/) 来说，还有默认构造函数、拷贝构造函数等。

#### 多种方式创建和初始化结构体——模拟构造函数重载

如果使用结构体描述猫的特性，那么根据猫的颜色和名字可以有不同种类的猫，那么不同的颜色和名字就是结构体的字段，同时可以使用颜色和名字构造不同种类的猫的实例，这个过程可以参考下面的代码：

```go
type Cat struct {
    Color string
    Name  string
}
func NewCatByName(name string) *Cat {
    return &Cat{
        Name: name,
    }
}
func NewCatByColor(color string) *Cat {
    return &Cat{
        Color: color,
    }
}
```

代码说明如下：

- 第 1 行定义 Cat 结构，包含颜色和名字字段。
- 第 6 行定义用名字构造猫结构的函数，返回 Cat 指针。
- 第 7 行取地址实例化猫的结构体。
- 第 8 行初始化猫的名字字段，忽略颜色字段。
- 第 12 行定义用颜色构造猫结构的函数，返回 Cat 指针。


在这个例子中，颜色和名字两个属性的类型都是字符串，由于Go语言中没有函数重载，为了避免函数名字冲突，使用 NewCatByName() 和 NewCatByColor() 两个不同的函数名表示不同的 Cat 构造过程。

#### 带有父子关系的结构体的构造和初始化——模拟父级构造调用

黑猫是一种猫，猫是黑猫的一种泛称，同时描述这两种概念时，就是派生，黑猫派生自猫的种类，使用结构体描述猫和黑猫的关系时，将猫（Cat）的结构体嵌入到黑猫（BlackCat）中，表示黑猫拥有猫的特性，然后再使用两个不同的构造函数分别构造出黑猫和猫两个结构体实例，参考下面的代码：

```go
type Cat struct {
    Color string
    Name  string
}
type BlackCat struct {
    Cat  // 嵌入Cat, 类似于派生
}
// “构造基类”
func NewCat(name string) *Cat {
    return &Cat{
        Name: name,
    }
}
// “构造子类”
func NewBlackCat(color string) *BlackCat {
    cat := &BlackCat{}
    cat.Color = color
    return cat
}
```

代码说明如下：

- 第 6 行，定义 BlackCat 结构，并嵌入了 Cat 结构体，BlackCat 拥有 Cat 的所有成员，实例化后可以自由访问 Cat 的所有成员。
- 第 11 行，NewCat() 函数定义了 Cat 的构造过程，使用名字作为参数，填充 Cat 结构体。
- 第 18 行，NewBlackCat() 使用 color 作为参数，构造返回 BlackCat 指针。
- 第 19 行，实例化 BlackCat 结构，此时 Cat 也同时被实例化。
- 第 20 行，填充 BlackCat 中嵌入的 Cat 颜色属性，BlackCat 没有任何成员，所有的成员都来自于 Cat。


这个例子中，Cat 结构体类似于面向对象中的“基类”，BlackCat 嵌入 Cat 结构体，类似于面向对象中的“派生”，实例化时，BlackCat 中的 Cat 也会一并被实例化。

总之，Go语言中没有提供构造函数相关的特殊机制，用户根据自己的需求，将参数使用函数传递到结构体构造参数中即可完成构造函数的任务。

### 5. 方法和接收器

在 Go 语言中，结构体就像是类的一种简化形式，那么类的方法在哪里呢？在 Go 语言中有一个概念，它和方法有着同样的名字，并且大体上意思相同，Go 方法是作用在接收器（receiver）上的一个函数，接收器是某种类型的变量，因此方法是一种特殊类型的函数。

接收器类型可以是（几乎）任何类型，不仅仅是结构体类型，任何类型都可以有方法，甚至可以是函数类型，可以是 int、bool、string 或数组的别名类型，但是接收器不能是一个接口类型，因为接口是一个抽象定义，而方法却是具体实现，如果这样做了就会引发一个编译错误`invalid receiver type…`。

接收器也不能是一个指针类型，但是它可以是任何其他允许类型的指针，一个类型加上它的方法等价于面向对象中的一个类，一个重要的区别是，在 Go 语言中，类型的代码和绑定在它上面的方法的代码可以不放置在一起，它们可以存在不同的源文件中，唯一的要求是它们必须是同一个包的。

类型 T（或 T）上的所有方法的集合叫做类型 T（或 T）的方法集。

因为方法是函数，所以同样的，不允许方法重载，即对于一个类型只能有一个给定名称的方法，但是如果基于接收器类型，是有重载的：具有同样名字的方法可以在 2 个或多个不同的接收器类型上存在，比如在同一个包里这么做是允许的。

#### 提示

在面向对象的语言中，类拥有的方法一般被理解为类可以做的事情。在 Go 语言中 “方法” 的概念与其他语言一致，只是 Go 语言建立的 “接收器” 强调方法的作用对象是接收器，也就是类实例，而函数没有作用对象。

#### 为结构体添加方法

本节中，将会使用背包作为 “对象”，将物品放入背包的过程作为“方法”，通过面向过程的方式和 Go 语言中结构体的方式来理解“方法” 的概念。

##### 1) 面向过程实现方法

面向过程中没有 “方法” 概念，只能通过结构体和函数，由使用者使用函数参数和调用关系来形成接近 “方法” 的概念，代码如下：

```go
  type Bag struct {
      items []int
  }

  // 将一个物品放入背包的过程
  func Insert(b *Bag, itemid int) {
      b.items = append(b.items, itemid)
  }

  func main() {

      bag := new(Bag)

      Insert(bag, 1001)
  }
```

代码说明如下：

- 第 1 行，声明 Bag 结构，这个结构体包含一个整型切片类型的 items 的成员。

- 第 6 行，定义了 Insert() 函数，这个函数拥有两个参数，第一个是背包指针（*Bag），第二个是物品 ID（itemid）。

- 第 7 行，用 append() 将 itemid 添加到 Bag 的 items 成员中，模拟往背包添加物品的过程。

- 第 12 行，创建背包实例 bag。

- 第 14 行，调用 Insert() 函数，第一个参数放入背包，第二个参数放入物品 ID。

Insert() 函数将 *Bag 参数放在第一位，强调 Insert 会操作 *Bag 结构体，但实际使用中，并不是每个人都会习惯将操作对象放在首位，一定程度上让代码失去一些范式和描述性。同时，Insert() 函数也与 Bag 没有任何归属概念，随着类似 Insert() 的函数越来越多，面向过程的代码描述对象方法概念会越来越麻烦和难以理解。

##### 2) Go 语言的结构体方法

将背包及放入背包的物品中使用 Go 语言的结构体和方法方式编写，为 *Bag 创建一个方法，代码如下：

```go
  type Bag struct {
      items []int
  }

  func (b *Bag) Insert(itemid int) {
      b.items = append(b.items, itemid)
  }

  func main() {

      b := new(Bag)

      b.Insert(1001)
  }
```

第 5 行中，Insert(itemid int) 的写法与函数一致，(b*Bag) 表示接收器，即 Insert 作用的对象实例。

每个方法只能有一个接收器，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5135I3337.jpg)](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5135I3337.jpg)

图：接收器

第 13 行中，在 Insert() 转换为方法后，我们就可以愉快地像其他语言一样，用面向对象的方法来调用 b 的 Insert。

#### 接收器——方法作用的目标

接收器的格式如下：

func (接收器变量 接收器类型) 方法名 (参数列表) (返回参数) {   函数体 }

对各部分的说明：

- 接收器变量：接收器中的参数变量名在命名时，官方建议使用接收器类型名的第一个小写字母，而不是 self、this 之类的命名。例如，Socket 类型的接收器变量应该命名为 s，Connector 类型的接收器变量应该命名为 c 等。

- 接收器类型：接收器类型和参数类似，可以是指针类型和非指针类型。

- 方法名、参数列表、返回参数：格式与函数定义一致。

接收器根据接收器的类型可以分为指针接收器、非指针接收器，两种接收器在使用时会产生不同的效果，根据效果的不同，两种接收器会被用于不同性能和功能要求的代码中。

#### 1) 理解指针类型的接收器

指针类型的接收器由一个结构体的指针组成，更接近于面向对象中的 this 或者 self。

由于指针的特性，调用方法时，修改接收器指针的任意成员变量，在方法结束后，修改都是有效的。

在下面的例子，使用结构体定义一个属性（Property），为属性添加 SetValue() 方法以封装设置属性的过程，通过属性的 Value() 方法可以重新获得属性的数值，使用属性时，通过 SetValue() 方法的调用，可以达成修改属性值的效果。

```go
  package main

  import "fmt"

  // 定义属性结构
  type Property struct {
      value int  // 属性值
  }

  // 设置属性值
  func (p *Property) SetValue(v int) {

      // 修改p的成员变量
      p.value = v
  }

  // 取属性值
  func (p *Property) Value() int {
      return p.value
  }

  func main() {

      // 实例化属性
      p := new(Property)

      // 设置值
      p.SetValue(100)

      // 打印值
      fmt.Println(p.Value())

  }
```

运行程序，输出如下：

```go
100
```

代码说明如下：

- 第 6 行，定义一个属性结构，拥有一个整型的成员变量。

- 第 11 行，定义属性值的方法。

- 第 14 行，设置属性值方法的接收器类型为指针，因此可以修改成员值，即便退出方法，也有效。

- 第 18 行，定义获取值的方法。

- 第 25 行，实例化属性结构。

- 第 28 行，设置值，此时成员变量变为 100。

- 第 31 行，获取成员变量。

##### 2) 理解非指针类型的接收器

当方法作用于非指针接收器时，Go 语言会在代码运行时将接收器的值复制一份，在非指针接收器的方法中可以获取接收器的成员值，但修改后无效。

点（Point）使用结构体描述时，为点添加 Add() 方法，这个方法不能修改 Point 的成员 X、Y 变量，而是在计算后返回新的 Point 对象，Point 属于小内存对象，在函数返回值的复制过程中可以极大地提高代码运行效率，详细过程请参考下面的代码。

```go
  package main

  import (
      "fmt"
  )

  // 定义点结构
  type Point struct {
      X int
      Y int
  }

  // 非指针接收器的加方法
  func (p Point) Add(other Point) Point {

      // 成员值与参数相加后返回新的结构
      return Point{p.X + other.X, p.Y + other.Y}
  }

  func main() {

      // 初始化点
      p1 := Point{1, 1}
      p2 := Point{2, 2}

      // 与另外一个点相加
      result := p1.Add(p2)

      // 输出结果
      fmt.Println(result)

  }
```

代码输出如下：

```go
{3 3}
```

代码说明如下：

- 第 8 行，定义一个点结构，拥有 X 和 Y 两个整型分量。

- 第 14 行，为 Point 结构定义一个 Add() 方法，传入和返回都是点的结构，可以方便地实现多个点连续相加的效果，例如`P4 := P1.Add(P2).Add( P3 )`

- 第 23 和 24 行，初始化两个点 p1 和 p2。

- 第 27 行，将 p1 和 p2 相加后返回结果。

- 第 30 行，打印结果。

由于例子中使用了非指针接收器，Add() 方法变得类似于只读的方法，Add() 方法内部不会对成员进行任何修改。

##### 3) 指针和非指针接收器的使用

在计算机中，小对象由于值复制时的速度较快，所以适合使用非指针接收器，大对象因为复制性能较低，适合使用指针接收器，在接收器和参数间传递时不进行复制，只是传递指针。

#### 示例：二维矢量模拟玩家移动

在游戏中，一般使用二维矢量保存玩家的位置，使用矢量运算可以计算出玩家移动的位置，本例子中，首先实现二维矢量对象，接着构造玩家对象，最后使用矢量对象和玩家对象共同模拟玩家移动的过程。

##### 1) 实现二维矢量结构

矢量是数学中的概念，二维矢量拥有两个方向的信息，同时可以进行加、减、乘（缩放）、距离、单位化等计算，在计算机中，使用拥有 X 和 Y 两个分量的 Vec2 结构体实现数学中二维向量的概念，详细实现请参考下面的代码。

```go
  package main

  import "math"

  type Vec2 struct {
      X, Y float32
  }

  // 加
  func (v Vec2) Add(other Vec2) Vec2 {

      return Vec2{
          v.X + other.X,
          v.Y + other.Y,
      }

  }

  // 减
  func (v Vec2) Sub(other Vec2) Vec2 {

      return Vec2{
          v.X - other.X,
          v.Y - other.Y,
      }
  }

  // 乘
  func (v Vec2) Scale(s float32) Vec2 {

      return Vec2{v.X * s, v.Y * s}
  }

  // 距离
  func (v Vec2) DistanceTo(other Vec2) float32 {
      dx := v.X - other.X
      dy := v.Y - other.Y

      return float32(math.Sqrt(float64(dx*dx + dy*dy)))
  }

  // 插值
  func (v Vec2) Normalize() Vec2 {
      mag := v.X*v.X + v.Y*v.Y
      if mag > 0 {
          oneOverMag := 1 / float32(math.Sqrt(float64(mag)))
          return Vec2{v.X * oneOverMag, v.Y * oneOverMag}
      }

      return Vec2{0, 0}
  }
```

代码说明如下：

- 第 5 行声明了一个 Vec2 结构体，包含两个方向的单精度浮点数作为成员。

- 第 10～16 行定义了 Vec2 的 Add() 方法，使用自身 Vec2 和通过 Add() 方法传入的 Vec2 进行相加，相加后，结果以返回值形式返回，不会修改 Vec2 的成员。

- 第 20 行定义了 Vec2 的减法操作。

- 第 29 行，缩放或者叫矢量乘法，是对矢量的每个分量乘上缩放比，Scale() 方法传入一个参数同时乘两个分量，表示这个缩放是一个等比缩放。

- 第 35 行定义了计算两个矢量的距离，math.Sqrt() 是开方函数，参数是 float64，在使用时需要转换，返回值也是 float64，需要转换回 float32。

- 第 43 行定义矢量单位化。

##### 2) 实现玩家对象

玩家对象负责存储玩家的当前位置、目标位置和速度，使用 MoveTo() 方法为玩家设定移动的目标，使用 Update() 方法更新玩家位置，在 Update() 方法中，通过一系列的矢量计算获得玩家移动后的新位置，步骤如下。

① 使用矢量减法，将目标位置（targetPos）减去当前位置（currPos）即可计算出位于两个位置之间的新矢量，如下图所示。

![](https://tva1.sinaimg.cn/large/008i3skNly1guu0wcsweij60e8053t8q02.jpg)

图：计算玩家方向矢量

② 使用 Normalize() 方法将方向矢量变为模为 1 的单位化矢量，这里需要将矢量单位化后才能进行后续计算，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5143040939.jpg)](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5143040939.jpg)

图：单位化方向矢量

③ 获得方向后，将单位化方向矢量根据速度进行等比缩放，速度越快，速度数值越大，乘上方向后生成的矢量就越长（模很大），如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5154603618.jpg)](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5154603618.jpg)

图：根据速度缩放方向

④ 将缩放后的方向添加到当前位置后形成新的位置，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5154J31V.jpg)](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5154J31V.jpg)

图：缩放后的方向叠加位置形成新位置

下面是玩家对象的具体代码：

```go
  package main

  type Player struct {
      currPos   Vec2    // 当前位置
      targetPos Vec2    // 目标位置
      speed     float32 // 移动速度
  }

  // 移动到某个点就是设置目标位置
  func (p *Player) MoveTo(v Vec2) {

      p.targetPos = v
  }

  // 获取当前的位置
  func (p *Player) Pos() Vec2 {
      return p.currPos
  }

  // 是否到达
  func (p *Player) IsArrived() bool {

      // 通过计算当前玩家位置与目标位置的距离不超过移动的步长，判断已经到达目标点
      return p.currPos.DistanceTo(p.targetPos) < p.speed
  }

  // 逻辑更新
  func (p *Player) Update() {

      if !p.IsArrived() {

          // 计算出当前位置指向目标的朝向
          dir := p.targetPos.Sub(p.currPos).Normalize()

          // 添加速度矢量生成新的位置
          newPos := p.currPos.Add(dir.Scale(p.speed))

          // 移动完成后，更新当前位置
          p.currPos = newPos
      }

  }

  // 创建新玩家
  func NewPlayer(speed float32) *Player {

      return &Player{
          speed: speed,
      }
  }
```

代码说明如下：

- 第 3 行，结构体 Player 定义了一个玩家的基本属性和方法，结构体的 currPos 表示当前位置，speed 表示速度。

- 第 10 行，定义玩家的移动方法，逻辑层通过这个函数告知玩家要去的目标位置，随后的移动过程由 Update() 方法负责。

- 第 15 行，使用 Pos 方法实现玩家 currPos 的属性访问封装。

- 第 20 行，判断玩家是否到达目标点，玩家每次移动的半径就是速度（speed），因此，如果与目标点的距离小于速度，表示已经非常靠近目标，可以视为到达目标。

- 第 27 行，玩家移动时位置更新的主要实现。

- 第 29 行，如果已经到达，则不必再更新。

- 第 32 行，数学中，两矢量相减将获得指向被减矢量的新矢量，Sub() 方法返回的新矢量使用 Normalize() 方法单位化，最终返回的 dir 矢量就是移动方向。

- 第 35 行，在当前的位置上叠加根据速度缩放的方向计算出新的位置 newPos。

- 第 38 行，将新位置更新到 currPos，为下一次移动做准备。

- 第 44 行，玩家的构造函数，创建一个玩家实例需要传入一个速度值。

##### 3) 处理移动逻辑

将 Player 实例化后，设定玩家移动的最终目标点，之后开始进行移动的过程，这是一个不断更新位置的循环过程，每次检测玩家是否靠近目标点附近，如果还没有到达，则不断地更新位置，让玩家朝着目标点不停的修改当前位置，如下代码所示：

```go
  package main

  import "fmt"

  func main() {

      // 实例化玩家对象，并设速度为0.5
      p := NewPlayer(0.5)

      // 让玩家移动到3,1点
      p.MoveTo(Vec2{3, 1})

      // 如果没有到达就一直循环
      for !p.IsArrived() {

          // 更新玩家位置
          p.Update()

          // 打印每次移动后的玩家位置
          fmt.Println(p.Pos())
      }

  }
```

代码说明如下：

- 第 8 行，使用 NewPlayer() 函数构造一个 *Player 玩家对象，并设移动速度为 0.5，速度本身是一种相对的和抽象的概念，在这里没有单位，可以根据实际效果进行调整，达到合适的范围即可。

- 第 11 行，设定玩家移动的最终目标为 X 为 3，Y 为 1。

- 第 14 行，构造一个循环，条件是没有到达时一直循环。

- 第 17 行，不停地更新玩家位置，如果玩家到达目标，p.IsArrived 将会变为 true。

- 第 20 行，打印每次更新后玩家的位置。

本例中使用到了结构体的方法、构造函数、指针和非指针类型方法接收器等，读者通过这个例子可以了解在哪些地方能够使用结构体。

### 6. 为任意类型添加方法

Go 语言可以对任何类型添加方法，给一种类型添加方法就像给结构体添加方法一样，因为结构体也是一种类型。

#### 为基本类型添加方法

在 Go 语言中，使用 type 关键字可以定义出新的自定义类型，之后就可以为自定义类型添加各种方法了。我们习惯于使用面向过程的方式判断一个值是否为 0，例如：

如果将 v 当做整型对象，那么判断 v 值就可以增加一个 IsZero() 方法，通过这个方法就可以判断 v 值是否为 0，例如：

为基本类型添加方法的详细实现流程如下：

```go
  package main

  import (
      "fmt"
  )

  // 将int定义为MyInt类型
  type MyInt int

  // 为MyInt添加IsZero()方法
  func (m MyInt) IsZero() bool {
      return m == 0
  }

  // 为MyInt添加Add()方法
  func (m MyInt) Add(other int) int {
      return other + int(m)
  }

  func main() {

      var b MyInt

      fmt.Println(b.IsZero())

      b = 1

      fmt.Println(b.Add(2))
  }
```

代码输出如下：

```go
true 3
```

代码说明如下：

- 第 8 行，使用 type MyInt int 将 int 定义为自定义的 MyInt 类型。

- 第 11 行，为 MyInt 类型添加 IsZero() 方法，该方法使用了 (m MyInt) 的非指针接收器，数值类型没有必要使用指针接收器。

- 第 16 行，为 MyInt 类型添加 Add() 方法。

- 第 17 行，由于 m 的类型是 MyInt 类型，但其本身是 int 类型，因此可以将 m 从 MyInt 类型转换为 int 类型再进行计算。

- 第 24 行，调用 b 的 IsZero() 方法，由于使用非指针接收器，b 的值会被复制进入 IsZero() 方法进行判断。

- 第 28 行，调用 b 的 Add() 方法，同样也是非指针接收器，结果直接通过 Add() 方法返回。

#### http 包中的类型方法

Go 语言提供的 http 包里也大量使用了类型方法，Go 语言使用 http 包进行 HTTP 的请求，使用 http 包的 NewRequest() 方法可以创建一个 HTTP 请求，填充请求中的 http 头（req.Header），再调用 http.Client 的 Do 方法，将传入的 HTTP 请求发送出去。

下面代码演示创建一个 HTTP 请求，并且设定 HTTP 头。

```go
  package main

  import (
      "fmt"
      "io/ioutil"
      "net/http"
      "os"
      "strings"
  )

  func main() {
      client := &http.Client{}

      // 创建一个http请求
      req, err := http.NewRequest("POST", "http://www.163.com/", strings.NewReader("key=value"))

      // 发现错误就打印并退出
      if err != nil {
          fmt.Println(err)
          os.Exit(1)
          return
      }

      // 为标头添加信息
      req.Header.Add("User-Agent", "myClient")

      // 开始请求
      resp, err := client.Do(req)

      // 处理请求的错误
      if err != nil {
          fmt.Println(err)
          os.Exit(1)
          return
      }

      data, err := ioutil.ReadAll(resp.Body)
      fmt.Println(string(data))

      defer resp.Body.Close()

  }
```

代码执行结果如下：

#### 405 Not Allowed

------

nginx

代码说明如下：

- 第 11 行，实例化 HTTP 的客户端，请求需要通过这个客户端实例发送。

- 第 14 行，使用 POST 方式向网易的服务器创建一个 HTTP 请求，第三个参数为 HTTP 的 Body 部分，Body 部分的内容来自字符串，但参数只能接受 io.Reader 类型，因此使用 strings.NewReader() 创建一个字符串的读取器，返回的 io.Reader 接口作为 http 的 Body 部分供 NewRequest() 函数读取，创建请求只是构造一个请求对象，不会连接网络。

- 第 24 行，为创建好的 HTTP 请求的头部添加 User-Agent，作用是表明用户的代理特性。

- 第 27 行，使用客户端处理请求，此时 client 将 HTTP 请求发送到网易服务器，服务器响应请求后，将信息返回并保存到 resp 变量中。

- 第 37 行，读取响应的 Body 部分并打印。

由于我们构造的请求不是网易服务器所支持的类型，所以服务器返回操作不被运行的 405 错误。

在本例子第 24 行中使用的 req.Header 的类型为 http.Header，就是典型的自定义类型，并且拥有自己的方法，http.Header 的部分定义如下：

```go
  type Header map[string][]string

  func (h Header) Add(key, value string) {
      textproto.MIMEHeader(h).Add(key, value)
  }

  func (h Header) Set(key, value string) {
      textproto.MIMEHeader(h).Set(key, value)
  }

  func (h Header) Get(key string) string {
      return textproto.MIMEHeader(h).Get(key)
  }
```

代码说明如下：

- 第 1 行，Header 实际是一个以字符串为键、字符串切片为值的映射。

- 第 3 行，Add() 为 Header 的方法，map 是一个引用类型，因此即便使用 (h Header) 的非指针接收器，也可以修改 map 的值。

为类型添加方法的过程是一个语言层特性，使用类型方法的代码经过编译器编译后的代码运行效率与传统的面向过程或面向对象的代码没有任何区别，因此，为了代码便于理解，可以在编码时使用 Go 语言的类型方法特性。

#### time 包中的类型方法

Go 语言提供的 time 包主要用于时间的获取和计算等，在这个包中，也使用了类型方法，例如：

```go
  package main

  import (
      "fmt"
      "time"
  )

  func main() {
      fmt.Println(time.Second.String())
  }
```

第 9 行的 time.Second 是一个常量，下面代码的加粗部分就是 time.Second 的定义：

```go
  const (
      Nanosecond  Duration = 1
      Microsecond  = 1000 * Nanosecond
      Millisecond  = 1000 * Microsecond
      **Second     = 1000 * Millisecond**
      Minute       = 60 * Second
      Hour         = 60 * Minute
  )
```

Second 的类型为 Duration，而 Duration 实际是一个 int64 的类型，定义如下：

```go
type Duration int64
```

它拥有一个 String 的方法，部分定义如下：

```go
  func (d Duration) String() string {

      // 一系列生成buf的代码
      …

      return string(buf[w:])
  }
```

Duration.String 可以将 Duration 的值转为字符串。

### 7. 使用事件系统实现事件的响应和处理

Go 语言可以将类型的方法与普通函数视为一个概念，从而简化方法和函数混合作为回调类型时的复杂性。这个特性和 C# 中的代理（delegate）类似，调用者无须关心谁来支持调用，系统会自动处理是否调用普通函数或类型的方法。

本节中，首先将用简单的例子了解 Go 语言是如何将方法与函数视为一个概念，接着会实现一个事件系统，事件系统能有效地将事件触发与响应两端代码解耦。

#### 方法和函数的统一调用

本节的例子将让一个结构体的方法（class.Do）的参数和一个普通函数（funcDo）的参数完全一致，也就是方法与函数的签名一致。然后使用与它们签名一致的函数变量（delegate）分别赋值方法与函数，接着调用它们，观察实际效果。

详细实现请参考下面的代码。

```go
  package main

  import "fmt"

  // 声明一个结构体
  type class struct {
  }

  // 给结构体添加Do方法
  func (c *class) Do(v int) {

      fmt.Println("call method do:", v)
  }

  // 普通函数的Do
  func funcDo(v int) {

      fmt.Println("call function do:", v)
  }

  func main() {

      // 声明一个函数回调
      var delegate func(int)

      // 创建结构体实例
      c := new(class)

      // 将回调设为c的Do方法
      delegate = c.Do

      // 调用
      delegate(100)

      // 将回调设为普通函数
      delegate = funcDo

      // 调用
      delegate(100)
  }
```

代码说明如下：

- 第 10 行，为结构体添加一个 Do() 方法，参数为整型。这个方法的功能是打印提示和输入的参数值。

- 第 16 行，声明一个普通函数，参数也是整型，功能是打印提示和输入的参数值。

- 第 24 行，声明一个 delegate 的变量，类型为 func(int)，与 funcDo 和 class 的 Do() 方法的参数一致。

- 第 30 行，将 c.Do 作为值赋给 delegate 变量。

- 第 33 行，调用 delegate() 函数，传入 100 的参数。此时会调用 c 实例的 Do() 方法。

- 第 36 行，将 funcDo 赋值给 delegate。

- 第 39 行，调用 delegate()，传入 100 的参数。此时会调用 funcDo() 方法。

运行代码，输出如下：

```go
call method do: 100 call function do: 100
```

这段代码能运行的基础在于：无论是普通函数还是结构体的方法，只要它们的签名一致，与它们签名一致的函数变量就可以保存普通函数或是结构体方法。

了解了 Go 语言的这一特性后，我们就可以将这个特性用在事件中。

#### 事件系统基本原理

事件系统可以将事件派发者与事件处理者解耦。例如，网络底层可以生成各种事件，在网络连接上后，网络底层只需将事件派发出去，而不需要关心到底哪些代码来响应连接上的逻辑。或者再比如，你注册、关注或者订阅某 “大 V” 的社交消息后，“大 V”发生的任何事件都会通知你，但他并不用了解粉丝们是如何为她喝彩或者疯狂的。如下图所示为事件系统基本原理图。

[![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5162QH04.jpg)](http://c.biancheng.net/uploads/allimg/180815/1-1PQ5162QH04.jpg)

图：事件系统基本原理

一个事件系统拥有如下特性：

- 能够实现事件的一方，可以根据事件 ID 或名字注册对应的事件。

- 事件发起者，会根据注册信息通知这些注册者。

- 一个事件可以有多个实现方响应。

通过下面的步骤详细了解事件系统的构成及使用。

#### 事件注册

事件系统需要为外部提供一个注册入口。这个注册入口传入注册的事件名称和对应事件名称的响应函数，事件注册的过程就是将事件名称和响应函数关联并保存起来，详细实现请参考下面代码的 RegisterEvent() 函数。

```go
  package main

  // 实例化一个通过字符串映射函数切片的map
  var eventByName = make(map[string][]func(interface{}))

  // 注册事件，提供事件名和回调函数
  func RegisterEvent(name string, callback func(interface{})) {

      // 通过名字查找事件列表
      list := eventByName[name]

      // 在列表切片中添加函数
      list = append(list, callback)

      // 将修改的事件列表切片保存回去
      eventByName[name] = list
  }

  // 调用事件
  func CallEvent(name string, param interface{}) {

      // 通过名字找到事件列表
      list := eventByName[name]

      // 遍历这个事件的所有回调
     for _, callback := range list {

          // 传入参数调用回调
          callback(param)
      }

  }
```

代码说明如下：

- 第 4 行，创建一个 map 实例，这个 map 通过事件名（string）关联回调列表（[]func(interface{}），同一个事件名称可能存在多个事件回调，因此使用回调列表保存。回调的函数声明为 func(interface{})。

- 第 7 行，提供给外部的通过事件名注册响应函数的入口。

- 第 10 行，eventByName 通过事件名（name）进行查询，返回回调列表（[]func(interface{}）。

- 第 13 行，为同一个事件名称在已经注册的事件回调的列表中再添加一个回调函数。

- 第 16 行，将修改后的函数列表设置到 map 的对应事件名中。

拥有事件名和事件回调函数列表的关联关系后，就需要开始准备事件调用的入口了。

#### 事件调用

事件调用方和注册方是事件处理中完全不同的两个角色。事件调用方是事发现场，负责将事件和事件发生的参数通过事件系统派发出去，而不关心事件到底由谁处理；事件注册方通过事件系统注册应该响应哪些事件及如何使用回调函数处理这些事件。事件调用的详细实现请参考上面代码的 CallEvent() 函数。

代码说明如下：

- 第 20 行，调用事件的入口，提供事件名称 name 和参数 param。事件的参数表示描述事件具体的细节，例如门打开的事件触发时，参数可以传入谁进来了。

- 第 23 行，通过注册事件回调的 eventByName 和事件名字查询处理函数列表 list。

- 第 26 行，遍历这个事件列表，如果没有找到对应的事件，list 将是一个空切片。

- 第 29 行，将每个函数回调传入事件参数并调用，就会触发事件实现方的逻辑处理。

#### 使用事件系统

例子中，在 main() 函数中调用事件系统的 CallEvent 生成 OnSkill 事件，这个事件有两个处理函数，一个是角色的 OnEvent() 方法，还有一个是函数 GlobalEvent()，详细代码实现过程请参考下面的代码。

```go
  package main

  import "fmt"

  // 声明角色的结构体
  type Actor struct {
  }

  // 为角色添加一个事件处理函数
  func (a \*Actor) OnEvent(param interface{}) {

      fmt.Println("actor event:", param)
  }

  // 全局事件
  func GlobalEvent(param interface{}) {

      fmt.Println("global event:", param)
  }

  func main() {

      // 实例化一个角色
      a := new(Actor)

      // 注册名为OnSkill的回调
      RegisterEvent("OnSkill", a.OnEvent)

      // 再次在OnSkill上注册全局事件
      RegisterEvent("OnSkill", GlobalEvent)

      // 调用事件，所有注册的同名函数都会被调用
      CallEvent("OnSkill", 100)

  }
```

代码说明如下：

- 第 6 行，声明一个角色的结构体。在游戏中，角色是常见的对象，本例中，角色也是 OnSkill 事件的响应处理方。

- 第 10 行，为角色结构添加一个 OnEvent() 方法，这个方法拥有 param 参数，类型为 interface{}，与事件系统的函数（func(interface{})）签名一致。

- 第 16 行为全局事件响应函数。有时需要全局进行侦听或者处理一些事件，这里使用普通函数实现全局事件的处理。

- 第 27 行，注册一个 OnSkill 事件，实现代码由 a 的 OnEvent 进行处理。也就是 Actor 的 OnEvent() 方法。

- 第 30 行，注册一个 OnSkill 事件，实现代码由 GlobalEvent 进行处理，虽然注册的是同一个名字的事件，但前面注册的事件不会被覆盖，而是被添加到事件系统中，关联 OnSkill 事件的函数列表中。

- 第 33 行，模拟处理事件，通过 CallEvent() 函数传入两个参数，第一个为事件名，第二个为处理函数的参数。

整个例子运行结果如下：

```go
actor event: 100 global event: 100
```

结果演示，角色和全局的事件会按注册顺序顺序地触发。

一般来说，事件系统不保证同一个事件实现方多个函数列表中的调用顺序，事件系统认为所有实现函数都是平等的。也就是说，无论例子中的 a.OnEvent 先注册，还是 GlobalEvent() 函数先注册，最终谁先被调用，都是无所谓的，开发者不应该去关注和要求保证调用的顺序。

一个完善的事件系统还会提供移除单个和所有事件的方法。

### 8. 类型内嵌和结构体内嵌

结构体可以包含一个或多个匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型也就是字段的名字。匿名字段本身可以是一个结构体类型，即结构体可以包含内嵌结构体。

可以粗略地将这个和面向对象语言中的继承概念相比较，随后将会看到它被用来模拟类似继承的行为。Go语言中的继承是通过内嵌或组合来实现的，所以可以说，在Go语言中，相比较于继承，组合更受青睐。

考虑如下的程序：

```go
package main
import "fmt"
type innerS struct {
    in1 int
    in2 int
}
type outerS struct {
    b int
    c float32
    int // anonymous field
    innerS //anonymous field
}
func main() {
    outer := new(outerS)
    outer.b = 6
    outer.c = 7.5
    outer.int = 60
    outer.in1 = 5
    outer.in2 = 10
    fmt.Printf("outer.b is: %d\n", outer.b)
    fmt.Printf("outer.c is: %f\n", outer.c)
    fmt.Printf("outer.int is: %d\n", outer.int)
    fmt.Printf("outer.in1 is: %d\n", outer.in1)
    fmt.Printf("outer.in2 is: %d\n", outer.in2)
    // 使用结构体字面量
    outer2 := outerS{6, 7.5, 60, innerS{5, 10}}
    fmt.Printf("outer2 is:", outer2)
}
```

运行结果如下所示：

```go
outer.b is: 6
outer.c is: 7.500000
outer.int is: 60
outer.in1 is: 5
outer.in2 is: 10
outer2 is:{6 7.5 60 {5 10}}
```

通过类型 outer.int 的名字来获取存储在匿名字段中的数据，于是可以得出一个结论：在一个结构体中对于每一种数据类型只能有一个匿名字段。

#### 内嵌结构体

同样地结构体也是一种数据类型，所以它也可以作为一个匿名字段来使用，如同上面例子中那样。外层结构体通过 outer.in1 直接进入内层结构体的字段，内嵌结构体甚至可以来自其他包。内层结构体被简单的插入或者内嵌进外层结构体。这个简单的“继承”机制提供了一种方式，使得可以从另外一个或一些类型继承部分或全部实现。

示例代码如下所示：

```go
package main
import "fmt"
type A struct {
    ax, ay int
}
type B struct {
    A
    bx, by float32
}
func main() {
    b := B{A{1, 2}, 3.0, 4.0}
    fmt.Println(b.ax, b.ay, b.bx, b.by)
    fmt.Println(b.A)
}
```

输出：

```go
1 2 3 4
{1 2}
```

#### 结构内嵌特性

Go语言的结构体内嵌有如下特性。

##### 1) 内嵌的结构体可以直接访问其成员变量

嵌入结构体的成员，可以通过外部结构体的实例直接访问。如果结构体有多层嵌入结构体，结构体实例访问任意一级的嵌入结构体成员时都只用给出字段名，而无须像传统结构体字段一样，通过一层层的结构体字段访问到最终的字段。例如，ins.a.b.c的访问可以简化为ins.c。

##### 2) 内嵌结构体的字段名是它的类型名

内嵌结构体字段仍然可以使用详细的字段进行一层层访问，内嵌结构体的字段名就是它的类型名，代码如下：

```go
var c Color
c.BasicColor.R = 1
c.BasicColor.G = 1
c.BasicColor.B = 0
```

一个结构体只能嵌入一个同类型的成员，无须担心结构体重名和错误赋值的情况，编译器在发现可能的赋值歧义时会报错。



### 9. 结构体内嵌模拟类的继承

在面向对象思想中，实现对象关系需要使用 “继承” 特性。例如，人类不能飞行，鸟类可以飞行。人类和鸟类都可以继承自可行走类，但只有鸟类继承自飞行类。

面向对象的设计原则中也建议对象最好不要使用多重继承，有些面向对象语言从语言层面就禁止了多重继承，如 C# 和 Java 语言。鸟类同时继承自可行走类和飞行类，这显然是存在问题的。在面向对象思想中要正确地实现对象的多重特性，只能使用一些精巧的设计来补救。

Go 语言的结构体内嵌特性就是一种组合特性，使用组合特性可以快速构建对象的不同特性。

下面的代码使用 Go 语言的结构体内嵌实现对象特性组合，请参考下面的代码。

人和鸟的特性：

```go
  package main

  import "fmt"

  // 可飞行的
  type Flying struct{}

  func (f *Flying) Fly() {
      fmt.Println("can fly")
  }

  // 可行走的
  type Walkable struct{}

  func (f *Walkable) Walk() {
      fmt.Println("can calk")
  }

  // 人类
  type Human struct {
      Walkable // 人类能行走
  }

  // 鸟类
  type Bird struct {
      Walkable // 鸟类能行走
      Flying   // 鸟类能飞行
  }

  func main() {

      // 实例化鸟类
      b := new(Bird)
      fmt.Println("Bird: ")
      b.Fly()
      b.Walk()

      // 实例化人类
      h := new(Human)
      fmt.Println("Human: ")
      h.Walk()

  }
```

代码说明如下：

- 第 6 行，声明可飞行结构（Flying）。

- 第 8 行，为可飞行结构添加飞行方法 Fly()。

- 第 13 行，声明可行走结构（Walkable）。

- 第 15 行，为可行走结构添加行走方法 Walk()。

- 第 20 行，声明人类结构。这个结构嵌入可行走结构（Walkable），让人类具备 “可行走” 特性

- 第 25 行，声明鸟类结构。这个结构嵌入可行走结构（Walkable）和可飞行结构（Flying），让鸟类具备既可行走又可飞行的特性。

- 第 33 行，实例化鸟类结构。

- 第 35 和 36 行，调用鸟类可以使用的功能，如飞行和行走。

- 第 39 行，实例化人类结构。

- 第 41 行，调用人类能使用的功能，如行走。

运行代码，输出如下：

```go
Bird: can fly can calk Human: can calk
```

使用 Go 语言的内嵌结构体实现对象特性，可以自由地在对象中增、删、改各种特性。Go 语言会在编译时检查能否使用这些特性。



### 10. 初始化内嵌结构体

结构体内嵌初始化时，将结构体内嵌的类型作为字段名像普通结构体一样进行初始化，详细实现过程请参考下面的代码。

车辆结构的组装和初始化：

```go
package main
import "fmt"
// 车轮
type Wheel struct {
    Size int
}
// 引擎
type Engine struct {
    Power int    // 功率
    Type  string // 类型
}
// 车
type Car struct {
    Wheel
    Engine
}
func main() {
    c := Car{
        // 初始化轮子
        Wheel: Wheel{
            Size: 18,
        },
        // 初始化引擎
        Engine: Engine{
            Type:  "1.4T",
            Power: 143,
        },
    }
    fmt.Printf("%+v\n", c)
}
```

代码说明如下：

- 第 6 行定义车轮结构。
- 第 11 行定义引擎结构。
- 第 17 行定义车结构，由车轮和引擎结构体嵌入。
- 第 27 行，将 Car 的 Wheel 字段使用 Wheel 结构体进行初始化。
- 第 32 行，将 Car 的 Engine 字段使用 Engine 结构体进行初始化。

#### 初始化内嵌匿名结构体

在前面描述车辆和引擎的例子中，有时考虑编写代码的便利性，会将结构体直接定义在嵌入的结构体中。也就是说，结构体的定义不会被外部引用到。在初始化这个被嵌入的结构体时，就需要再次声明结构才能赋予数据。具体请参考下面的代码。

```go
package main
import "fmt"
// 车轮
type Wheel struct {
    Size int
}
// 车
type Car struct {
    Wheel
    // 引擎
    Engine struct {
        Power int    // 功率
        Type  string // 类型
    }
}
func main() {
    c := Car{
        // 初始化轮子
        Wheel: Wheel{
            Size: 18,
        },
        // 初始化引擎
        Engine: struct {
            Power int
            Type  string
        }{
            Type:  "1.4T",
            Power: 143,
        },
    }
    fmt.Printf("%+v\n", c)
}
```

代码说明如下：

- 第 14 行中原来的 Engine 结构体被直接定义在 Car 的结构体中。这种嵌入的写法就是将原来的结构体类型转换为 struct{…}。
- 第 30 行，需要对 Car 的 Engine 字段进行初始化，由于 Engine 字段的类型并没有被单独定义，因此在初始化其字段时需要先填写 struct{…} 声明其类型。
- 第 3行开始填充这个匿名结构体的数据，按“键：值”格式填充。



### 11. 内嵌结构体成员名字冲突

嵌入结构体内部可能拥有相同的成员名，成员重名时会发生什么？下面通过例子来讲解。

```go
package main
import (
    "fmt"
)
type A struct {
    a int
}
type B struct {
    a int
}
type C struct {
    A
    B
}
func main() {
    c := &C{}
    c.A.a = 1
    fmt.Println(c)
}
```

代码说明如下：

- 第 7 行和第 11 行分别定义了两个拥有 a int 字段的结构体。
- 第 15 行的结构体嵌入了 A 和 B 的结构体。
- 第 21 行实例化 C 结构体。
- 第 22 行按常规的方法，访问嵌入结构体 A 中的 a 字段，并赋值 1。
- 第 23 行可以正常输出实例化 C 结构体。


接着，将第 22 行修改为如下代码：

```go
func main() {
    c := &C{}
    c.a = 1
    fmt.Println(c)
}
```

此时再编译运行，编译器报错：

```go
.\main.go:22:3: ambiguous selector c.a
```

编译器告知 C 的选择器 a 引起歧义，也就是说，编译器无法决定将 1 赋给 C 中的 A 还是 B 里的字段 a。

在使用内嵌结构体时，Go语言的编译器会非常智能地提醒我们可能发生的歧义和错误。

### 12. 使用匿名结构体解析JSON数据

JavaScript 对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。在类似的协议中，JSON 并不是唯一的一个标准协议。 XML、ASN.1 和 Google 的 Protocol Buffers 都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON 是应用最广泛的一个。

Go 语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的 encoding/json、encoding/xml、encoding/asn1 等包提供支持，并且这类包都有着相似的 API 接口。

基本的 JSON 类型有数字（十进制或科学记数法）、布尔值（true 或 false）、字符串，其中字符串是以双引号包含的 Unicode 字符序列，支持和 Go 语言类似的反斜杠转义特性，不过 JSON 使用的是 \Uhhhh 转义数字来表示一个 UTF-16 编码，而不是 Go 语言的 rune 类型。

手机拥有屏幕、电池、指纹识别等信息，将这些信息填充为 JSON 格式的数据。如果需要选择性地分离 JSON 中的数据则较为麻烦。Go 语言中的匿名结构体可以方便地完成这个操作。

首先给出完整的代码，然后再讲解每个部分。

```go
  package main

  import (
      "encoding/json"
      "fmt"
  )

  // 定义手机屏幕
  type Screen struct {
      Size       float32 // 屏幕尺寸
      ResX, ResY int     // 屏幕水平和垂直分辨率
  }

  // 定义电池
  type Battery struct {
      Capacity int // 容量
  }

  // 生成json数据
  func genJsonData() []byte {
      // 完整数据结构
      raw := &struct {
          Screen
          Battery
          HasTouchID bool // 序列化时添加的字段：是否有指纹识别
      }{
          // 屏幕参数
          Screen: Screen{
              Size: 5.5,
              ResX: 1920,
              ResY: 1080,
          },

          // 电池参数
          Battery: Battery{
              2910,
          },

          // 是否有指纹识别
          HasTouchID: true,
      }

      // 将数据序列化为json
      jsonData, _ := json.Marshal(raw)

      return jsonData
  }

  func main() {

      // 生成一段json数据
      jsonData := genJsonData()

      fmt.Println(string(jsonData))

      // 只需要屏幕和指纹识别信息的结构和实例
      screenAndTouch := struct {
          Screen
          HasTouchID bool
      }{}

      // 反序列化到screenAndTouch
      json.Unmarshal(jsonData, &screenAndTouch)

      // 输出screenAndTouch的详细结构
      fmt.Printf("%+v\n", screenAndTouch)

      // 只需要电池和指纹识别信息的结构和实例
      batteryAndTouch := struct {
          Battery
          HasTouchID bool
      }{}

      // 反序列化到batteryAndTouch
      json.Unmarshal(jsonData, &batteryAndTouch)

      // 输出screenAndTouch的详细结构
      fmt.Printf("%+v\n", batteryAndTouch)
  }
```

#### 定义数据结构

首先，定义手机的各种数据结构体，如屏幕和电池，参考如下代码：

```go
  // 定义手机屏幕
  type Screen struct {
      Size       float32  // 屏幕尺寸
      ResX, ResY int      // 屏幕水平和垂直分辨率
  }

  // 定义电池
  type Battery struct {
      Capacity int  // 容量
  }
```

上面代码定义了屏幕结构体和电池结构体，它们分别描述屏幕和电池的各种细节参数。

#### 准备 JSON 数据

准备手机数据结构，填充数据，将数据序列化为 JSON 格式的字节数组，代码如下：

```go
  // 生成JSON数据
  func genJsonData() []byte {
      // 完整数据结构
      raw := &struct {
          Screen
          Battery
          HasTouchID bool  // 序列化时添加的字段：是否有指纹识别
      }{
              // 屏幕参数
          Screen: Screen{
              Size: 5.5,
              ResX: 1920,
              ResY: 1080,
          },

          // 电池参数
          Battery: Battery{
              2910,
          },

          // 是否有指纹识别
          HasTouchID: true,
      }

      // 将数据序列化为JSON
      jsonData, _ := json.Marshal(raw)

      return jsonData
  }
```

代码说明如下：

- 第 4 行定义了一个匿名结构体。这个结构体内嵌了 Screen 和 Battery 结构体，同时临时加入了 HasTouchID 字段。

- 第 10 行，为刚声明的匿名结构体填充屏幕数据。

- 第 17 行，填充电池数据。

- 第 22 行，填充指纹识别字段。

- 第 26 行，使用 json.Marshal 进行 JSON 序列化，将 raw 变量序列化为 []byte 格式的 JSON 数据。

#### 分离 JSON 数据

调用 genJsonData 获得 JSON 数据，将需要的字段填充到匿名结构体实例中，通过 json.Unmarshal 反序列化 JSON 数据达成分离 JSON 数据效果。代码如下：

```go
  func main() {

      // 生成一段JSON数据
      jsonData := genJsonData()

      fmt.Println(string(jsonData))

      // 只需要屏幕和指纹识别信息的结构和实例
      screenAndTouch := struct {
              Screen
              HasTouchID bool
      }{}

      // 反序列化到screenAndTouch中
      json.Unmarshal(jsonData, &screenAndTouch)

      // 输出screenAndTouch的详细结构
      fmt.Printf("%+v\n", screenAndTouch)

      // 只需要电池和指纹识别信息的结构和实例
      batteryAndTouch := struct {
              Battery
              HasTouchID bool
      }{}

      // 反序列化到batteryAndTouch
      json.Unmarshal(jsonData, &batteryAndTouch)

      // 输出screenAndTouch的详细结构
      fmt.Printf("%+v\n", batteryAndTouch)
  }
```

代码说明如下：

- 第 4 行，调用 genJsonData() 函数，获得 []byte 类型的 JSON 数据。
- 第 6 行，将 jsonData 的 []byte 类型的 JSON 数据转换为字符串格式并打印输出。
- 第 9 行，构造匿名结构体，填充 Screen 结构和 HasTouchID 字段，第 12 行中的 {} 表示将结构体实例化。
- 第 15 行，调用 json.Unmarshal，输入完整的 JSON 数据（jsonData），将数据按第 9 行定义的结构体格式序列化到 screenAndTouch 中。
- 第 18 行，打印输出 screenAndTouch 中的详细数据信息。
- 第 21 行，构造匿名结构体，填充 Battery 结构和 HasTouchID 字段。
- 第 27 行，调用 json.Unmarshal，输入完整的 JSON 数据（jsonData），将数据按第 21 行定义的结构体格式序列化到 batteryAndTouch 中。
- 第 30 行，打印输出 batteryAndTouch 的详细数据信息。



### 13. 垃圾回收和SetFinalizer

Go语言自带垃圾回收机制（GC）。GC 通过独立的进程执行，它会搜索不再使用的变量，并将其释放。需要注意的是，GC 在运行时会占用机器资源。

GC 是自动进行的，如果要手动进行 GC，可以使用 runtime.GC() 函数，显式的执行 GC。显式的进行 GC 只在某些特殊的情况下才有用，比如当内存资源不足时调用 runtime.GC() ，这样会立即释放一大片内存，但是会造成程序短时间的性能下降。

finalizer（终止器）是与对象关联的一个函数，通过 runtime.SetFinalizer 来设置，如果某个对象定义了 finalizer，当它被 GC 时候，这个 finalizer 就会被调用，以完成一些特定的任务，例如发信号或者写日志等。

在Go语言中 SetFinalizer 函数是这样定义的：

```go
func SetFinalizer(x, f interface{})
```

参数说明如下：

- 参数 x 必须是一个指向通过 new 申请的对象的指针，或者通过对复合字面值取址得到的指针。
- 参数 f 必须是一个函数，它接受单个可以直接用 x 类型值赋值的参数，也可以有任意个被忽略的返回值。


SetFinalizer 函数可以将 x 的终止器设置为 f，当垃圾收集器发现 x 不能再直接或间接访问时，它会清理 x 并调用 f(x)。

另外，x 的终止器会在 x 不能直接或间接访问后的任意时间被调用执行，不保证终止器会在程序退出前执行，因此一般终止器只用于在长期运行的程序中释放关联到某对象的非内存资源。例如，当一个程序丢弃一个 os.File 对象时没有调用其 Close 方法，该 os.File 对象可以使用终止器去关闭对应的操作系统文件描述符。

终止器会按依赖顺序执行：如果 A 指向 B，两者都有终止器，且 A 和 B 没有其它关联，那么只有 A 的终止器执行完成，并且 A 被释放后，B 的终止器才可以执行。

如果 *x 的大小为 0 字节，也不保证终止器会执行。

此外，我们也可以使用`SetFinalizer(x, nil)`来清理绑定到 x 上的终止器。

提示：终止器只有在对象被 GC 时，才会被执行。其他情况下，都不会被执行，即使程序正常结束或者发生错误。

【示例】在函数 entry() 中定义局部变量并设置 finalizer，当函数 entry() 执行完成后，在 main 函数中手动触发 GC，查看 finalizer 的执行情况。

```go
package main
import (
    "log"
    "runtime"
    "time"
)
type Road int
func findRoad(r *Road) {
    log.Println("road:", *r)
}
func entry() {
    var rd Road = Road(999)
    r := &rd
    runtime.SetFinalizer(r, findRoad)
}
func main() {
    entry()
    for i := 0; i < 10; i++ {
        time.Sleep(time.Second)
        runtime.GC()
    }
}
```

运行结果如下：

```go
2019/11/28 15:32:16 road: 999
```



### 14. 将结构体数据保存为JSON格式数据

JSON 格式是一种对象文本格式，是当前互联网最常用的信息交换格式之一。在 Go 语言中，可以使用 json.Marshal() 函数将结构体格式的数据格式化为 JSON 格式。

想要使用 json.Marshal() 函数需要我们先引入 encoding/json 包，示例代码如下：

```go
  package main

  import (
      "encoding/json"
      "fmt"
  )

  func main() {
      // 声明技能结构体
      type Skill struct {
          Name  string
          Level int
      }
      // 声明角色结构体
      type Actor struct {
          Name   string
          Age    int
          Skills []Skill
      }
      // 填充基本角色数据
      a := Actor{
          Name: "cow boy",
          Age:  37,
          Skills: []Skill{
              {Name: "Roll and roll", Level: 1},
              {Name: "Flash your dog eye", Level: 2},
              {Name: "Time to have Lunch", Level: 3},
          },
      }
      result, err := json.Marshal(a)
      if err != nil {
          fmt.Println(err)
      }
      jsonStringData := string(result)
      fmt.Println(jsonStringData)
  }
```

运行结果如下：

```json
{
    "Name":"cow boy",
    "Age":37,
    "Skills":[
        {
            "Name":"Roll and roll",
            "Level":1
        },
        {
            "Name":"Flash your dog eye",
            "Level":2
        },
        {
            "Name":"Time to have Lunch",
            "Level":3
        }
    ]
}
```

通过运行结果可以看出我们成功的将结构体数据转换成了 JSON 格式。

提示：为了便于查看这里将输出结果做了格式化处理。

在转换 JSON 格式时，JSON 的各个字段名称默认使用结构体的名称，如果想要指定为其它的名称我们可以在声明结构体时添加一个``json:" "``标签，在`" "`中可以填入我们想要的内容，代码如下所示：

```go
  package main

  import (
      "encoding/json"
      "fmt"
  )

  func main() {
      // 声明技能结构体
      type Skill struct {
          Name  string `json:"name"`
          Level int    `json:"level"`
      }
      // 声明角色结构体
      type Actor struct {
          Name   string
          Age    int
          Skills []Skill
      }
      // 填充基本角色数据
      a := Actor{
          Name: "cow boy",
          Age:  37,
          Skills: []Skill{
              {Name: "Roll and roll", Level: 1},
              {Name: "Flash your dog eye", Level: 2},
              {Name: "Time to have Lunch", Level: 3},
          },
      }
      result, err := json.Marshal(a)
      if err != nil {
          fmt.Println(err)
      }
      jsonStringData := string(result)
      fmt.Println(jsonStringData)
  }
```

运行结果如下：

```json
{
	"Name": "cow boy",
	"Age": 37,
	"Skills": [{
			"level": 1
		},
		{
			"name": "Flash your dog eye",
			"level": 0
		},
		{
			"name": "Time to have Lunch",
			"level": 3
		}
	]
}
```

通过运行结果可以看出，我们成功将 Skill 结构体的 Name 和 Level 字段转换成了想要的内容。

我们还可以在上面的标签的`" "`中加入 omitempty（使用逗号`,`与前面的内容分隔），来过滤掉转换的 JSON 格式中的空值，如下所示：

```go
  package main

  import (
      "encoding/json"
      "fmt"
  )

  func main() {
      // 声明技能结构体
      type Skill struct {
          Name  string `json:"name,omitempty"`
          Level int    `json:"level"`
      }
      // 声明角色结构体
      type Actor struct {
          Name   string
          Age    int
          Skills []Skill
      }
      // 填充基本角色数据
      a := Actor{
          Name: "cow boy",
          Age:  37,
          Skills: []Skill{
              {Name: "", Level: 1},
              {Name: "Flash your dog eye"},
              {Name: "Time to have Lunch", Level: 3},
          },
      }
      result, err := json.Marshal(a)
      if err != nil {
          fmt.Println(err)
      }
      jsonStringData := string(result)
      fmt.Println(jsonStringData)
  }
```

运行结果如下：

```json
{
	"Name": "cow boy",
	"Age": 37,
	"Skills": [{
			"level": 1
		},
		{
			"name": "Flash your dog eye",
			"level": 0
		},
		{
			"name": "Time to have Lunch",
			"level": 3
		}
	]
}
```

通过对比 Skill 结构体的 Name 和 Level 字段可以看出，Name 字段的空值被忽略了，而 Level 字段则没有。

``json:" "` `标签的使用总结为以下几点：

- `FieldName int `json:"-"``：表示该字段被本包忽略；
- `FieldName int `json:"myName"``：表示该字段在 JSON 里使用 “myName” 作为键名；
- `FieldName int `json:"myName,omitempty"``：表示该字段在 JSON 里使用 “myName” 作为键名，并且如果该字段为空时将其省略掉；
- `FieldName int `json:",omitempty"``：该字段在 json 里的键名使用默认值，但如果该字段为空时会被省略掉，注意 omitempty 前面的逗号不能省略。



### 15. 链表操作

链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

使用链表结构可以避免在使用数组时需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。

链表允许插入和移除表上任意位置上的结点，但是不允许随机存取。链表有三种类型：单向链表、双向链表以及循环链表。

#### 单向链表

单向链表中每个结点包含两部分，分别是数据域和指针域，上一个结点的指针指向下一结点，依次相连，形成链表。

这里介绍三个概念：首元结点、头结点和头指针。

- 首元结点：就是链表中存储第一个元素的结点，如下图中 a1 的位置。
- 头结点：它是在首元结点之前附设的一个结点，其指针域指向首元结点。头结点的数据域可以存储链表的长度或者其它的信息，也可以为空不存储任何信息。
- 头指针：它是指向链表中第一个结点的指针。若链表中有头结点，则头指针指向头结点；若链表中没有头结点，则头指针指向首元结点。



![img](http://c.biancheng.net/uploads/allimg/191129/4-1911291A225308.gif)
图：单向链表


头结点在链表中不是必须的，但增加头结点有以下几点好处：

- 增加了头结点后，首元结点的地址保存在头结点的指针域中，对链表的第一个数据元素的操作与其他数据元素相同，无需进行特殊处理。
- 增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针，若链表为空的话，那么头结点的指针域为空。

#### 使用 Struct 定义单链表

利用 Struct 可以包容多种数据类型的特性，使用它作为链表的结点是最合适不过了。一个结构体内可以包含若干成员，这些成员可以是基本类型、自定义类型、数组类型，也可以是指针类型。这里可以使用指针类型成员来存放下一个结点的地址。

【示例 1】使用 Struct 定义一个单向链表。

```go
type Node struct {
    Data  int
    Next  *node
}
```

其中成员 Data 用来存放结点中的有用数据，Next 是指针类型的成员，它指向 Node struct 类型数据，也就是下一个结点的数据类型。

【示例 2】为链表赋值，并遍历链表中的每个结点。

```go
package main
import "fmt"
type Node struct {
    data int
    next *Node
}
func Shownode(p *Node) { //遍历
    for p != nil {
        fmt.Println(*p)
        p = p.next //移动指针
    }
}
func main() {
    var head = new(Node)
    head.data = 1
    var node1 = new(Node)
    node1.data = 2
    head.next = node1
    var node2 = new(Node)
    node2.data = 3
    node1.next = node2
    Shownode(head)
}
```

运行结果如下：

```go
{1 0xc00004c1e0}
{2 0xc00004c1f0}
{3 <nil>}
```

#### 插入结点

单链表的结点插入方法一般使用头插法或者尾插法。

##### 1) 头插法

每次插入在链表的头部插入结点，代码如下所示：

```go
package main
import "fmt"
type Node struct {
    data  int
    next  *Node
}
func Shownode(p *Node){   //遍历
    for p != nil{
        fmt.Println(*p)
        p=p.next  //移动指针
    }
}
func main() {
    var head = new(Node)
    head.data = 0
    var tail *Node
    tail = head   //tail用于记录头结点的地址，刚开始tail的的指针指向头结点
    for i :=1 ;i<10;i++{
        var node = Node{data:i}
        node.next = tail   //将新插入的node的next指向头结点
        tail = &node      //重新赋值头结点
    }
    Shownode(tail) //遍历结果
}
```

运行结果如下:

```go
{9 0xc000036270}
{8 0xc000036260}
{7 0xc000036250}
{6 0xc000036240}
{5 0xc000036230}
{4 0xc000036220}
{3 0xc000036210}
{2 0xc000036200}
{1 0xc0000361f0}
{0 <nil>}
```

##### 2) 尾插法

每次插入结点在尾部，这也是我们较为习惯的方法。

```go
package main
import "fmt"
type Node struct {
    data  int
    next  *Node
}
func Shownode(p *Node){   //遍历
    for p != nil{
        fmt.Println(*p)
        p=p.next  //移动指针
    }
}
func main() {
    var head = new(Node)
    head.data = 0
    var tail *Node
    tail = head   //tail用于记录最末尾的结点的地址，刚开始tail的的指针指向头结点
    for i :=1 ;i<10;i++{
        var node = Node{data:i}
        (*tail).next = &node
        tail = &node
    }
    Shownode(head) //遍历结果
}
```

运行结果如下：

```go
{0 0xc0000361f0}
{1 0xc000036200}
{2 0xc000036210}
{3 0xc000036220}
{4 0xc000036230}
{5 0xc000036240}
{6 0xc000036250}
{7 0xc000036260}
{8 0xc000036270}
{9 <nil>}
```

在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以速度较慢。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。

但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。

#### 循环链表

循环链表是一种特殊的单链表。

循环链表跟单链表唯一的区别就在尾结点。单向链表的尾结点指针指向空地址，表示这就是最后的结点了，而循环链表的尾结点指针是指向链表的头结点，它像一个环一样首尾相连，所以叫作“循环”链表，如下图所示。

![img](http://c.biancheng.net/uploads/allimg/191129/4-191129164U09C.gif)
图：循环链表


和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题，尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。

#### 双向链表

单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。



![img](http://c.biancheng.net/uploads/allimg/191129/4-19112916493M30.gif)
图：双向链表


双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。

### 16. 数据I/O对象及操作

在Go语言中，几乎所有的[数据结构](http://c.biancheng.net/data_structure/)都围绕接口展开，接口是Go语言中所有数据结构的核心。在实际开发过程中，无论是实现 web 应用程序，还是控制台输入输出，又或者是网络操作，都不可避免的会遇到 I/O 操作。

Go语言标准库的 bufio 包中，实现了对数据 I/O 接口的缓冲功能。这些功能封装于接口 io.ReadWriter、io.Reader 和 io.Writer 中，并对应创建了 ReadWriter、Reader 或 Writer 对象，在提供缓冲的同时实现了一些文本基本 I/O 操作功能。

#### ReadWriter 对象

ReadWriter 对象可以对数据 I/O 接口 io.ReadWriter 进行输入输出缓冲操作，ReadWriter 结构定义如下：

```go
type ReadWriter struct {
    *Reader
    *Writer
}
```

默认情况下，ReadWriter 对象中存放了一对 Reader 和 Writer 指针，它同时提供了对数据 I/O 对象的读写缓冲功能。

可以使用 NewReadWriter() 函数创建 ReadWriter 对象，该函数的功能是根据指定的 Reader 和 Writer 创建一个 ReadWriter 对象，ReadWriter 对象将会向底层 io.ReadWriter 接口写入数据，或者从 io.ReadWriter 接口读取数据。该函数原型声明如下：

```go
func NewReadWriter(r *Reader, w *Writer) *ReadWriter
```

在函数 NewReadWriter() 中，参数 r 是要读取的来源 Reader 对象，参数 w 是要写入的目的 Writer 对象。

#### Reader 对象

Reader 对象可以对数据 I/O 接口 io.Reader 进行输入缓冲操作，Reader 结构定义如下：

```go
type Reader struct {
  //contains filtered or unexported fields
)
```

默认情况下 Reader 对象没有定义初始值，输入缓冲区最小值为 16。当超出限制时，另创建一个二倍的存储空间。

#### 创建 Reader 对象

可以创建 Reader 对象的函数一共有两个，分别是 NewReader() 和 NewReaderSize()，下面分别介绍。

##### 1) NewReader() 函数

NewReader() 函数的功能是按照缓冲区默认长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：

```go
func NewReader(rd io.Reader) *Reader
```

其中，参数 rd 是 io.Reader 接口，Reader 对象将从该接口读取数据。

##### 2) NewReaderSize() 函数

NewReaderSize() 函数的功能是按照指定的缓冲区长度创建 Reader 对象，Reader 对象会从底层 io.Reader 接口读取尽量多的数据进行缓存。该函数原型如下：

```go
func NewReaderSize(rd io.Reader, size int) *Reader
```

其中，参数 rd 是 io.Reader 接口，参数 size 是指定的缓冲区字节长度。

#### 操作 Reader 对象

操作 Reader 对象的方法共有 11 个，分别是 Read()、ReadByte()、ReadBytes()、ReadLine()、ReadRune ()、ReadSlice()、ReadString()、UnreadByte()、UnreadRune()、Buffered()、Peek()，下面分别介绍。

##### 1) Read() 方法

Read() 方法的功能是读取数据，并存放到字节切片 p 中。Read() 执行结束会返回已读取的字节数，因为最多只调用底层的 io.Reader 一次，所以返回的 n 可能小于 len(p)，当字节流结束时，n 为 0，err 为 io. EOF。该方法原型如下：

```go
func (b *Reader) Read(p []byte) (n int, err error)
```

在方法 Read() 中，参数 p 是用于存放读取数据的字节切片。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("C语言中文网")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    var buf [128]byte
    n, err := r.Read(buf[:])
    fmt.Println(string(buf[:n]), n, err)
}
```

运行结果如下：

```go
C语言中文网 16 <nil>
```

##### 2) ReadByte() 方法

ReadByte() 方法的功能是读取并返回一个字节，如果没有字节可读，则返回错误信息。该方法原型如下：

```go
func (b *Reader) ReadByte() (c byte,err error)
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    c, err := r.ReadByte()
    fmt.Println(string(c), err)
}
```

运行结果如下：

```go
G <nil>
```

##### 3) ReadBytes() 方法

ReadBytes() 方法的功能是读取数据直到遇到第一个分隔符“delim”，并返回读取的字节序列（包括“delim”）。如果 ReadBytes 在读到第一个“delim”之前出错，它返回已读取的数据和那个错误（通常是 io.EOF）。只有当返回的数据不以“delim”结尾时，返回的 err 才不为空值。该方法原型如下：

```go
func (b *Reader) ReadBytes(delim byte) (line []byte, err error)
```

其中，参数 delim 用于指定分割字节。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("C语言中文网, Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    var delim byte = ','
    line, err := r.ReadBytes(delim)
    fmt.Println(string(line), err)
}
```

运行结果如下：

```go
C语言中文网, <nil>
```

##### 4) ReadLine() 方法

ReadLine() 是一个低级的用于读取一行数据的方法，大多数调用者应该使用 ReadBytes('\n') 或者 ReadString('\n')。ReadLine 返回一行，不包括结尾的回车字符，如果一行太长（超过缓冲区长度），参数 isPrefix 会设置为 true 并且只返回前面的数据，剩余的数据会在以后的调用中返回。

当返回最后一行数据时，参数 isPrefix 会置为 false。返回的字节切片只在下一次调用 ReadLine 前有效。ReadLine 会返回一个非空的字节切片或一个错误，方法原型如下：

```go
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("Golang is a beautiful language. \r\n I like it!")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    line, prefix, err := r.ReadLine()
    fmt.Println(string(line), prefix, err)
}
```

运行结果如下：

```go
Golang is a beautiful language. false <nil>
```

##### 5) ReadRune() 方法

ReadRune() 方法的功能是读取一个 UTF-8 编码的字符，并返回其 Unicode 编码和字节数。如果编码错误，ReadRune 只读取一个字节并返回 unicode.ReplacementChar(U+FFFD) 和长度 1。该方法原型如下：

```go
func (b *Reader) ReadRune() (r rune, size int, err error)
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("C语言中文网")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    ch, size, err := r.ReadRune()
    fmt.Println(string(ch), size, err)
}
```

运行结果如下：

```go
C 1 <nil>
```

##### 6) ReadSlice() 方法

ReadSlice() 方法的功能是读取数据直到分隔符“delim”处，并返回读取数据的字节切片，下次读取数据时返回的切片会失效。如果 ReadSlice 在查找到“delim”之前遇到错误，它返回读取的所有数据和那个错误（通常是 io.EOF）。

如果缓冲区满时也没有查找到“delim”，则返回 ErrBufferFull 错误。ReadSlice 返回的数据会在下次 I/O 操作时被覆盖，大多数调用者应该使用 ReadBytes 或者 ReadString。只有当 line 不以“delim”结尾时，ReadSlice 才会返回非空 err。该方法原型如下：

```go
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
```

其中，参数 delim 用于指定分割字节。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("C语言中文网, Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    var delim byte = ','
    line, err := r.ReadSlice(delim)
    fmt.Println(string(line), err)
    line, err = r.ReadSlice(delim)
    fmt.Println(string(line), err)
    line, err = r.ReadSlice(delim)
    fmt.Println(string(line), err)
}
```

运行结果如下：

```go
C语言中文网, <nil>
Go语言入门教程 EOF
EOF
```

##### 7) ReadString() 方法

ReadString() 方法的功能是读取数据直到分隔符“delim”第一次出现，并返回一个包含“delim”的字符串。如果 ReadString 在读取到“delim”前遇到错误，它返回已读字符串和那个错误（通常是 io.EOF）。只有当返回的字符串不以“delim”结尾时，ReadString 才返回非空 err。该方法原型如下：

```go
func (b *Reader) ReadString(delim byte) (line string, err error)
```

其中，参数 delim 用于指定分割字节。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("C语言中文网, Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    var delim byte = ','
    line, err := r.ReadString(delim)
    fmt.Println(line, err)
}
```

运行结果为：

```go
C语言中文网, <nil>
```

##### 8) UnreadByte() 方法

UnreadByte() 方法的功能是取消已读取的最后一个字节（即把字节重新放回读取缓冲区的前部）。只有最近一次读取的单个字节才能取消读取。该方法原型如下：

```go
func (b *Reader) UnreadByte() error
```

##### 9) UnreadRune() 方法

UnreadRune() 方法的功能是取消读取最后一次读取的 Unicode 字符。如果最后一次读取操作不是 ReadRune，UnreadRune 会返回一个错误（在这方面它比 UnreadByte 更严格，因为 UnreadByte 会取消上次任意读操作的最后一个字节）。该方法原型如下：

```go
func (b *Reader) UnreadRune() error
```

##### 10) Buffered() 方法

Buffered() 方法的功能是返回可从缓冲区读出数据的字节数, 示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    var buf [14]byte
    n, err := r.Read(buf[:])
    fmt.Println(string(buf[:n]), n, err)
    rn := r.Buffered()
    fmt.Println(rn)
    n, err = r.Read(buf[:])
    fmt.Println(string(buf[:n]), n, err)
    rn = r.Buffered()
    fmt.Println(rn)
}
```

运行结果如下：

```go
Go语言入门 14 <nil>
6
教程 6 <nil>
0
```

##### 11) Peek() 方法

Peek() 方法的功能是读取指定字节数的数据，这些被读取的数据不会从缓冲区中清除。在下次读取之后，本次返回的字节切片会失效。如果 Peek 返回的字节数不足 n 字节，则会同时返回一个错误说明原因，如果 n 比缓冲区要大，则错误为 ErrBufferFull。该方法原型如下：

```go
func (b *Reader) Peek(n int) ([]byte, error)
```

在方法 Peek() 中，参数 n 是希望读取的字节数。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    data := []byte("Go语言入门教程")
    rd := bytes.NewReader(data)
    r := bufio.NewReader(rd)
    bl, err := r.Peek(8)
    fmt.Println(string(bl), err)
    bl, err = r.Peek(14)
    fmt.Println(string(bl), err)
    bl, err = r.Peek(20)
    fmt.Println(string(bl), err)
}
```

运行结果如下：

```go
Go语言 <nil>
Go语言入门 <nil>
Go语言入门教程 <nil>
```

#### Writer 对象

Writer 对象可以对数据 I/O 接口 io.Writer 进行输出缓冲操作，Writer 结构定义如下：

```go
type Writer struct {
  //contains filtered or unexported fields
}
```

默认情况下 Writer 对象没有定义初始值，如果输出缓冲过程中发生错误，则数据写入操作立刻被终止，后续的写操作都会返回写入异常错误。

#### 创建 Writer 对象

创建 Writer 对象的函数共有两个分别是 NewWriter() 和 NewWriterSize()，下面分别介绍一下。

##### 1) NewWriter() 函数

NewWriter() 函数的功能是按照默认缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：

```go
func NewWriter(wr io.Writer) *Writer
```

其中，参数 wr 是 io.Writer 接口，Writer 对象会将数据写入该接口。

##### 2) NewWriterSize() 函数

NewWriterSize() 函数的功能是按照指定的缓冲区长度创建 Writer 对象，Writer 对象会将缓存的数据批量写入底层 io.Writer 接口。该函数原型如下：

```go
func NewWriterSize(wr io.Writer, size int) *Writer
```

其中，参数 wr 是 io.Writer 接口，参数 size 是指定的缓冲区字节长度。

#### 操作 Writer 对象

操作 Writer 对象的方法共有 7 个，分别是 Available()、Buffered()、Flush()、Write()、WriteByte()、WriteRune() 和 WriteString() 方法，下面分别介绍。

##### 1) Available() 方法

Available() 方法的功能是返回缓冲区中未使用的字节数，该方法原型如下：

```go
func (b *Writer) Available() int
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    p := []byte("C语言中文网")
    fmt.Println("写入前未使用的缓冲区为：", w.Available())
    w.Write(p)
    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Available())
}
```

运行结果如下：

写入前未使用的缓冲区为： 4096
写入"C语言中文网"后，未使用的缓冲区为：4080

##### 2) Buffered() 方法

Buffered() 方法的功能是返回已写入当前缓冲区中的字节数，该方法原型如下：

```go
func (b *Writer) Buffered() int
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    p := []byte("C语言中文网")
    fmt.Println("写入前未使用的缓冲区为：", w.Buffered())
    w.Write(p)
    fmt.Printf("写入%q后，未使用的缓冲区为：%d\n", string(p), w.Buffered())
    w.Flush()
    fmt.Println("执行 Flush 方法后，写入的字节数为：", w.Buffered())
}
```

该例测试结果为：

写入前未使用的缓冲区为： 0
写入"C语言中文网"后，未使用的缓冲区为：16
执行 Flush 方法后，写入的字节数为： 0

##### 3) Flush() 方法

Flush() 方法的功能是把缓冲区中的数据写入底层的 io.Writer，并返回错误信息。如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：

```go
func (b *Writer) Flush() error
```

示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    p := []byte("C语言中文网")
    w.Write(p)
    fmt.Printf("未执行 Flush 缓冲区输出 %q\n", string(wr.Bytes()))
    w.Flush()
    fmt.Printf("执行 Flush 后缓冲区输出 %q\n", string(wr.Bytes()))
}
```

运行结果如下：

未执行 Flush 缓冲区输出 ""
执行 Flush 后缓冲区输出 "C语言中文网"

##### 4) Write() 方法

Write() 方法的功能是把字节切片 p 写入缓冲区，返回已写入的字节数 nn。如果 nn 小于 len(p)，则同时返回一个错误原因。该方法原型如下：

```go
func (b *Writer) Write(p []byte) (nn int, err error)
```

其中，参数 p 是要写入的字节切片。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    p := []byte("C语言中文网")
    n, err := w.Write(p)
    w.Flush()
    fmt.Println(string(wr.Bytes()), n, err)
}
```

运行结果如下：

```go
C语言中文网 16 <nil>
```

##### 5) WriteByte() 方法

WriteByte() 方法的功能是写入一个字节，如果成功写入，error 返回 nil，否则 error 返回错误原因。该方法原型如下：

```go
func (b *Writer) WriteByte(c byte) error
```

其中，参数 c 是要写入的字节数据，比如 ASCII 字符。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    var c byte = 'G'
    err := w.WriteByte(c)
    w.Flush()
    fmt.Println(string(wr.Bytes()), err)
}
```

运行结果如下：

```go
G <nil>
```

##### 6) WriteRune() 方法

WriteRune() 方法的功能是以 UTF-8 编码写入一个 Unicode 字符，返回写入的字节数和错误信息。该方法原型如下：

```go
func (b *Writer) WriteRune(r rune) (size int,err error)
```

其中，参数 r 是要写入的 Unicode 字符。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    var r rune = 'G'
    size, err := w.WriteRune(r)
    w.Flush()
    fmt.Println(string(wr.Bytes()), size, err)
}
```

该例测试结果为：

```go
G 1 <nil>
```

##### 7) WriteString() 方法

WriteString() 方法的功能是写入一个字符串，并返回写入的字节数和错误信息。如果返回的字节数小于 len(s)，则同时返回一个错误说明原因。该方法原型如下：

```go
func (b *Writer) WriteString(s string) (int, error)
```

其中，参数 s 是要写入的字符串。示例代码如下：

```go
package main
import (
    "bufio"
    "bytes"
    "fmt"
)
func main() {
    wr := bytes.NewBuffer(nil)
    w := bufio.NewWriter(wr)
    s := "C语言中文网"
    n, err := w.WriteString(s)
    w.Flush()
    fmt.Println(string(wr.Bytes()), n, err)
}
```

运行结果如下：

```go
C语言中文网 16 <nil>
```



## 第七章 接口

### 1. 接口声明（定义）

Go语言不是一种 “传统” 的面向对象编程语言：它里面没有类和继承的概念。

但是Go语言里有非常灵活的接口概念，通过它可以实现很多面向对象的特性。很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。

这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。

接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。

接口是双方约定的一种合作协议。接口实现者不需要关心接口会被怎样使用，调用者也不需要关心接口的实现细节。接口是一种类型，也是一种抽象结构，不会暴露所含数据的格式、类型及结构。

#### 接口声明的格式

每个接口类型由数个方法组成。接口的形式代码如下：

```go
type 接口类型名 interface{
    方法名1( 参数列表1 ) 返回值列表1
    方法名2( 参数列表2 ) 返回值列表2
    …
}
```

对各个部分的说明：

- 接口类型名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加 er，如有写操作的接口叫 Writer，有字符串功能的接口叫 Stringer，有关闭功能的接口叫 Closer 等。
- 方法名：当方法名首字母是大写时，且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。
- 参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以被忽略，例如：

```go
type writer interface{
    Write([]byte) error
}
```

#### 开发中常见的接口及写

Go语言提供的很多包中都有接口，例如 io 包中提供的 Writer 接口：

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

这个接口可以调用 Write() 方法写入一个字节数组（[]byte），返回值告知写入字节数（n int）和可能发生的错误（err error）。

类似的，还有将一个对象以字符串形式展现的接口，只要实现了这个接口的类型，在调用 String() 方法时，都可以获得对象对应的字符串。在 fmt 包中定义如下：

```go
type Stringer interface {
    String() string
}
```

Stringer 接口在Go语言中的使用频率非常高，功能类似于 [Java](http://c.biancheng.net/java/) 或者 [C#](http://c.biancheng.net/csharp/) 语言里的 ToString 的操作。

Go语言的每个接口中的方法数量不会很多。Go语言希望通过一个接口精准描述它自己的功能，而通过多个接口的嵌入和组合的方式将简单的接口扩展为复杂的接口。本章后面的小节中会介绍如何使用组合来扩充接口。

### 2. 实现接口的条件

如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。

实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。

接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。

#### 接口被实现的条件一：接口的方法与实现接口的类型方法格式一致

在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。

为了抽象数据写入的过程，定义 DataWriter 接口来描述数据写入需要实现的方法，接口中的 WriteData() 方法表示将数据写入，写入方无须关心写入到哪里。实现接口的类型实现 WriteData 方法时，会具体编写将数据写入到什么结构中。这里使用file结构体实现 DataWriter 接口的 WriteData 方法，方法内部只是打印一个日志，表示有数据写入，详细实现过程请参考下面的代码。

数据写入器的抽象：

```go
package main
import (
    "fmt"
)
// 定义一个数据写入器
type DataWriter interface {
    WriteData(data interface{}) error
}
// 定义文件结构，用于实现DataWriter
type file struct {
}
// 实现DataWriter接口的WriteData方法
func (d *file) WriteData(data interface{}) error {
    // 模拟写入数据
    fmt.Println("WriteData:", data)
    return nil
}
func main() {
    // 实例化file
    f := new(file)
    // 声明一个DataWriter的接口
    var writer DataWriter
    // 将接口赋值f，也就是*file类型
    writer = f
    // 使用DataWriter接口进行数据写入
    writer.WriteData("data")
}
```

代码说明如下：

- 第 8 行，定义 DataWriter 接口。这个接口只有一个方法，即 WriteData()，输入一个 interface{} 类型的 data，返回一个 error 结构表示可能发生的错误。
- 第 17 行，file 的 WriteData() 方法使用指针接收器。输入一个 interface{} 类型的 data，返回 error。
- 第 27 行，实例化 file 赋值给 f，f 的类型为 *file。
- 第 30 行，声明 DataWriter 类型的 writer 接口变量。
- 第 33 行，将 *file 类型的 f 赋值给 DataWriter 接口的 writer，虽然两个变量类型不一致。但是 writer 是一个接口，且 f 已经完全实现了 DataWriter() 的所有方法，因此赋值是成功的。
- 第 36 行，DataWriter 接口类型的 writer 使用 WriteData() 方法写入一个字符串。


运行代码，输出如下：

```go
WriteData: data
```

本例中调用及实现关系如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180815/1-1PQ51J445a1.jpg)
图：WriteWriter的实现过程


当类型无法实现接口时，编译器会报错，下面列出常见的几种接口无法实现的错误。

##### 1) 函数名不一致导致的报错

在以上代码的基础上尝试修改部分代码，造成编译错误，通过编译器的报错理解如何实现接口的方法。首先，修改 file 结构的 WriteData() 方法名，将这个方法签名（第17行）修改为：

```go
func (d *file) WriteDataX(data interface{}) error {
```

编译代码，报错：

```go
cannot use f (type *file) as type DataWriter in assignment:
    *file does not implement DataWriter (missing WriteData method)
```

报错的位置在第 33 行。报错含义是：不能将 f 变量（类型*file）视为 DataWriter 进行赋值。原因：*file 类型未实现 DataWriter 接口（丢失 WriteData 方法）。

WriteDataX 方法的签名本身是合法的。但编译器扫描到第 33 行代码时，发现尝试将 *file 类型赋值给 DataWriter 时，需要检查 *file 类型是否完全实现了 DataWriter 接口。显然，编译器因为没有找到 DataWriter 需要的 WriteData() 方法而报错。

##### 2) 实现接口的方法签名不一致导致的报错

将修改的代码恢复后，再尝试修改 WriteData() 方法，把 data 参数的类型从 interface{} 修改为 int 类型，代码如下：

```go
func (d *file) WriteData(data int) error {
```

编译代码，报错：

```go
cannot use f (type *file) as type DataWriter in assignment:
    *file does not implement DataWriter (wrong type for WriteData method)
        have WriteData(int) error
        want WriteData(interface {}) error
```

这次未实现 DataWriter 的理由变为（错误的 WriteData() 方法类型）发现 WriteData(int)error，期望 WriteData(interface{})error。

这种方式的报错就是由实现者的方法签名与接口的方法签名不一致导致的。

#### 接口被实现的条件二：接口中所有方法均被实现

当一个接口中有多个方法时，只有这些方法都被实现了，接口才能被正确编译并使用。

在本节开头的代码中，为 DataWriter中 添加一个方法，代码如下：

```go
// 定义一个数据写入器
type DataWriter interface {
    WriteData(data interface{}) error
    // 能否写入
    CanWrite() bool
}
```

新增 CanWrite() 方法，返回 bool。此时再次编译代码，报错：

```go
cannot use f (type *file) as type DataWriter in assignment:
    *file does not implement DataWriter (missing CanWrite method)
```

需要在 file 中实现 CanWrite() 方法才能正常使用 DataWriter()。

Go语言的接口实现是隐式的，无须让实现接口的类型写出实现了哪些接口。这个设计被称为非侵入式设计。

实现者在编写方法时，无法预测未来哪些方法会变为接口。一旦某个接口创建出来，要求旧的代码来实现这个接口时，就需要修改旧的代码的派生部分，这一般会造成雪崩式的重新编译。

##### 提示

传统的派生式接口及类关系构建的模式，让类型间拥有强耦合的父子关系。这种关系一般会以“类派生图”的方式进行。经常可以看到大型软件极为复杂的派生树。随着系统的功能不断增加，这棵“派生树”会变得越来越复杂。

对于Go语言来说，非侵入式设计让实现者的所有类型均是平行的、组合的。如何组合则留到使用者编译时再确认。因此，使用GO语言时，不需要同时也不可能有“类派生图”，开发者唯一需要关注的就是“我需要什么？”，以及“我能实现什么？”。

### 3. 类型与接口的关系

在Go语言中类型和接口之间有一对多和多对一的关系，下面将列举出这些常见的概念，以方便读者理解接口与类型在复杂环境下的实现关系。

#### 一个类型可以实现多个接口

一个类型可以同时实现多个接口，而接口间彼此独立，不知道对方的实现。

网络上的两个程序通过一个双向的通信连接实现数据的交换，连接的一端称为一个 Socket。Socket 能够同时读取和写入数据，这个特性与文件类似。因此，开发中把文件和 Socket 都具备的读写特性抽象为独立的读写器概念。

Socket 和文件一样，在使用完毕后，也需要对资源进行释放。

把 Socket 能够写入数据和需要关闭的特性使用接口来描述，请参考下面的代码：

```go
type Socket struct {
}
func (s *Socket) Write(p []byte) (n int, err error) {
    return 0, nil
}
func (s *Socket) Close() error {
    return nil
}
```

Socket 结构的 Write() 方法实现了 io.Writer 接口：

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

同时，Socket 结构也实现了 io.Closer 接口：

```go
type Closer interface {
    Close() error
}
```

使用 Socket 实现的 Writer 接口的代码，无须了解 Writer 接口的实现者是否具备 Closer 接口的特性。同样，使用 Closer 接口的代码也并不知道 Socket 已经实现了 Writer 接口，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180816/1-1PQ6100I14b.jpg)
图：接口的使用和实现过程


在代码中使用 Socket 结构实现的 Writer 接口和 Closer 接口代码如下：

```go
// 使用io.Writer的代码, 并不知道Socket和io.Closer的存在
func usingWriter( writer io.Writer){
    writer.Write( nil )
}
// 使用io.Closer, 并不知道Socket和io.Writer的存在
func usingCloser( closer io.Closer) {
    closer.Close()
}
func main() {
    // 实例化Socket
    s := new(Socket)
    usingWriter(s)
    usingCloser(s)
}
```

usingWriter() 和 usingCloser() 完全独立，互相不知道对方的存在，也不知道自己使用的接口是 Socket 实现的。

#### 多个类型可以实现相同的接

一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。也就是说，使用者并不关心某个接口的方法是通过一个类型完全实现的，还是通过多个结构嵌入到一个结构体中拼凑起来共同实现的。

Service 接口定义了两个方法：一个是开启服务的方法（Start()），一个是输出日志的方法（Log()）。使用 GameService 结构体来实现 Service，GameService 自己的结构只能实现 Start() 方法，而 Service 接口中的 Log() 方法已经被一个能输出日志的日志器（Logger）实现了，无须再进行 GameService 封装，或者重新实现一遍。所以，选择将 Logger 嵌入到 GameService 能最大程度地避免代码冗余，简化代码结构。详细实现过程如下：

```go
// 一个服务需要满足能够开启和写日志的功能
type Service interface {
    Start()  // 开启服务
    Log(string)  // 日志输出
}
// 日志器
type Logger struct {
}
// 实现Service的Log()方法
func (g *Logger) Log(l string) {
}
// 游戏服务
type GameService struct {
    Logger  // 嵌入日志器
}
// 实现Service的Start()方法
func (g *GameService) Start() {
}
```

代码说明如下：

- 第 2 行，定义服务接口，一个服务需要实现 Start() 方法和日志方法。
- 第 8 行，定义能输出日志的日志器结构。
- 第 12 行，为 Logger 添加 Log() 方法，同时实现 Service 的 Log() 方法。
- 第 17 行，定义 GameService 结构。
- 第 18 行，在 GameService 中嵌入 Logger 日志器，以实现日志功能。
- 第 22 行，GameService 的 Start() 方法实现了 Service 的 Start() 方法。


此时，实例化 GameService，并将实例赋给 Service，代码如下：

```go
var s Service = new(GameService)
s.Start()
s.Log(“hello”)
```

s 就可以使用 Start() 方法和 Log() 方法，其中，Start() 由 GameService 实现，Log() 方法由 Logger 实现。

### 4. 接口的nil判断

nil 在 Go 语言中只能被赋值给指针和接口。接口在底层的实现有两个部分：type 和 data。在源码中，显式地将 nil 赋值给接口时，接口的 type 和 data 都将为 nil。此时，接口与 nil 值判断是相等的。但如果将一个带有类型的 nil 赋值给接口时，只有 data 为 nil，而 type 为 nil，此时，接口与 nil 判断将不相等。

#### 接口与 nil 不相等

下面代码使用 MyImplement() 实现 fmt 包中的 Stringer 接口，这个接口的定义如下：

```go
  type Stringer interface {
      String() string
  }
```

在 GetStringer() 函数中将返回这个接口。通过 *MyImplement 指针变量置为 nil 提供 GetStringer 的返回值。在 main() 中，判断 GetStringer 与 nil 是否相等，代码如下：

```go
  package main

  import "fmt"

  // 定义一个结构体
  type MyImplement struct{}

  // 实现fmt.Stringer的String方法
  func (m *MyImplement) String() string {

      return "hi"
  }

  // 在函数中返回fmt.Stringer接口
  func GetStringer() fmt.Stringer {

      // 赋nil
      var s *MyImplement = nil

      // 返回变量
      return s
  }

  func main() {

      // 判断返回值是否为nil
      if GetStringer() == nil {
          fmt.Println("GetStringer() == nil")
      } else {
          fmt.Println("GetStringer() != nil")
      }

  }
```

代码说明如下：

- 第 9 行，实现 fmt.Stringer 的 String() 方法。

- 第 21 行，s 变量此时被 fmt.Stringer 接口包装后，实际类型为 *MyImplement，值为 nil 的接口。

- 第 27 行，使用 GetStringer() 的返回值与 nil 判断时，虽然接口里的 value 为 nil，但 type 带有 *MyImplement 信息，使用 == 判断相等时，依然不为 nil。

#### 发现 nil 类型值返回时直接返回 nil

为了避免这类误判的问题，可以在函数返回时，发现带有 nil 的指针时直接返回 nil，代码如下：

```go
  func GetStringer() fmt.Stringer {

      var s *MyImplement = nil

      if s == nil {
          return nil
      }

      return s
  }
```



### 5. 类型断言简述

类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。

在Go语言中类型断言的语法格式如下：

```go
value, ok := x.(T)
```

其中，x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。

该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：

- 如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。
- 如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。
- 无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。


示例代码如下：

```go
package main
import (
    "fmt"
)
func main() {
    var x interface{}
    x = 10
    value, ok := x.(int)
    fmt.Print(value, ",", ok)
}
```

运行结果如下：

```go
10,true
```

需要注意如果不接收第二个参数也就是上面代码中的 ok，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。

示例代码如下：

```go
package main
import (
    "fmt"
)
func main() {
    var x interface{}
    x = "Hello"
    value := x.(int)
    fmt.Println(value)
}
```

运行结果如下：

```go
panic: interface conversion: interface {} is string, not int
```

类型断言还可以配合 switch 使用，示例代码如下：

```go
package main
import (
    "fmt"
)
func main() {
    var a int
    a = 10
    getType(a)
}
func getType(a interface{}) {
    switch a.(type) {
    case int:
        fmt.Println("the type of a is int")
    case string:
        fmt.Println("the type of a is string")
    case float64:
        fmt.Println("the type of a is float")
    default:
        fmt.Println("unknown type")
    }
}
```

运行结果如下：

```go
the type of a is int
```

### 6. 实现日志系统

日志可以用于查看和分析应用程序的运行状态。日志一般可以支持输出多种形式，如命令行、文件、网络等。

本例将搭建一个支持多种写入器的日志系统，可以自由扩展多种日志写入设备。

#### 日志对外接口

本例中定义一个日志写入器接口（LogWriter），要求写入设备必须遵守这个接口协议才能被日志器（Logger）注册。日志器有一个写入器的注册方法（Logger 的 RegisterWriter() 方法）。

日志器还有一个 Log() 方法，进行日志的输出，这个函数会将日志写入到所有已经注册的日志写入器（LogWriter）中，详细代码实现请参考下面的代码。

```go
  package main

  // 声明日志写入器接口
  type LogWriter interface {
      Write(data interface{}) error
  }

  // 日志器
  type Logger struct {
      // 这个日志器用到的日志写入器
      writerList []LogWriter
  }

  // 注册一个日志写入器
  func (l *Logger) RegisterWriter(writer LogWriter) {
      l.writerList = append(l.writerList, writer)
  }

  // 将一个data类型的数据写入日志
  func (l *Logger) Log(data interface{}) {

      // 遍历所有注册的写入器
      for _, writer := range l.writerList {

          // 将日志输出到每一个写入器中
          writer.Write(data)
      }
  }

  // 创建日志器的实例
  func NewLogger() *Logger {
      return &Logger{}
  }
```

代码说明如下： 第 4 行，声明日志写入器接口。这个接口可以被外部使用。日志的输出可以有多种设备，这个写入器就是用来实现一个日志的输出设备。 第 9 行，声明日志器结构。日志器使用 writeList 记录输出到哪些设备上。 第 15 行，使用日志器方法 RegisterWriter() 将一个日志写入器（LogWriter）注册到日志器（Logger）中。注册的意思就是将日志写入器的接口添加到 writeList 中。 第 20 行，日志器的 Log() 方法可以将 interface{} 类型的 data 写入到注册过的日志写入器中。 第 23 行，遍历日志器拥有的所有日志写入器。 第 26 行，将本次日志的内容写入日志写入器。 第 31 行，创建日志器的实例。

这个例子中，为了最大程度地展示接口的用法，仅仅只是将数据直接写入日志写入器中。复杂一些的日志器还可以将日期、级别等信息合并到数据中一并写入日志。

#### 文件写入器

文件写入器（fileWriter）是众多日志写入器（LogWriter）中的一种。文件写入器的功能是根据一个文件名创建日志文件（fileWriter 的 SetFile 方法）。在有日志写入时，将日志写入文件中。

文件写入器代码：

```go
  package main

  import (
      "errors"
      "fmt"
      "os"
  )

  // 声明文件写入器
  type fileWriter struct {
      file *os.File
  }

  // 设置文件写入器写入的文件名
  func (f *fileWriter) SetFile(filename string) (err error) {

      // 如果文件已经打开, 关闭前一个文件
      if f.file != nil {
          f.file.Close()
      }

      // 创建一个文件并保存文件句柄
      f.file, err = os.Create(filename)

      // 如果创建的过程出现错误, 则返回错误
      return err
  }

  // 实现LogWriter的Write()方法
  func (f *fileWriter) Write(data interface{}) error {

      // 日志文件可能没有创建成功
      if f.file == nil {

          // 日志文件没有准备好
          return errors.New("file not created")
      }

      // 将数据序列化为字符串
      str := fmt.Sprintf("%v\n", data)

      // 将数据以字节数组写入文件中
      _, err := f.file.Write([]byte(str))

      return err
  }

  // 创建文件写入器实例
  func newFileWriter() *fileWriter {
      return &fileWriter{}
  }
```

代码说明如下：

- 第 10 行，声明文件写入器，在结构体中保存一个文件句柄，以方便每次写入时操作。

- 第 15 行，文件写入器通过文件名创建文件，这里通过 SetFile 的参数提供一个文件名，并创建文件。

- 第 18 行，考虑到 SetFile() 方法可以被多次调用（函数可重入性），假设之前已经调用过 SetFile() 后再次调用，此时的 f.file 不为空，就需要关闭之前的文件，重新创建新的文件。

- 第 23 行，根据文件名创建文件，如果发生错误，通过 SetFile 的返回值返回。

- 第 30 行，fileWriter 的 Write() 方法实现了 LogWriter 接口的 Write() 方法。

- 第 33 行，如果文件没有准备好，文件句柄为 nil，此时使用 errors 包的 New() 函数返回一个错误对象，包含一个字符串 “file not created”。

- 第 40 行，通过 Write() 方法传入的 data 参数是 interface{} 类型，而 f.file 的 Write() 方法需要的是 []byte 类型。使用 fmt.Sprintf 将 data 转换为字符串，这里使用的格式化参数是`%v`，意思是将 data 按其本来的值转换为字符串。

- 第 43 行，通过 f.file 的 Write() 方法，将 str 字符串转换为 []byte 字节数组，再写入到文件中。如果发生错误，则返回。

在操作文件时，会出现文件无法创建、无法写入等错误。开发中尽量不要忽略这些底层报出的错误，应该处理可能发生的所有错误。

文件使用完后，要注意使用 os.File 的 Close() 方法进行及时关闭，否则文件再次访问时会因为其属性出现无法读取、无法写入等错误。

##### 提示

一个完备的文件写入器会提供多种写入文件的模式，例子中使用的模式是将日志添加到日志文件的尾部。随着文件越来越大，文件的访问效率和查看便利性也会大大降低。此时，就需要另外一种写入模式：滚动写入文件。

滚动写入文件模式也是将日志添加到文件的尾部，但当文件达到设定的期望大小时，会自动开启一个新的文件继续写入文件，最终将获得多个日志文件。

日志文件名不仅可以按照文件大小进行分割，还可以按照日期范围进行分割。在到达设定的日期范围，如每天、每小时的周期范围时，日志器会自动创建新的日志文件。这种日志文件创建方法也能方便开发者按日志查看日志。

#### 命令行写入器

在 UNIX 的思想中，一切皆文件。文件包括内存、磁盘、网络和命令行等。这种抽象方法方便我们访问这些看不见摸不着的虚拟资源。命令行在 Go 语言中也是一种文件，os.Stdout 对应标准输出，一般表示屏幕，也就是命令行，也可以被重定向为打印机或者磁盘文件；os.Stderr 对应标准错误输出，一般将错误输出到日志中，不过大多数情况，os.Stdout 会与 os.Stderr 合并输出；os.Stdin 对应标准输入，一般表示键盘。os.Stdout、os.Stderr、os.Stdin 都是 *os.File 类型，和文件一样实现了 io.Writer 接口的 Write() 方法。

下面的代码展示如何将命令行抽象为日志写入器：

```go
  package main

  import (
      "fmt"
      "os"
  )

  // 命令行写入器
  type consoleWriter struct {
  }

  // 实现LogWriter的Write()方法
  func (f *consoleWriter) Write(data interface{}) error {

      // 将数据序列化为字符串
      str := fmt.Sprintf("%v\n", data)

      // 将数据以字节数组写入命令行中
      _, err := os.Stdout.Write([]byte(str))

      return err
  }

  // 创建命令行写入器实例
  func newConsoleWriter() *consoleWriter {
      return &consoleWriter{}
  }
```

代码说明如下：

- 第 9 行，声明 consoleWriter 结构，以实现命令行写入器。

- 第 13 行，consoleWriter 的 Write() 方法实现了日志写入接口（LogWriter）的 Write() 方法。

- 第 16 行，与 fileWriter 类似，这里也将 data 通过 fmt.Sprintf 序列化为字符串。

- 第 19 行，与 fileWriter 类似，这里也将 str 字符串转换为字节数组并写入标准输出 os.Stdout。写入后的内容就会显示在命令行中。

- 第 25 行，创建命令行写入器的实例。

除了命令行写入器（consoleWriter）和文件写入器（fileWriter），读者还可以自行使用 net 包中的 Socket 封装实现网络写入器 socketWriter，让日志可以写入远程的服务器中或者可以跨进程进行日志保存和分析。

#### 使用日志

在程序中使用日志器一般会先通过代码创建日志器（Logger），为日志器添加输出设备（fileWriter、consoleWriter 等）。这些设备中有一部分需要一些参数设定，如文件日志写入器需要提供文件名（fileWriter 的 SetFile() 方法）。

下面代码中展示了使用日志器的过程：

```go
  package main

  import "fmt"

  // 创建日志器
  func createLogger() *Logger {

      // 创建日志器
      l := NewLogger()

      // 创建命令行写入器
      cw := newConsoleWriter()

      // 注册命令行写入器到日志器中
      l.RegisterWriter(cw)

      // 创建文件写入器
      fw := newFileWriter()

      // 设置文件名
      if err := fw.SetFile("log.log"); err != nil {
              fmt.Println(err)
      }

      // 注册文件写入器到日志器中
      l.RegisterWriter(fw)

      return l
  }

  func main() {

      // 准备日志器
      l := createLogger()

      // 写一个日志
      l.Log("hello")
  }
```

代码说明如下：

- 第 6 行，一个创建日志的过程。这个过程一般隐藏在系统初始化中。程序启动时初始化一次。

- 第 9 行，创建一个日志器的实例，后面的代码会使用到它。

- 第 12 行，创建一个命令行写入器。如果全局有很多日志器，命令行写入器可以被共享，全局只会有一份。

- 第 18 行，创建一个文件写入器。一个程序的日志一般只有一个，因此不同的日志器也应该共享一个文件写入器。

- 第 21 行，创建好的文件写入器需要初始化写入的文件，通过文件名确定写入的文件。设置的过程可能会发生错误，发生错误时会输出错误信息。

- 第 26 行，将文件写入器注册到日志器中。

- 第 34 行，在程序一开始创建日志器。

- 第 37 行，往创建好的日志器中写入日志。

编译整个代码并运行，输出如下：

```go
hello
```

同时，当前目录的 log.log 文件中也会出现 hello 字符。

##### 提示

Go 语言的 log 包实现了一个小型的日志系统。这个日志系统可以在创建日志器时选择输出设备、日志前缀及 flag，函数定义如下：

```go
  func New(out io.Writer, prefix string, flag int) *Logger {
      return &Logger{out: out, prefix: prefix, flag: flag}
  }
```

在 flag 中，还可以定制日志中是否输出日期、日期精度和详细文件名等。

这个日志器在编写时，也最大程度地保证了输出的效率，如果读者对日志器的编写比较感兴趣，可以在 log 包的基础上进行扩展，形成方便自己使用的日志库。

### 7. 排序（借助sort.Interface接口）

排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要 15 行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。

幸运的是，sort 包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。

相比之下，Go语言的 sort.Sort 函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型 sort.Interface 来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。

一个内置的排序算法需要知道三个东西：序列的长度，表示两个元素比较的结果，一种交换两个元素的方式；这就是 sort.Interface 的三个方法：

```go
package sort
type Interface interface {
    Len() int            // 获取元素数量
    Less(i, j int) bool // i，j是序列元素的指数。
    Swap(i, j int)        // 交换元素
}
```

为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用 sort.Sort 函数。思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型 MyStringList 和它的 Len，Less 和 Swap 方法

```go
type MyStringList  []string
func (p MyStringList ) Len() int { return len(m) }
func (p MyStringList ) Less(i, j int) bool { return m[i] < m[j] }
func (p MyStringList ) Swap(i, j int) { m[i], m[j] = m[j], m[i] }
```

#### 使用sort.Interface接口进行排序

对一系列字符串进行排序时，使用字符串切片（[]string）承载多个字符串。使用 type 关键字，将字符串切片（[]string）定义为自定义类型 MyStringList。为了让 sort 包能识别 MyStringList，能够对 MyStringList 进行排序，就必须让 MyStringList 实现 sort.Interface 接口。

下面是对字符串排序的详细代码（代码1）：

```go
package main
import (
    "fmt"
    "sort"
)
// 将[]string定义为MyStringList类型
type MyStringList []string
// 实现sort.Interface接口的获取元素数量方法
func (m MyStringList) Len() int {
    return len(m)
}
// 实现sort.Interface接口的比较元素方法
func (m MyStringList) Less(i, j int) bool {
    return m[i] < m[j]
}
// 实现sort.Interface接口的交换元素方法
func (m MyStringList) Swap(i, j int) {
    m[i], m[j] = m[j], m[i]
}
func main() {
    // 准备一个内容被打乱顺序的字符串切片
    names := MyStringList{
        "3. Triple Kill",
        "5. Penta Kill",
        "2. Double Kill",
        "4. Quadra Kill",
        "1. First Blood",
    }
    // 使用sort包进行排序
    sort.Sort(names)
    // 遍历打印结果
    for _, v := range names {
            fmt.Printf("%s\n", v)
    }
}
```

代码输出结果：

```go
\1. First Blood
\2. Double Kill
\3. Triple Kill
\4. Quadra Kill
\5. Penta Kill
```

代码说明如下：

- 第 9 行，接口实现不受限于结构体，任何类型都可以实现接口。要排序的字符串切片 []string 是系统定制好的类型，无法让这个类型去实现 sort.Interface 排序接口。因此，需要将 []string 定义为自定义的类型。

- 第 12 行，实现获取元素数量的 Len() 方法，返回字符串切片的元素数量。

- 第 17 行，实现比较元素的 Less() 方法，直接取 m 切片的 i 和 j 元素值进行小于比较，并返回比较结果。

- 第 22 行，实现交换元素的 Swap() 方法，这里使用Go语言的多变量赋值特性实现元素交换。

- 第 29 行，由于将 []string 定义成 MyStringList 类型，字符串切片初始化的过程等效于下面的写法：

  ```go
  names := []string {
      "3. Triple Kill",
      "5. Penta Kill",
      "2. Double Kill",
      "4. Quadra Kill",
      "1. First Blood",
  }
  ```

- 第 38 行，使用 sort 包的 Sort() 函数，将 names（MyStringList类型）进行排序。排序时，sort 包会通过 MyStringList 实现的 Len()、Less()、Swap() 这 3 个方法进行数据获取和修改。

- 第 41 行，遍历排序好的字符串切片，并打印结果。

#### 常见类型的便捷排序

通过实现 sort.Interface 接口的排序过程具有很强的可定制性，可以根据被排序对象比较复杂的特性进行定制。例如，需要多种排序逻辑的需求就适合使用 sort.Interface 接口进行排序。但大部分情况中，只需要对字符串、整型等进行快速排序。Go语言中提供了一些固定模式的封装以方便开发者迅速对内容进行排序。

##### 1) 字符串切片的便捷排序

sort 包中有一个 StringSlice 类型，定义如下：

```go
type StringSlice []string
func (p StringSlice) Len() int           { return len(p) }
func (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p StringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
// Sort is a convenience method.
func (p StringSlice) Sort() { Sort(p) }
```

sort 包中的 StringSlice 的代码与 MyStringList 的实现代码几乎一样。因此，只需要使用 sort 包的 StringSlice 就可以更简单快速地进行字符串排序。将代码1中的排序代码简化后如下所示：

```go
names := sort.StringSlice{
    "3. Triple Kill",
    "5. Penta Kill",
    "2. Double Kill",
    "4. Quadra Kill",
    "1. First Blood",
}
sort.Sort(names)
```

简化后，只要两句代码就实现了字符串排序的功能。

##### 2) 对整型切片进行排序

除了字符串可以使用 sort 包进行便捷排序外，还可以使用 sort.IntSlice 进行整型切片的排序。sort.IntSlice 的定义如下：

```go
type IntSlice []int
func (p IntSlice) Len() int           { return len(p) }
func (p IntSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p IntSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
// Sort is a convenience method.
func (p IntSlice) Sort() { Sort(p) }
```

sort 包在 sort.Interface 对各类型的封装上还有更进一步的简化，下面使用 sort.Strings 继续对代码1进行简化，代码如下：

```go
names := []string{
    "3. Triple Kill",
    "5. Penta Kill",
    "2. Double Kill",
    "4. Quadra Kill",
    "1. First Blood",
}
sort.Strings(names)
// 遍历打印结果
for _, v := range names {
    fmt.Printf("%s\n", v)
}
```

代码说明如下：

- 第 1 行，需要排序的字符串切片。
- 第 9 行，使用 sort.Strings 直接对字符串切片进行排序。

##### 3) sort包内建的类型排序接口一览

Go语言中的 sort 包中定义了一些常见类型的排序方法，如下表所示。

| 类  型                | 实现 sort.lnterface 的类型 | 直接排序方法               | 说  明            |
| --------------------- | -------------------------- | -------------------------- | ----------------- |
| 字符串（String）      | StringSlice                | sort.Strings(a [] string)  | 字符 ASCII 值升序 |
| 整型（int）           | IntSlice                   | sort.Ints(a []int)         | 数值升序          |
| 双精度浮点（float64） | Float64Slice               | sort.Float64s(a []float64) | 数值升序          |


编程中经常用到的 int32、int64、float32、bool 类型并没有由 sort 包实现，使用时依然需要开发者自己编写。

#### 对结构体数据进行排序

除了基本类型的排序，也可以对结构体进行排序。结构体比基本类型更为复杂，排序时不能像数值和字符串一样拥有一些固定的单一原则。结构体的多个字段在排序中可能会存在多种排序的规则，例如，结构体中的名字按字母升序排列，数值按从小到大的顺序排序。一般在多种规则同时存在时，需要确定规则的优先度，如先按名字排序，再按年龄排序等。

##### 1) 完整实现sort.Interface进行结构体排序

将一批英雄名单使用结构体定义，英雄名单的结构体中定义了英雄的名字和分类。排序时要求按照英雄的分类进行排序，相同分类的情况下按名字进行排序，详细代码实现过程如下。

结构体排序代码（代码2）：

```go
package main
import (
    "fmt"
    "sort"
)
// 声明英雄的分类
type HeroKind int
// 定义HeroKind常量, 类似于枚举
const (
    None HeroKind = iota
    Tank
    Assassin
    Mage
)
// 定义英雄名单的结构
type Hero struct {
    Name string  // 英雄的名字
    Kind HeroKind  // 英雄的种类
}
// 将英雄指针的切片定义为Heros类型
type Heros []*Hero
// 实现sort.Interface接口取元素数量方法
func (s Heros) Len() int {
    return len(s)
}
// 实现sort.Interface接口比较元素方法
func (s Heros) Less(i, j int) bool {
    // 如果英雄的分类不一致时, 优先对分类进行排序
    if s[i].Kind != s[j].Kind {
        return s[i].Kind < s[j].Kind
    }
    // 默认按英雄名字字符升序排列
    return s[i].Name < s[j].Name
}
// 实现sort.Interface接口交换元素方法
func (s Heros) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
func main() {
    // 准备英雄列表
    heros := Heros{
        &Hero{"吕布", Tank},
        &Hero{"李白", Assassin},
        &Hero{"妲己", Mage},
        &Hero{"貂蝉", Assassin},
        &Hero{"关羽", Tank},
        &Hero{"诸葛亮", Mage},
    }
    // 使用sort包进行排序
    sort.Sort(heros)
    // 遍历英雄列表打印排序结果
    for _, v := range heros {
        fmt.Printf("%+v\n", v)
    }
}
```

代码输出如下：

```go
&{Name:关羽 Kind:1}
&{Name:吕布 Kind:1}
&{Name:李白 Kind:2}
&{Name:貂蝉 Kind:2}
&{Name:妲己 Kind:3}
&{Name:诸葛亮 Kind:3}
```

代码说明如下：

- 第 9 行，将 int 声明为 HeroKind 英雄类型，后面会将这个类型当做枚举来使用。
- 第 13 行，定义一些英雄类型常量，可以理解为枚举的值。
- 第 26 行，为了方便实现 sort.Interface 接口，将 []*Hero 定义为 Heros 类型。
- 第 29 行，Heros 类型实现了 sort.Interface 的 Len() 方法，返回英雄的数量。
- 第 34 行，Heros 类型实现了 sort.Interface 的 Less() 方法，根据英雄字段的比较结果决定如何排序。
- 第 37 行，当英雄的分类不一致时，优先按分类的枚举数值从小到大排序。
- 第 42 行，英雄分类相等的情况下，默认根据英雄的名字字符升序排序。
- 第 46 行，Heros 类型实现了 sort.Interface 的 Swap() 方法，交换英雄元素的位置。
- 第 53～60 行，准备一系列英雄数据。
- 第 63 行，使用 sort 包进行排序。
- 第 66 行，遍历所有排序完成的英雄数据。

##### 2) 使用sort.Slice进行切片元素排序

从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice() 函数进行更为简便的排序方法。sort.Slice() 函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为 func(i,j int)bool，sort.Slice() 函数的定义如下：

```go
func Slice(slice interface{}, less func(i, j int) bool)
```

使用 sort.Slice() 函数，对代码2重新优化的完整代码如下：

```go
package main
import (
    "fmt"
    "sort"
)
type HeroKind int
const (
    None = iota
    Tank
    Assassin
    Mage
)
type Hero struct {
    Name string
    Kind HeroKind
}
func main() {
    heros := []*Hero{
        {"吕布", Tank},
        {"李白", Assassin},
        {"妲己", Mage},
        {"貂蝉", Assassin},
        {"关羽", Tank},
        {"诸葛亮", Mage},
    }
    sort.Slice(heros, func(i, j int) bool {
        if heros[i].Kind != heros[j].Kind {
            return heros[i].Kind < heros[j].Kind
        }
        return heros[i].Name < heros[j].Name
    })
    for _, v := range heros {
        fmt.Printf("%+v\n", v)
    }
}
```

第 33 行到第 39 行加粗部分是新添加的 sort.Slice() 及回调函数部分。对比前面的代码，这里去掉了 Heros 及接口实现部分的代码。

使用 sort.Slice() 不仅可以完成结构体切片排序，还可以对各种切片类型进行自定义排序。

### 8. 接口的嵌套组合

在Go语言中，不仅结构体与结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。

一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。只要接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用。

#### 系统包中的接口嵌套组合

Go语言的 io 包中定义了写入器（Writer）、关闭器（Closer）和写入关闭器（WriteCloser）3 个接口，代码如下：

```go
type Writer interface {
    Write(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
type WriteCloser interface {
    Writer
    Closer
}
```

代码说明如下：

- 第 1 行定义了写入器（Writer），如这个接口较为常用，常用于 I/O 设备的数据写入。
- 第 5 行定义了关闭器（Closer），如有非托管内存资源的对象，需要用关闭的方法来实现资源释放。
- 第 9 行定义了写入关闭器（WriteCloser），这个接口由 Writer 和 Closer 两个接口嵌入。也就是说，WriteCloser 同时拥有了 Writer 和 Closer 的特性。

#### 在代码中使用接口嵌套组

在代码中使用 io.Writer、io.Closer 和 io.WriteCloser 这 3 个接口时，只需要按照接口实现的规则实现 io.Writer 接口和 io.Closer 接口即可。而 io.WriteCloser 接口在使用时，编译器会根据接口的实现者确认它们是否同时实现了 io.Writer 和 io.Closer 接口，详细实现代码如下：

```go
package main
import (
    "io"
)
// 声明一个设备结构
type device struct {
}
// 实现io.Writer的Write()方法
func (d *device) Write(p []byte) (n int, err error) {
    return 0, nil
}
// 实现io.Closer的Close()方法
func (d *device) Close() error {
    return nil
}
func main() {
    // 声明写入关闭器, 并赋予device的实例
    var wc io.WriteCloser = new(device)
    // 写入数据
    wc.Write(nil)
    // 关闭设备
    wc.Close()
    // 声明写入器, 并赋予device的新实例
    var writeOnly io.Writer = new(device)
    // 写入数据
    writeOnly.Write(nil)
}
```

代码说明如下：

- 第 8 行定义了 device 结构体，用来模拟一个虚拟设备，这个结构会实现前面提到的 3 种接口。
- 第 12 行，实现了 io.Writer 的 Write() 方法。
- 第 17 行，实现了 io.Closer 的 Close() 方法。
- 第 24 行，对 device 实例化，由于 device 实现了 io.WriteCloser 的所有嵌入接口，因此 device 指针就会被隐式转换为 io.WriteCloser 接口。
- 第 27 行，调用了 wc（io.WriteCloser接口）的 Write() 方法，由于 wc 被赋值 *device，因此最终会调用 device 的 Write() 方法。
- 第 30 行，与 27 行类似，最终调用 device 的 Close() 方法。
- 第 33 行，再次创建一个 device 的实例，writeOnly 是一个 io.Writer 接口，这个接口只有 Write() 方法。
- 第 36 行，writeOnly 只能调用 Write() 方法，没有 Close() 方法。


为了整理思路，将上面的实现、调用关系使用图方式来展现，参见图 1 和图 2。

1) io.WriteCloser的实现及调用过程如图 1 所示。



![img](http://c.biancheng.net/uploads/allimg/180816/1-1PQ61125141Z.jpg)
图1：io.WriteCloser 的实现及调用过程


2) io.Writer 的实现调用过程如图 2 所示。



![img](http://c.biancheng.net/uploads/allimg/180816/1-1PQ6112952232.jpg)
图2：io.Write 的实现及调用过程


给 io.WriteCloser 或 io.Writer 更换不同的实现者，可以动态地切换实现代码。

### 9. 接口和类型之间的转换

Go语言中使用接口断言（type assertions）将接口转换成另外一个接口，也可以将接口转换为另外的类型。接口的转换在开发中非常常见，使用也非常频繁。

#### 类型断言的格式

类型断言是一个使用在接口值上的操作。语法上它看起来像 i.(T) 被称为断言类型，这里 i 表示一个接口的类型和 T 表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。

类型断言的基本格式如下：

```go
t := i.(T)
```

其中，i 代表接口变量，T 代表转换的目标类型，t 代表转换后的变量。

这里有两种可能。第一种，如果断言的类型 T 是一个具体类型，然后类型断言检查 i 的动态类型是否和 T 相同。如果这个检查成功了，类型断言的结果是 i 的动态值，当然它的类型是 T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出 panic。例如：

```go
var w io.Writer
w = os.Stdout
f := w.(*os.File) // 成功: f == os.Stdout
c := w.(*bytes.Buffer) // 死机：接口保存*os.file，而不是*bytes.buffer
```

第二种，如果相反断言的类型 T 是一个接口类型，然后类型断言检查是否 i 的动态类型满足 T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型 T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保护了接口值内部的动态类型和值的部分。

在下面的第一个类型断言后，w 和 rw 都持有 os.Stdout 因此它们每个有一个动态类型 *os.File，但是变量 w 是一个 io.Writer 类型只对外公开出文件的 Write 方法，然而 rw 变量也只公开它的 Read 方法。

```go
var w io.Writer
w = os.Stdout
rw := w.(io.ReadWriter) // 成功：*os.file具有读写功能
w = new(ByteCounter)
rw = w.(io.ReadWriter) // 死机：*字节计数器没有读取方法
```

如果断言操作的对象是一个 nil 接口值，那么不论被断言的类型是什么这个类型断言都会失败。几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于 nil 接口值的情况。

如果 i 没有完全实现 T 接口的方法，这个语句将会触发宕机。触发宕机不是很友好，因此上面的语句还有一种写法：

```go
t,ok := i.(T)
```

这种写法下，如果发生接口未实现时，将会把 ok 置为 false，t 置为 T 类型的 0 值。正常实现时，ok 为 true。这里 ok 可以被认为是：i 接口是否实现 T 类型的结果。

#### 将接口转换为其他接口

实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。

鸟和猪具有不同的特性，鸟可以飞，猪不能飞，但两种动物都可以行走。如果使用结构体实现鸟和猪，让它们具备自己特性的 Fly() 和 Walk() 方法就让鸟和猪各自实现了飞行动物接口（Flyer）和行走动物接口（Walker）。

将鸟和猪的实例创建后，被保存到 interface{} 类型的 map 中。interface{} 类型表示空接口，意思就是这种接口可以保存为任意类型。对保存有鸟或猪的实例的 interface{} 变量进行断言操作，如果断言对象是断言指定的类型，则返回转换为断言对象类型的接口；如果不是指定的断言类型时，断言的第二个参数将返回 false。例如下面的代码：

```go
var obj interface = new(bird)
f, isFlyer := obj.(Flyer)
```

代码中，new(bird) 产生 *bird 类型的 bird 实例，这个实例被保存在 interface{} 类型的 obj 变量中。使用 obj.(Flyer) 类型断言，将 obj 转换为 Flyer 接口。f 为转换成功时的 Flyer 接口类型，isFlyer 表示是否转换成功，类型就是 bool。

下面是详细的代码（代码1）：

```go
package main
import "fmt"
// 定义飞行动物接口
type Flyer interface {
    Fly()
}
// 定义行走动物接口
type Walker interface {
    Walk()
}
// 定义鸟类
type bird struct {
}
// 实现飞行动物接口
func (b *bird) Fly() {
    fmt.Println("bird: fly")
}
// 为鸟添加Walk()方法, 实现行走动物接口
func (b *bird) Walk() {
    fmt.Println("bird: walk")
}
// 定义猪
type pig struct {
}
// 为猪添加Walk()方法, 实现行走动物接口
func (p *pig) Walk() {
    fmt.Println("pig: walk")
}
func main() {
// 创建动物的名字到实例的映射
    animals := map[string]interface{}{
        "bird": new(bird),
        "pig":  new(pig),
    }
    // 遍历映射
    for name, obj := range animals {
        // 判断对象是否为飞行动物
        f, isFlyer := obj.(Flyer)
        // 判断对象是否为行走动物
        w, isWalker := obj.(Walker)
        fmt.Printf("name: %s isFlyer: %v isWalker: %v\n", name, isFlyer, isWalker)
        // 如果是飞行动物则调用飞行动物接口
        if isFlyer {
            f.Fly()
        }
        // 如果是行走动物则调用行走动物接口
        if isWalker {
            w.Walk()
        }
    }
}
```

代码说明如下：

- 第 6 行定义了飞行动物的接口。
- 第 11 行定义了行走动物的接口。
- 第 16 和 30 行分别定义了鸟和猪两个对象，并分别实现了飞行动物和行走动物接口。
- 第 41 行是一个 map，映射对象名字和对象实例，实例是鸟和猪。
- 第 47 行开始遍历 map，obj 为 interface{} 接口类型。
- 第 50 行中，使用类型断言获得 f，类型为 Flyer 及 isFlyer 的断言成功的判定。
- 第 52 行中，使用类型断言获得 w，类型为 Walker 及 isWalker 的断言成功的判定。
- 第 57 和 62 行，根据飞行动物和行走动物两者是否断言成功，调用其接口。


代码输出如下：

```go
name: pig isFlyer: false isWalker: true
pig: walk
name: bird isFlyer: true isWalker: true
bird: fly
bird: walk
```

#### 将接口转换为其他类型

在代码 1 中，可以实现将接口转换为普通的指针类型。例如将 Walker 接口转换为 *pig 类型，请参考下面的代码：

```go
p1 := new(pig)
var a Walker = p1
p2 := a.(*pig)
fmt.Printf("p1=%p p2=%p", p1, p2)
```

对代码的说明如下：

- 第 3 行，由于 pig 实现了 Walker 接口，因此可以被隐式转换为 Walker 接口类型保存于 a 中。
- 第 4 行，由于 a 中保存的本来就是 *pig 本体，因此可以转换为 *pig 类型。
- 第 6 行，对比发现，p1 和 p2 指针是相同的。


如果尝试将上面这段代码中的 Walker 类型的 a 转换为 *bird 类型，将会发出运行时错误，请参考下面的代码：

```go
p1 := new(pig)
var a Walker = p1
p2 := a.(*bird)
```

运行时报错：

```go
panic: interface conversion: main.Walker is *main.pig, not *main.bird
```

报错意思是：接口转换时，main.Walker 接口的内部保存的是 *main.pig，而不是 *main.bird。

因此，接口在转换为其他类型时，接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。

##### 总结

接口和其他类型的转换可以在Go语言中自由进行，前提是已经完全实现。

接口断言类似于流程控制中的 if。但大量类型断言出现时，应使用更为高效的类型分支 switch 特性。

### 10. 空接口类型（interface{}）

空接口是接口类型的特殊形式，空接口没有任何方法，因此任何类型都无须实现空接口。从实现的角度看，任何值都满足这个接口的需求。因此空接口类型可以保存任何值，也可以从空接口中取出原值。

#### 提示

空接口类型类似于 [C#](http://c.biancheng.net/csharp/) 或 [Java](http://c.biancheng.net/java/) 语言中的 Object、C语言中的 void*、[C++](http://c.biancheng.net/cplus/) 中的 std::any。在泛型和模板出现前，空接口是一种非常灵活的数据抽象保存和使用的方法。

空接口的内部实现保存了对象的类型和指针。使用空接口保存一个数据的过程会比直接用数据对应类型的变量保存稍慢。因此在开发中，应在需要的地方使用空接口，而不是在所有地方使用空接口。

#### 将值保存到空接口

空接口的赋值如下：

```go
var any interface{}
any = 1
fmt.Println(any)
any = "hello"
fmt.Println(any)
any = false
fmt.Println(any)
```

代码输出如下：

```go
1
hello
false
```

对代码的说明：

- 第 1 行，声明 any 为 interface{} 类型的变量。
- 第 3 行，为 any 赋值一个整型 1。
- 第 4 行，打印 any 的值，提供给 fmt.Println 的类型依然是 interface{}。
- 第 6 行，为 any 赋值一个字符串 hello。此时 any 内部保存了一个字符串。但类型依然是 interface{}。
- 第 9 行，赋值布尔值。

#### 从空接口获取值

保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误，代码如下：

```go
// 声明a变量, 类型int, 初始值为1
var a int = 1
// 声明i变量, 类型为interface{}, 初始值为a, 此时i的值变为1
var i interface{} = a
// 声明b变量, 尝试赋值i
var b int = i
```

第8行代码编译报错：

```go
cannot use i (type interface {}) as type int in assignment: need type assertion
```

编译器告诉我们，不能将i变量视为int类型赋值给b。

在代码第 15 行中，将 a 的值赋值给 i 时，虽然 i 在赋值完成后的内部值为 int，但 i 还是一个 interface{} 类型的变量。类似于无论集装箱装的是茶叶还是烟草，集装箱依然是金属做的，不会因为所装物的类型改变而改变。

为了让第 8 行的操作能够完成，编译器提示我们得使用 type assertion，意思就是类型断言。

使用类型断言修改第 8 行代码如下：

```go
var b int = i.(int)
```

修改后，代码可以编译通过，并且 b 可以获得 i 变量保存的 a 变量的值：1。

##### 空接口的值比较

空接口在保存不同的值后，可以和其他变量值一样使用`==`进行比较操作。空接口的比较有以下几种特性。

###### 1) 类型不同的空接口间的比较结果不相同

保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的，代码如下：

```go
// a保存整型
var a interface{} = 100
// b保存字符串
var b interface{} = "hi"
// 两个空接口不相等
fmt.Println(a == b)
```

代码输出如下：

```go
false
```

###### 2) 不能比较空接口中的动态值

当接口中保存有动态类型的值时，运行时将触发错误，代码如下：

```go
// c保存包含10的整型切片
var c interface{} = []int{10}
// d保存包含20的整型切片
var d interface{} = []int{20}
// 这里会发生崩溃
fmt.Println(c == d)
```

代码运行到第8行时发生崩溃：

```go
panic: runtime error: comparing uncomparable type []int
```

这是一个运行时错误，提示 []int 是不可比较的类型。下表中列举出了类型及比较的几种情况。



| 类  型          | 说  明                                                       |
| --------------- | ------------------------------------------------------------ |
| map             | 宕机错误，不可比较                                           |
| 切片（[]T）     | 宕机错误，不可比较                                           |
| 通道（channel） | 可比较，必须由同一个 make 生成，也就是同一个通道才会是 true，否则为 false |
| 数组（[容量]T） | 可比较，编译期知道两个数组是否一致                           |
| 结构体          | 可比较，可以逐个比较结构体的值                               |
| 函数            | 可比较                                                       |



### 11. 使用空接口实现可以保存任意值的字典

空接口可以保存任何类型这个特性可以方便地用于容器的设计。下面例子使用 map 和 interface{} 实现了一个字典。字典在其他语言中的功能和 map 类似，可以将任意类型的值做成键值对保存，然后进行找回、遍历操作。详细实现过程请参考下面的代码。

```go
  package main

  import "fmt"

  // 字典结构
  type Dictionary struct {
      data map[interface{}]interface{} // 键值都为interface{}类型
  }

  // 根据键获取值
  func (d *Dictionary) Get(key interface{}) interface{} {
      return d.data[key]
  }

  // 设置键值
  func (d *Dictionary) Set(key interface{}, value interface{}) {

      d.data[key] = value
  }

  // 遍历所有的键值，如果回调返回值为false，停止遍历
  func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {

      if callback == nil {
          return
      }

      for k, v := range d.data {
          if !callback(k, v) {
              return
          }
      }
  }

  // 清空所有的数据
  func (d *Dictionary) Clear() {
      d.data = make(map[interface{}]interface{})
  }

  // 创建一个字典
  func NewDictionary() *Dictionary {
      d := &Dictionary{}

      // 初始化map
      d.Clear()
      return d
  }

  func main() {

      // 创建字典实例
      dict := NewDictionary()

      // 添加游戏数据
      dict.Set("My Factory", 60)
      dict.Set("Terra Craft", 36)
      dict.Set("Don't Hungry", 24)

      // 获取值及打印值
      favorite := dict.Get("Terra Craft")
      fmt.Println("favorite:", favorite)

      // 遍历所有的字典元素
      dict.Visit(func(key, value interface{}) bool {

          // 将值转为int类型，并判断是否大于40
          if value.(int) > 40 {

              // 输出很贵
              fmt.Println(key, "is expensive")
              return true
          }

          // 默认都是输出很便宜
          fmt.Println(key, "is cheap")

          return true
      })
  }
```

#### 值设置和获取

字典内部拥有一个 data 字段，其类型为 map。这个 map 的键和值都是 interface{} 类型，也就是实现任意类型关联任意类型。字典的值设置和获取通过 Set() 和 Get() 两个方法来完成，参数都是 interface{}。详细实现代码如下：

```go
  // 字典结构
  type Dictionary struct {
      data map[interface{}]interface{}  // 键值都为interface{}类型
  }

  // 根据键获取值
  func (d *Dictionary) Get(key interface{}) interface{} {
      return d.data[key]
  }

  // 设置键值
  func (d *Dictionary) Set(key interface{}, value interface{}) {
      d.data[key] = value
  }
```

代码说明如下：

- 第 3 行，Dictionary 的内部实现是一个键值均为 interface{} 类型的 map，map 也具备与 Dictionary 一致的功能。

- 第 8 行，通过 map 直接获取值，如果键不存在，将返回 nil。

- 第 13 行，通过 map 设置键值。

#### 遍历字段的所有键值关联数据

每个容器都有遍历操作。遍历时，需要提供一个回调返回需要遍历的数据。为了方便在必要时终止遍历操作，可以将回调的返回值设置为 bool 类型，外部逻辑在回调中不需要遍历时直接返回 false 即可终止遍历。

Dictionary 的 Visit() 方法需要传入回调函数，回调函数的类型为 func(k,v interface{})bool。每次遍历时获得的键值关联数据通过回调函数的 k 和 v 参数返回。Visit 的详细实现请参考下面的代码：

```go
  // 遍历所有的键值, 如果回调返回值为false, 停止遍历
  func (d *Dictionary) Visit(callback func(k, v interface{}) bool) {

      if callback == nil {
          return
      }

      for k, v := range d.data {
          if !callback(k, v) {
              return
          }
      }
  }
```

代码说明如下：

- 第 2 行，定义回调，类型为 func(k,v interface{})bool，意思是返回键值数据（k、v）。bool 表示遍历流程控制，返回 true 时继续遍历，返回 false 时终止遍历。

- 第 4 行，当 callback 为空时，退出遍历，避免后续代码访问空的 callback 而导致的崩溃。

- 第 8 行，遍历字典结构的 data 成员，也就是遍历 map 的所有元素。

- 第 9 行，根据 callback 的返回值，决定是否继续遍历。

#### 初始化和清除

字典结构包含有 map，需要在创建 Dictionary 实例时初始化 map。这个过程通过 Dictionary 的 Clear() 方法完成。在 NewDictionary 中调用 Clear() 方法避免了 map 初始化过程的代码重复问题。请参考下面的代码：

```go
  // 清空所有的数据
  func (d *Dictionary) Clear() {
      d.data = make(map[interface{}]interface{})
  }

  // 创建一个字典
  func NewDictionary() *Dictionary {
      d := &Dictionary{}

      // 初始化map
      d.Clear()
      return d
  }
```

代码说明如下：

- 第 3 行，map 没有独立的复位内部元素的操作，需要复位元素时，使用 make 创建新的实例。Go 语言的垃圾回收是并行的，不用担心 map 清除的效率问题。

- 第 7 行，实例化一个 Dictionary。

- 第 11 行，在初始化时调用 Clear 进行 map 初始化操作。

#### 使用字典

字典实现完成后，需要经过一个测试过程，查看这个字典是否存在问题。

将一些字符串和数值组合放入到字典中，然后再从字典中根据键查询出对应的值，接着再遍历一个字典中所有的元素。详细实现过程请参考下面的代码：

```go
  func main() {

      // 创建字典实例
      dict := NewDictionary()

      // 添加游戏数据
      dict.Set("My Factory", 60)
      dict.Set("Terra Craft", 36)
      dict.Set("Don't Hungry", 24)

      // 获取值及打印值
      favorite := dict.Get("Terra Craft")
      fmt.Println("favorite:", favorite)

      // 遍历所有的字典元素
      dict.Visit(func(key, value interface{}) bool {

          // 将值转为int类型, 并判断是否大于40
          if value.(int) > 40 {

              // 输出“很贵”
              fmt.Println(key, "is expensive")
              return true
          }

          // 默认都是输出“很便宜”
          fmt.Println(key, "is cheap")

          return true
      })
  }
```

代码说明如下：

- 第 4 行创建字典的实例。

- 第 7～9 行，将 3 组键值对通过字典的 Set() 方法设置到字典中。

- 第 12 行，根据字符串键查找值，将结果保存在 favorite 中。

- 第 13 行，打印 favorite 的值。

- 第 16 行，遍历字典的所有键值对。遍历的返回数据通过回调提供，key 是键，value 是值。

- 第 19 行，遍历返回的 key 和 value 的类型都是 interface{}，这里确认 value 只有 int 类型，所以将 value 转换为 int 类型判断是否大于 40。

- 第 23 和 29 行，继续遍历，返回 true

- 第 23 行，打印键。

运行代码，输出如下：

```go
favorite: 36 My Factory is expensive Terra Craft is cheap Don’t Hungry is chea
```

### 12. 类型分支（switch判断空接口中变量的类型）

type-switch 流程控制的语法或许是Go语言中最古怪的语法。 它可以被看作是类型断言的增强版。它和 switch-case 流程控制代码块有些相似。 一个 type-switch 流程控制代码块的语法如下所示：

```go
switch t := areaIntf.(type) {
case *Square:
    fmt.Printf("Type Square %T with value %v\n", t, t)
case *Circle:
    fmt.Printf("Type Circle %T with value %v\n", t, t)
case nil:
    fmt.Printf("nil value: nothing to check?\n")
default:
    fmt.Printf("Unexpected type %T\n", t)
}
```

输出结构如下：

```go
Type Square *main.Square with value &{5
```

变量 t 得到了 areaIntf 的值和类型， 所有 case 语句中列举的类型（nil 除外）都必须实现对应的接口，如果被检测类型没有在 case 语句列举的类型中，就会执行 default 语句。

如果跟随在某个 case 关键字后的条目为一个非接口类型（用一个类型名或类型字面表示），则此非接口类型必须实现了断言值 x 的（接口）类型。

#### 类型断言的书写格式

switch 实现类型分支时的写法格式如下：

```go
switch 接口变量.(type) {
    case 类型1:
        // 变量是类型1时的处理
    case 类型2:
        // 变量是类型2时的处理
    …
    default:
        // 变量不是所有case中列举的类型时的处理
}
```

对各个部分的说明：

- 接口变量：表示需要判断的接口类型的变量。
- 类型1、类型2……：表示接口变量可能具有的类型列表，满足时，会指定 case 对应的分支进行处理。

#### 使用类型分支判断基本类型

下面的例子将一个 interface{} 类型的参数传给 printType() 函数，通过 switch 判断 v 的类型，然后打印对应类型的提示，代码如下：

```go
package main
import (
    "fmt"
)
func printType(v interface{}) {
    switch v.(type) {
    case int:
        fmt.Println(v, "is int")
    case string:
        fmt.Println(v, "is string")
    case bool:
        fmt.Println(v, "is bool")
    }
}
func main() {
    printType(1024)
    printType("pig")
    printType(true)
}
```

代码输出如下：

```go
1024 is int
pig is string
true is bool
```

代码第 9 行中，v.(type) 就是类型分支的典型写法。通过这个写法，在 switch 的每个 case 中写的将是各种类型分支。

代码经过 switch 时，会判断 v 这个 interface{} 的具体类型从而进行类型分支跳转。

switch 的 default 也是可以使用的，功能和其他的 switch 一致。

#### 使用类型分支判断接口类型

多个接口进行类型断言时，可以使用类型分支简化判断过程。

现在电子支付逐渐成为人们普遍使用的支付方式，电子支付相比现金支付具备很多优点。例如，电子支付能够刷脸支付，而现金支付容易被偷等。使用类型分支可以方便地判断一种支付方法具备哪些特性，具体请参考下面的代码。

电子支付和现金支付：

```go
package main
import "fmt"
// 电子支付方式
type Alipay struct {
}
// 为Alipay添加CanUseFaceID()方法, 表示电子支付方式支持刷脸
func (a *Alipay) CanUseFaceID() {
}
// 现金支付方式
type Cash struct {
}
// 为Cash添加Stolen()方法, 表示现金支付方式会出现偷窃情况
func (a *Cash) Stolen() {
}
// 具备刷脸特性的接口
type CantainCanUseFaceID interface {
    CanUseFaceID()
}
// 具备被偷特性的接口
type ContainStolen interface {
    Stolen()
}
// 打印支付方式具备的特点
func print(payMethod interface{}) {
    switch payMethod.(type) {
    case CantainCanUseFaceID:  // 可以刷脸
        fmt.Printf("%T can use faceid\n", payMethod)
    case ContainStolen:  // 可能被偷
        fmt.Printf("%T may be stolen\n", payMethod)
    }
}
func main() {
    // 使用电子支付判断
    print(new(Alipay))
    // 使用现金判断
    print(new(Cash))
}
```

代码说明如下：

- 第 6～19 行，分别定义 Alipay 和 Cash 结构，并为它们添加具备各自特点的方法。
- 第 22～29 行，定义两种特性，即刷脸和被偷。
- 第 32 行，传入支付方式的接口。
- 第 33 行，使用类型分支进行支付方法的特性判断。
- 第 34～37 行，分别对刷脸和被偷的特性进行打印。


运行代码，输出如下：

```go
*main.Alipay can use faceid
*main.Cash may be stolen
```

### 13. error接口：返回错误信息

错误处理在每个编程语言中都是一项重要内容，通常开发中遇到的分为异常与错误两种，Go语言中也不例外。本节我们主要来学习一下Go语言中的错误处理。

在C语言中通过返回 -1 或者 NULL 之类的信息来表示错误，但是对于使用者来说，如果不查看相应的 API 说明文档，根本搞不清楚这个返回值究竟代表什么意思，比如返回 0 是成功还是失败？

针对这样的情况，Go语言中引入 error 接口类型作为错误处理的标准模式，如果函数要返回错误，则返回值类型列表中肯定包含 error。error 处理过程类似于C语言中的错误码，可逐层返回，直到被处理。

#### error 基本用法

Go语言中返回的 error 类型究竟是什么呢？查看Go语言的源码就会发现 error 类型是一个非常简单的接口类型，如下所示：

```go
// The error built-in interface type is the conventional interface for
// representing an error condition, with the nil value representing no error.
type error interface {
    Error() string
}
```

error 接口有一个签名为 Error() string 的方法，所有实现该接口的类型都可以当作一个错误类型。Error() 方法给出了错误的描述，在使用 fmt.Println 打印错误时，会在内部调用 Error() string 方法来得到该错误的描述。

一般情况下，如果函数需要返回错误，就将 error 作为多个返回值中的最后一个（但这并非是强制要求）。

创建一个 error 最简单的方法就是调用 errors.New 函数，它会根据传入的错误信息返回一个新的 error，示例代码如下：

```go
package main
import (
    "errors"
    "fmt"
    "math"
)
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return -1, errors.New("math: square root of negative number")
    }
    return math.Sqrt(f), nil
}
func main() {
    result, err := Sqrt(-13)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(result)
    }
}
```

运行结果如下：

```go
math: square root of negative numbe
```

上面代码中简单介绍了使用 errors.New 来返回一个错误信息，与其他语言的异常相比，Go语言的方法相对更加容易、直观。

#### 自定义错误类型

除了上面的 errors.New 用法之外，我们还可以使用 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。

```go
package main
import (
    "fmt"
    "math"
)
type dualError struct {
    Num     float64
    problem string
}
func (e dualError) Error() string {
    return fmt.Sprintf("Wrong!!!,because \"%f\" is a negative number", e.Num)
}
func Sqrt(f float64) (float64, error) {
    if f < 0 {
        return -1, dualError{Num: f}
    }
    return math.Sqrt(f), nil
}
func main() {
    result, err := Sqrt(-13)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Println(result)
    }
}
```

运行结果如下：

```go
Wrong!!!,because "-13.000000" is a negative number
```



### 14.  接口内部实现

前几节我们介绍了接口的基本概念和用法，定义接口只需简单声明一个方法集合即可，定义新类型时不需要显式地声明要实现的接口，接口的使用也很简单。

那么接口的底层是如何实现的呢？如何实现动态调用的呢？接口的动态调用到底有多大的额外开销？本节我们就来深入讲解一下接口的底层实现。

阅读本节需要读者了解 Go 语言接口的基础知识和 Go 语言汇编基础和函数调用规约，以及对 ELF 可执行文件格式有基本了解。本节内容有点偏底层，有一定的难度，如果阅读起来有困难，可以先跳过去，有时间再慢慢读。

#### 数据结构

从前面章节了解到，接口变量必须初始化才有意义，没有初始化的接口变量的默认值是 nil，没有任何意义。具体类型实例传递给接口称为接口的实例化。在接口的实例化的过程中，编译器通过特定的数据结构描述这个过程。

首先介绍非空接口的内部数据结构，空接口的底层更简单，放到最后介绍。非空接口的底层数据结构是 iface，代码位于 Go 语言安装目录的 src/runtime/runtime2.go 文件中。

##### iface 数据结构

非空接口初始化的过程就是初始化一个 iface 类型的结构，示例如下：

```go
  //src/runtime/runtime2.go
  type iface struct {
      tab *itab                //itab 存放类型及方法指针信息
      data unsafe.Pointer      //数据信息
  }
```

可以看到 iface 结构很简单，有两个指针类型字段。

- itab：用来存放接口自身类型和绑定的实例类型及实例相关的函数指针，具体内容后面有详细介绍。

- 数据指针 data：指向接口绑定的实例的副本，接口的初始化也是一种值拷贝。

data 指向具体的实例数据，如果传递给接口的是值类型，则 data 指向的是实例的副本；如果传递给接口的是指针类型，则 data 指向指针的副本。总而言之，无论接口的转换，还是函数调用，Go 遵循一样的规则——值传递。

接下来看一下 itab 数据结构，itab 是接口内部实现的核心和基础。示例如下：

```go
  //src/runtime/runtime2.go
  type itab struct {
      inter *interfacetype      //接口自身的静态类型
      _type *_type              //_type 就是接口存放的具体实例的类型（动态类型）
      //hash 存放具体类型的 Hash 值
      hash uint32               // copy of _type.hash. Used for type switches.
      _   [4]byte
      fun [1]uintptr            // variable sized. fun[0]==0 means _type does not implement inter.
  }
```

itab 有 5 个字段：

- inner：是指向接口类型元信息的指针。

- _type：是指向接口存放的具体类型元信息的指针，iface 里的 data 指针指向的是该类型的值。一个是类型信息，另一个是类型的值。

- hash：是具体类型的 Hash 值，_type 里面也有 hash，这里冗余存放主要是为了接口断言或类型查询时快速访问。

- fun：是一个函数指针，可以理解为 C++ 对象模型里面的虚拟函数指针，这里虽然只有一个元素，实际上指针数组的大小是可变的，编译器负责填充，运行时使用底层指针进行访问，不会受 struct 类型越界检查的约束，这些指针指向的是具体类型的方法。

itab 这个数据结构是非空接口实现动态调用的基础，itab 的信息被编译器和链接器保存了下来，存放在可执行文件的只读存储段（.rodata）中。itab 存放在静态分配的存储空间中，不受 GC 的限制，其内存不会被回收。

接下来介绍 _type 数据结构，Go 语言是一种强类型的语言，编译器在编译时会做严格的类型校验。所以 Go 必然为每种类型维护一个类型的元信息，这个元信息在运行和反射时都会用到，Go 语言的类型元信息的通用结构是 _type（代码位于 src/runtime/type.go）， 其他类型都是以 _type 为内嵌宇段封装而成的结构体。

```go
  //src/runtime/type.go
  type type struct {
      size uintptr     // 大小
      ptrdata uintptr  //size of memory prefix holding all pointers
      hash uint32      //类型Hash
      tflag tflag      //类型的特征标记
      align uint8      //_type 作为整体交量存放时的对齐字节数
      fieldalign uint8 //当前结构字段的对齐字节数
      kind uint8       //基础类型枚举值和反射中的 Kind 一致，kind 决定了如何解析该类型
      alg *typeAlg     //指向一个函数指针表，该表有两个函数，一个是计算类型 Hash 函
                       //数，另一个是比较两个类型是否相同的 equal 函数
      //gcdata stores the GC type data for the garbage collector.
      //If the KindGCProg bit is set in kind, gcdata is a GC program.
      //Otherwise it is a ptrmask bitmap. See mbitmap.go for details.
      gcdata *byte      //GC 相关信息
      str nameOff       //str 用来表示类型名称字符串在编译后二进制文件中某个 section
                        //的偏移量
                        //由链接器负责填充
      ptrToThis typeOff //ptrToThis 用来表示类型元信息的指针在编译后二进制文件中某个
                        //section 的偏移量
                        //由链接器负责填充
  }
```

_type 包含所有类型的共同元信息，编译器和运行时可以根据该元信息解析具体类型、类型名存放位置、类型的 Hash 值等基本信息。

这里需要说明一下：＿type 里面的 nameOff 和 typeOff 最终是由链接器负责确定和填充的，它们都是一个偏移量（offset），类型的名称和类型元信息实际上存放在连接后可执行文件的某个段（section）里，这两个值是相对于段内的偏移量，运行时提供两个转换查找函数。例如：

//src/runtime/type.go // 获取 _type 的 name func resolveNameOff(ptrInModule unsafe.Pointer , off nameOff) name {} // 获取 _type 的副本 func resolveTypeOff(ptrInModule unsafe.Pointer , off typeOff) *_type {}

> 注意：Go 语言类型元信息最初由编译器负责构建，并以表的形式存放在编译后的对象文件中，再由链接器在链接时进行段合并、符号重定向（填充某些值）。这些类型信息在接口的动态调用和反射中被运行时引用。

接下来看一下接口的类型元信息的数据结构。示例如下：

```go
  //描述接口的类型
  type interfacetype struct {
      typ _type       //类型通用部分
      pkgpath name    //接口所属包的名字信息， name 内存放的不仅有名称，还有描述信息
      mhdr []imethod  //接口的方法
  }
  //接口方法元信息
  type imethod struct {
      name nameOff //方法名在编译后的 section 里面的偏移量
      ityp typeOff //方法类型在编译后的 section 里面的偏移量
  }
```

#### 接口调用过程分析

前面讨论了接口内部的基本数据结构，下面就来通过跟踪接口实例化和动态调用过程，使用 Go 源码和反汇编代码相结合的方式进行研究。下面是一段非常简单的接口调用代码。

```go
  //iface.go
  package main

  type Caler interface {
      Add (a , b int) int
      Sub (a , b int) int
  }

  type Adder struct ｛id int }

  //go:noinline
  func (adder Adder) Add(a, b int) int { return a + b }

  //go:noinline
  func (adder Adder) Sub(a , b int) int { return a - b }

  func main () {
      var m Caler=Adder{id: 1234}
      m.Add(10, 32)
  }
```

生成汇编代码：

go build -gcflags= “-S - N -l” iface.go >iface.s 2>&1

接下来分析 main 函数的汇编代码，非关键逻辑已经去掉：

```go
  "".main STEXT size=151 args=0x0 locals=0x40
      ...
      0x000f 00015 (src/iface.go:16) SUBQ $64, SP
      0x0013 00019 (src/iface.go:16) MOVQ BP, 56(SP)
      0x0018 00024 (src/iface.go:16) LEAQ 56(SP), BP
```

为 main 函数堆战开辟空间并保存原来的 BP 指针，这是函数调用前编译器的固定动作。

var m Caler = Adder {id: 1234} 语句汇编代码分析：

```c
0x00ld 00029 (src/iface.go:17) MOVQ    $0, "“..autotmp_1+32(SP)
0x0026 00038 (src/iface.go:17) MOVQ    $1234,”"..autotmp_1+32(SP)
```

在堆上初始化局部对象 Adder，先初始化为 0，后初始化为 1234。

```c
0x002f 00047 (src/iface.go:17) LEAQ    go.itab."“.Adder,”".Caler(SB),AX
0x0036 00054 (src/iface.go:17) MOVQ    AX, (SP)
```

这两条语句非常关键，首先 LEAQ 指令是一个获取地址的指令，go.itab."“.Adder,”".Caler(SB) 是一个全局符号引用，通过该符号能够获取接口初始化时 itab 数据结构的地址。

注意：这个标号在链接器链接的过程中会替换为具体的地址。我们知道 (SP) 里面存放的是指向 itab(Caler,Adder) 的元信息的地址，这里 (SP) 是函数调用第一个参数的位置。示例如下：

```c
0x003a 00058 (src/iface.go:17) LEAQ ""..autotmp_1+32(SP), AX
0x003f 00063 (src/iface.go:17) MOVQ AX, 8(SP)
0x0044 00068 (src/iface.go:17) PCDATA $0, $0
```

复制刚才的 Adder 类型对象的地址到 8(SP)，8(SP) 是函数调用的第二个参数位置。示例如下：

```c
0x0044 00068 (src/iface.go:17) CALL    runtime.convT2I64(SB)
```

runtime.convT2I64 函数是运行时接口动态调用的核心函数。runtime 中有一类这样的函数，看一下 runtime.convT2I64 的源码：

```go
  func convT2I64(tab *itab, elem unsafe.Pointer) (i iface) {
      t := tab._type
      if raceenabled {
          raceReadObjectPC(t, elem, getcallerpc(unsafe.Pointer(&tab)), funcPC(convT2I64))
      }
      if msanenabled {
          msanread (elem, t.size)
      }
      var x unsafe.Pointer
      if *(uint64) (elem) == 0 {
          x = unsafe.Pointer(&zeroVal[0])
      } else {
          x = mallocgc(8, t, false)
          *(*uint64) (x) = *(*uint64) (elem)
      }
      i.tab = tab
      i.data = x
      return
  }
```

从上述源码可以清楚地看出，runtime.convT2I64 的两个参数分别是 *itab 和 unsafe.Pointer 类型，这两个参数正是上文传递进去的两个参数值：go.itab."“.Adder,”".Caler(SB) 和指向 Adder 对象复制的指针。

runtime.convT2I64 的返回值是一个 iface 数据结构，其意义就是根据 itab 元信息和对象值复制的指针构建和初始化 iface 数据结构，iface 数据结构是实现接口动态调用的关键。至此己经完成了接口初始化的工作，即完成了 iface 数据结构的构建过程。下一步就是接口方法调用了。示例如下：

```c
0x0049 00073 (src/iface.go:17) MOVQ 24(SP), AX
0x004e 00078 (src/iface.go:17) MOVQ 16(SP), CX
0x0053 00083 (src/iface.go:17) MOVQ CX, "“.m+40(SP)
0x0058 00088 (src/iface.go:17) MOVQ AX,”".m+48(SP)
```

16(SP) 和 24(SP) 存放的是函数 runtime.convT2I64 的返回值，分别是指向 itab 和 data 的指针，将指向 itab 的指针复制到 40(SP)，将指向对象 data 的指针复制到 48(SP) 位置。

m.Add(10, 32) 对应的汇编代码如下：

```c
0x00Sd 00093 (src/iface.go:18) MOVQ "“.m+40(SP), AX
0x0062 00098 (src/iface.go:18) MOVQ 32(AX), AX
0x0066 00102 (src/iface.go:18) MOVQ”".m+48(SP), ex
0x006b 00107 (src/iface.go:18) MOVQ $10, 8(SP)
0x0074 00116 (src/iface.go:18) MOVQ $32, 16(SP)
0x007d 00125 (src/iface.go:18) MOVQ CX, (SP)
0x0081 00129 (src/iface.go:18) PCDATA $0, $0
0x0081 00129 (src/iface.go:18) CALL AX
```

第 1 条指令是将 itab 的指针（位于 40(SP)）复制到 AX 寄存器。第 2 条指令是 AX 将 itab 的偏移 32 字节的值复制到 AX。再来看一下 itab 的数据结构：

```go
  type itab struct {
      inter *interfacetype
      _type *type
      link *itab
      hash uint32 //copy of _type.hash.Used for type switches.
      bad bool    //type does not implement interface
      inhash bool //has this itab been added to hash?
      unused [2]byte
      fun [1] uintptr //variable sized
  }
```

32(AX) 正好是函数指针的位置， 即存放 Adder *Add() 方法指针的地址（注意：编译器将接收者为值类型的 Add 方法转换为指针的 Add 方法，编译器的这种行为是为了方便调用和优化）。

第 3 条指令和第 6 条指令是将对象指针作为接下来函数调用的第 1 个参数。

第 4 条和第 5 条指令是准备函数的第 2、第 3 个参数。

第 8 条指令是调用 Adder 类型的 Add 方法。

此函数调用时，对象的值的副本作为第 1 个参数，调用格式可以表述为 `func(reciver, param1, param2)`。

至此，整个接口的动态调用完成。从中可以清楚地看到，接口的动态调用分为两个阶段：

- 第一阶段就是构建 iface 动态数据结构，这一阶段是在接口实例化的时候完成的，映射到 Go 语句就是 `var m Caler = Adder{id: 1234}`。

- 第二阶段就是通过函数指针间接调用接口绑定的实例方法的过程，映射到 Go 语句就是 m.Add(10, 32)。

接下来看一下 go.itab. "“.Adder,”".Caler(SB) 这个符号在哪里？我们使用 readelf 工具来静态地分析编译后的 ELF 格式的可执行程序。例如：

```go
  #编译
  #go build -gcflag s= "-N -l" iface.go
  #readelf -s -W iface legrep 'itab'
      60:000000000047b220 0 OBJECT LOCAL DEFAULT 5 runtime.itablink
      61:000000000047b230 0 OBJECT LOCAL DEFAULT 5 runtime.eitablink
      88:00000000004aa100 48 OBJECT GLOBAL DEFAULT 8 go.itab.main.Adder, main.Caler
      214:00000000004aa080 40 OBJECT GLOBAL DEFAULT 8 go.itab.runtime.errorString, error
      418:00000000004095e0 1129 FUNC GLOBAL DEFAULT 1 runtime.getitab
      419:0000000000409a50 1665 FUNC GLOBAL DEFAULT 1 runtime.additab
      420:000000000040a0e0 257 FUNC GLOBAL DEFAULT 1 runtime.itabsinit
```

可以看到符号表里面 go.itab.main.Adder, main.Caler 对应本程序里面 itab 的元信息，它被存放在第 8 个段中。我们来看一下第 8 个段是什么段？

```c
#readelf -S -W iface |egrep ‘＼[8\] | I Nr’
[Nr] Name Type Address Off Size ES Flg Lk Inf Al
[8]. noptrdata PROGBITS 00000000004aa000 OaaOOO 000a78 00 WA 0 0 32
```

可以看到这个接口动态转换的数据元信息存放在 .noptrdata 段中，它是由链接器负责初始化的。可以进一步使用 dd 工具读取井分析其内容，本书就不再继续深入这个细节，留给感兴趣的读者继续分析。

#### 接口调用代价

前面讨论了接口动态调用过程，这个过程有两部分多余时耗，一个是接口实例化的过程，也就是 iface 结构建立的过程，一旦实例化后，这个接口和具体类型的 itab 数据结构是可以复用的；另一个是接口的方法调用，它是一个函数指针的间接调用。

同时我们应考虑到接口调用是一种动态的计算后的跳转调用，这对现代的计算机 CPU 的执行很不友好，会导致 CPU 缓存失效和分支预测失败，这也有一部分的性能损失。当然最直接的办法就是对比测试，看看接口动态调用的性能损失到底有多大。

##### 测试用例

直接选用 GitHub 上的一个测试用例，稍作改写，代码如下。

```go
  package main
  import (
      "testing"
  )
  type identifier interface {
      idInline() int32
      idNoInline() int32
  }
  type id32 struct{ id int32 }
  func (id \*id32) idinline() int32 { return id.id }

  //go:noinline
  func (id \*id32) idNoinline() int32 { return id.id }

  var escapeMePlease \*id32

  //主要作用是强制变量内存在 heap 上分配
  //go:noinline
  func escapeToHeap(id \*id32) identifier {
      escapeMePlease = id
      return escapeMePlease
  }

  //直接调用
  func BenchmarkMethodCall\_direct(b \*testing.B) { //
      var myID int32

      b.Run("single/noinline", func(b \*testing.B) {
          m := escapeToHeap(&id32{id: 6754}).(\*id32)
          b.ResetTimer ()
          for i :＝ 0; i ＜ b.N; i++ {
              //CALL "".(\*id32).idNoinline(SB)
              //MOVL 8(SP), AX
              //MOVQ "".&myID+40(SP), CX
              //MOVL AX, (CX)
              myID = m.idNoInline()
          }
      }
      b.Run ("single/inline", func(b \*testing.B) {
          m := escapeToHeap(＆id32{id: 6754}).(\*id32)
          b.ResetTimer()
          for i: ＝ 0; i < b.N; i++ {
              //MOVL (DX), SI
              //MOVL SI, (CX)
              myID = m.idinline()
          }
      })
  }
  //接口调用
  func BenchmarkMethodCall\_interface(b \*testing.B) { //
      var myID int32
      b.Run("single/noinline", func(b \*testing.B) {
          m := escapeToHeap(＆id32{id: 6754})
          b.ResetTimer()
          for i := 0; i < b.N ; i++ {
              // MOVQ 32(AX), CX
              // MOVQ "".m.data+40(SP), DX
              // MOVQ DX, (SP)
              // CALL CX
              // MOVL 8(SP), AX
              // MOVQ "".&myID+48(SP), CX
              // MOVL AX, (CX)
              myID = m.idNoInline()
          }
      })
      b.Run("single/inline", func(b \*testing.B) {
          m := escapeToHeap(&id32{id: 6754})
          b.ResetTimer()
          for i := 0; i < b.N; i++ {
              //MOVQ 24(AX), CX
              //MOVQ "".m.data+40(SP), DX
              //MOVQ DX, (SP)
              //CALL CX
              //MOVL 8(SP), AX
              //MOVQ "". &myID+48(SP), ex
              //MOVL AX, (CX)
              myID = m.idinline()
          }
      })
  } //
  func main() {}
```

##### 测试过程和结果

```go
  //直接调用
  #go test -bench= 'BenchmarkMethodCall\_direct/single/noinline' -cpu=1 -count=5 iface\_bench\_test.go
  goos:linux
  goarch:amd64
  BenchmarkMethodCall\_direct/single/noinline 2000000000 2.00 ns/op
  BenchmarkMethodCall\_direct/single/noinline 2000000000 1.97 ns/op
  BenchmarkMethodCall\_direct/single/noinline 2000000000 1.97 ns/op
  BenchmarkMethodCall\_direct/single/noinline 2000000000 1.94 ns/op
  BenchmarkMethodCall\_direct/single/noinline 2000000000 1.97 ns/op
  PASS
  ok command-line-arguments 20.682s

  //接口调用
  #go test -bench='BenchmarkMethodCall\_interface/single/noinline' －cpu=1 -count=5 iface\_bench\_test.go
  goos:linux
  goarch:amd64
  BenchmarkMethodCall\_interface/single/noinline 1000000000 2.18 ns/op
  BenchmarkMethodCall\_interface/single/noinline 1000000000 2.16 ns/op
  BenchmarkMethodCall\_interface/single/noinline 1000000000 2.17 ns/op
  BenchmarkMethodCall\_interface/single/noinline 1000000000 2.15 ns/op
  BenchmarkMethodCall\_interface/single/noinline 1000000000 2.16 ns/op
  PASS
  ok command-line-arguments 11.930s
```

##### 结果分析

直接调用平均时耗为 1.97ns/op，接口调用的平均时耗为 2.16ns/op, (2.16-1.97)/1.97 约等于 9.64%。可以看到测试结果符合预期，每次迭代接口要慢 0.19ns，大约有 9% 的性能损失。

但是要清楚这个百分比并不能真实地反映接口的效率问题，首先调用的方法是一个很简单的方法，方法的耗时占比很小，无形中放大了接口调用的耗时。如果方法里面有复杂的逻辑，则真实的性能损失远远小于 9%。

从绝对值的角度来看更合理，那就是每次接口调用大约比直接调用慢 0.2ns ，从这个角度看，动态调用的性能损失几乎可以忽略不计。

#### 空接口数据结构

前面我们了解到空接口 interface{} 是没有任何方法集的接口，所以空接口内部不需要维护和动态内存分配相关的数据结构 itab 。空接口只关心存放的具体类型是什么，具体类型的值是什么，所以空接口的底层数据结构也很简单，具体如下：

```go
  //go/src/runtime/runtime2.go
  //空接口
  type eface struct {
      _type *_type
      data unsafe.Pointer
  }
```

从 eface 的数据结构可以看出，空接口不是真的为空，其保留了具体实例的类型和值拷贝，即便存放的具体类型是空的，空接口也不是空的。

由于空接口自身没有方法集，所以空接口变量实例化后的真正用途不是接口方法的动态调用。空接口在 Go 语言中真正的意义是支持多态，有如下几种方式使用了空接口（将空接口类型还原）：

- 通过接口类型断言

- 通过接口类型查询

- 通过反射

至此，接口内部实现原理全部讲完，大家在了解和学习接口内部实现的知识的同时，更应该学习和思考分析过程中的方法和技巧，使用该方法可以继续分析接口断言、接口查询和接口赋值的内部实现机制。

### 15. 表达式求值器

在本节中，我们将创建简单算术表达式的一个求值器。我们将使用一个接口 Expr 来代表这种语言中的任意一个表达式。现在，这个接口没有任何方法，但稍后我们会逐个添加。

```go
// Expr：算术表达式
type Expr interface{}
```

我们的表达式语言包括浮点数字面量，二元操作符 +、-、*、/，一元操作符 -x 和 +x，函数调用 pow(x,y)、sin(x) 和 sqrt(x)，变量（比如 x 和 pi），当然，还有圆括号和标准的操作符优先级。所有的值都是 float64 类型。下面是几个示例表达式：

```go
sqrt(A / pi)
pow(x, 3) + pow(y, 3)
(F - 32) * 5 / 9
```

下面 5 种具体类型代表特定类型的表达式。Var 代表变量应用（很快我们将了解到为什么这个类型需要导岀）。literal 代表浮点数常量。unary 和 binary 类型代表有一个或者两个操作数的操作符表达式，而操作数则可以任意的 Expr。call 代表函数调用，这里限制它的 fn 字段只能是 pow、sin 和 sqrt。

```go
  // Var 表示一个变量，比如 x
  type Var string
  // literal 是一个数字常量，比如 3.141
  type literal float64
  // unary 表示一元操作符表达式，比如-x
  type unary struct {
      op rune // '+', '-' 中的一个
      x Expr
  }
  // binary 表示二元操作符表达式，比如 x+y
  type binary struct {
      op rune // '+', '-', '\*', '/' 中的一个
      x, y Expr
  }
  // call 表示函数调用表达式，比如 sin(x)
  type call struct {
      fn string // one of "pow", "sin", "sqrt" 中的一个
      args []Expr
  }
```

要对包含变量的表达式进行求值，需要一个上下文 (environment) 来把变量映射到数值：

```go
type Env map[Var] float64
```

我们还需要为每种类型的表达式定义一个 Eval 方法来返回表达式在一个给定上下文下的值。既然每个表达式都必须提供这个方法，那么可以把它加到 Expr 接口中。这个包只导出了类型 Expr、Env 和 Var。客户端可以在不接触其他表达式类型的情况下使用这个求值器。

```go
type Expr interface {
    // Eval 返回表达式在 env 上下文下的值
    Eval(env Env) float64
}
```

下面是具体的 Eval 方法。Var 的 Eval 方法从上下文中查询结果，如果变量不存在则返回 0 literal 的 Eval 方法则直接返冋本身的值。

```go
func (v Var) Eval(env Env) float64 {
    return env[v]
}
func (l literal) Eval(_ Env) float64 {
    return float64(l)
}
```

unary 和 binary 的 Eval 方法首先对它们的操作数递归求值，然后应用 op 操作。我们不把除以 0 或者无穷大当做错误（尽管它们生成的结果显然不是有穷数）。最后，call 方法先对 pow、sin 或者 sqrt 函数的参数求值，再调用 math 包中的对应函数。

```go
  func (u unary) Eval(env Env) float64 {
      switch u.op {
      case '+':
          return +u.x.Eval(env)
      case '-':
          return -u.x.Eval(env)
      }
      panic(fmt.Sprintf("unsupported unary operator: %q", u.op))
  }
  func (b binary) Eval(env Env) float64 {
      switch b.op {
      case '+':
          return b.x.Eval(env) + b.y.Eval(env)
      case '-':
          return b.x.Eval(env) - b.y.Eval(env)
      case '*1:
          return b.x.Eval(env) * b.y.Eval(env)
      case '/':
          return b.x.Eval(env) / b.y.Eval(env)
      }
      panic(fmt.Sprintf("unsupported binary operator: %q", b.op))
  }
  func (c call) Eval(env Env) float64 {
      switch c.fn {
      case "pow":
          return math.Pow(c.args[0].Eval(env), c.args[1].Eval(env)
      case "sin":
          return math.Sin(c.args[0].Eval(erw))
      case "sqrt":
          return math.Sqrt(c.args[0].Eval(env))
      }
      panic(fmt.Sprintf("unsupported function call: %s", c.fn))
  }
```

某些方法可能会失败，比如 call 表达式可能会遇到未知的函数，或者参数数量不对。也有可能用 “!” 或者 “<” 这类无效的操作符构造了一个 unary 或 binary 表达式（尽管后面的 Parse 函数不会产生这样的结果）。这些错误都会导致 Eval 崩溃。

其他错误（比如对一个上下文中没有定义的变量求值）仅会导致返回不正确的结果。所有这些错误都可以在求值之前做检查来发现。后面的 Check 方法就负责完成这个任务，但我们先测试 Eval。

下面的 TestEval 函数用于测试求值器，它使用 testing 包。我们知道调用 t.Errorf 来报告错误。这个函数遍历一个表格，表格中定义了三个表达式并为每个表达式准备了不同上下文。第一个表达式用于根据圆面积 A 求半径，第二个用于计算两个变量 x 和 y 的立方和，第三个把华氏温度 F 转为摄氏温度。

```go
  func TestEval(t \*testing.T) {
      tests := []struct {
          expr string
          env Env
          want string
      }{
          {"sqrt(A / pi)", Env{"A": 87616, "pi": math.Pi}, "167"},
          {"pow(x, 3) + pow(y, 3)", Env{"x": 12, "y": 1}, "1729"},
          {"pow(x, 3) + pow(y, 3)", Env{"x": 9, "y": 10}, "1729"},
          {"5/9 * (F - 32)", Env{"F": -40}, "-40"},
          {"5/9 * (F - 32)", Env{"F": 32}, "0"},
          {"5/9 * (F - 32)", Env{"F": 212}, "100"},
      }
      var prevExpr string
      for _, test := range tests {
          // 仅在表达式变更时才输出
          if test.expr != prevExpr {
              fmt.Printf("\n%s\n", test.expr)
              prevExpr = test.expr
          }
          expr, err := Parse(test.expr)
          if err != nil {
              t.Error(err) // 解析出错
              continue
          }
          got := fmt.Sprintf("%.6g", expr.Eval(test.env))
          fmt.Printf("\t%v => %s\n", test.env, got)
          if got != test.want {
              t.Errorf("%s.Eval() in %v = %q, want %q\n", test.expr, test.env, got, test.want)
          }
      }
  }
```

对于表格中的每一行记录，该测试先解析表达式，在上下文中求值，再输出表达式。这里没有足够的空间来显示 Parse 函数，但可以通过 go get 来下载源码，自行查看。

go test 命令可用于运行包的测试：

$ go test -v gopl.io/ch7/eval

启用 -v 选项后可以看到测试的输出，通常情况下对于结果正确的测试输出就不显示了。下面就是测试中 fmt.Printf 语句输岀的内容。

```go
sqrt(A / pi)
    map[A:87616 pi:3.141592653589793] => 167

pow(x, 3) + pow(y, 3)
    map[x:12 y:1] => 1729
    map[x:9 y:10] => 1729
5 / 9 * (F - 32)
    map[F:-40] => -40
    map[F:32] => 0
    map[F:212] => 100
```

幸运的是，到现在为止所有的输入都是合法的，但这种幸运是不能持久的。即使在解释性语言中，通过语法检查来发现静态错误（即不用运行程序也能检测出来的错误）也是很常见的。通过分离静态检查和动态检查，我们可以更快发现错误，也可以只在运行前检查一次，而不用在表达式求值时每次都检查。

让我们给 Expr 方法加上另外一个方法。Check 方法用于在表达式语法树上检查静态错误。它的 vars 参数将稍后解释。

```go
type Expr interface {
    Eval(env Env) float64
    // Check 方法报告表达式中的错误，并把表达式中的变量加入 Vars 中
    Check(vars map[Var]bool) error
}
```

具体的 Check 方法如下所示。literal 和 Var 的求值不可能出错，所以 Check 方法返回 nil。unary 和 binary 的方法首先检查操作符是否合法，再递归地检查操作数。类似地，call 的方法首先检查函数是否是已知的，然后检查参数个数是否正确，最后递归检查每个参数。

```go
  func (v Var) Check(vars map[Var]bool) error {
      vars[v] = true
      return nil
  }
  func (literal) Check(vars map[Var]bool) error {
      return nil
  }
  func (u unary) Check(vars map[Var]bool) error {
      if !strings.ContainsRune("+-", u.op) {
          return fmt.Errorf("unexpected unary op %q", u.op)
      }
      return u.x.Check(vars)
  }
  func (b binary) Check(vars map[Var]bool) error {
      if !strings.ContainsRune("+-*/", b.op) {
          return fmt.Errorf("unexpected binary op %q", b.op)
      }
      if err := b.x.Check(vars); err != nil {
          return err
      }
      return b.y.Check(vars)
  }
  func (c call) Check(vars map[Var]bool) error {
      arity, ok := numParams[c.fn]
      if !ok {
          return fmt.Errorf("unknown function %q", c.fn)
      }
      if len(c.args) != arity {
          return fmt.Errorf("call to %s has %d args, want %d", c.fn, len(c.args), arity)
      }
      for _, arg := range c.args {
          if err := arg.Check(vars); err != nil {
              return err
          }
      }
      return nil
  }
  var numParams = map[string]int{"pow",: 2, "sin": 1, "sqrt": 1}
```

下面分两列展示了一些有错误的输入，以及它们触发的错误。Parse 函数（没有显示）报告了语法错误，Check 方法报告了语义错误。

```go
x % 2  unexpected ‘%’
math.Pi unexpected ‘.’
!true  unexpected ‘!’
“hello” unexpected ’“’
log(10) unknown function”log"
sqrt(1, 2) call to sqrt has 2 args, want 1
```

Check 的输入参数是一个 Ver 集合，它收集在表达中发现的变量名。要让表达式能成功求值，上下文必须包含所有的这些变量。从逻辑上来讲，这个集合应当是 Check 的输出结果而不是输入参数，但因为这个方法是递归调用的，在这种情况下使用参数更为方便。调用方在最初调用时需要提供一个空的集合。

既然我们可以对字符串形式的表达式进行解析、检查和求值，那么就可以构建一个 Web 应用，在运行时从客户端接收一个表达式，并绘制函数的曲面图。可以使用 vars 集合来检查表达式是一个只有两个变量 x、y 的函数（为了简单起见，还提供了半径 r，所以实际上是 3 个变量）。使用 Check 方法来拒绝掉不规范的表达式，避免了在接下来的 40000 次求值中重复检查（4 个象限中 100 x 100 的格子）。

下面的 parseAndCheck 函数组合了解析和检查步骤：

```go
  import "gopl.io/ch7/eval"
  func parseAndCheck(s string) (eval.Expr, error) {
      if s == "" {
          return nil, fmt.Errorf("empty expression")
      }
      expr, err := eval.Parse(s)
      if err != nil {
          return nil, err
      }
      vars := make(map[eval.Var]bool)
      if err := expr.Check(vars); err != nil {
          return nil, err
      }
      for v := range vars {
          if v != "x" && v != "y" && v != "r" {
              return nil, fmt.Errorf("undefined variable: %s", v)
          }
      }
      return expr, nil
  }
```

要构造完这个 Web 应用，仅需要增加下面的 plot 函数，其函数签名与 http.HandlerFunc 类似：

```go
  func plot(w http.ResponseWriter, r *http.Request) {
      r.ParseForm()
      expr, err := parseAndCheck(r.Form.Get("expr"))
      if err != nil {
          http.Error(w, "bad expr: "+err.Error(), http.StatusBadRequest)
          return
      }
      w.Header().Set("Content-Type", "image/syg+xml")
      surface(w, func(x, y float64) float64 {
          r := math.Hypot(x, y)   // 与(0,0)之间的距离
          return expr.Eval(eval.Env{"x": x, "y": y, "r" : r})
      })
  }
```

plot 函数解析并检查 HTTP 请求中的表达式，并用它来创建一个有两个变量的匿名函数。这个匿名函数与原始曲面图绘制程序中的 f 有同样的签名，且能对用户提供的表达式进行求值。上下文定义了 x、y 和半径 r。

最后，plot 调用了 surface 函数，surface 函数来自 gop1.io/ch3/surface 中的 main 函数，略做修改，加了参数用于接受绘制函数和输出用的 io.Writer，原始版本直接使用了函数 f 和 os.Stdout。下图显示了用这个程序绘制的三张曲面图。

[![img](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK524310.gif)](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK524310.gif)

（a）

[![img](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK544596.gif)](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK544596.gif)

1. [![img](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK600E4.gif)](http://c.biancheng.net/uploads/allimg/190808/4-1ZPQK600E4.gif)

1. 图：三个函数的曲面图：

   a) sin(-x)*pow(1.5, -r);

   b) pow(2, sin(y))*pow(2, sin(x))/12;*

   c) sin (x*y/10)/10

### 16. 实现Web服务器

Go语言里面提供了一个完善的 net/http 包，通过 net/http 包我们可以很方便的搭建一个可以运行的 Web 服务器。同时使用 net/http 包能很简单地对 Web 的路由，静态文件，模版，cookie 等数据进行设置和操作。

#### Web服务器的工作方式

我们平时浏览网页的时候，会打开浏览器，然后输入网址后就可以显示出想要浏览的内容。这个看似简单的过程背后却隐藏了非常复杂的操作。

对于普通的上网过程，系统其实是这样做的：

- 浏览器本身是一个客户端，当在浏览器中输入 URL （网址）的时候，首先浏览器会去请求 DNS 服务器，通过 DNS 获取相应的域名对应的 IP，然后通过 IP 地址找到对应的服务器后，要求建立 TCP 连接；
- 与服务器建立连接后，浏览器会向服务器发送 HTTP Request （请求）包；
- 服务器接收到请求包之后开始处理请求包，并调用自身服务，返回 HTTP Response（响应）包；
- 客户端收到来自服务器的响应后开始渲染这个 Response 包里的主体（body），等收到全部的内容后断开与该服务器之间的 TCP 连接。



![img](http://c.biancheng.net/uploads/allimg/191205/4-19120512054A56.gif)
图：用户访问一个站点的过程


通过上图可以将 Web 服务器的工作原理简单地归纳为：

- 客户机通过 TCP/IP 协议与服务器建立 TCP 连接；
- 客户端向服务器发送 HTTP 协议请求包，请求服务器里的资源文档；
- 服务器向客户机发送 HTTP 协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解释引擎负责处理“动态内容”，并将处理得到的数据返回给客户端；
- 客户机与服务器断开，由客户端解释 HTML 文档，在客户端屏幕上渲染图形结果。

#### 搭建一个简单的 Web 服务器

前面简单介绍了 Web 服务器的工作原理，那么如何用Go语言搭建一个 Web 服务器呢？示例代码如下：

```go
package main
import (
    "fmt"
    "log"
    "net/http"
)
func main() {
    http.HandleFunc("/", index) // index 为向 url发送请求时，调用的函数
    log.Fatal(http.ListenAndServe("localhost:8000", nil))
}
func index(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "C语言中文网")
}
```

使用`go run`命令运行上面的代码：

```go
go run main.go
```

运行之后并没有什么提示信息，但是命令行窗口会被占用（不能再输入其它命令）。这时我们在浏览器中输入 localhost:8000 可以看到下图所示的内容，则说明我们的服务器成功运行了。



![img](http://c.biancheng.net/uploads/allimg/191205/4-191205120Jb60.gif)
图：localhost:8000

提示：运行 Web 服务器会占用命令行窗口，我们可以使用 Ctrl+C 组合键来退出。

上面的代码只是展示了 Web 服务器的简单应用，下面我们来完善一下，为这个服务器添加一个页面并设置访问的路由。

首先我们准备一个 html 文件，并命名为 index.html，代码如下所示：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>C语言中文网</title>
</head>
<body>
    <h1>C语言中文网</h1>
</body>
</html>
```

然后将我们上面写的 Web 服务器的代码简单修改一下，如下所示：

```go
package main
import (
    "io/ioutil"
    "log"
    "net/http"
)
func main() {
    // 在/后面加上 index ，来指定访问路径
    http.HandleFunc("/index", index)
    log.Fatal(http.ListenAndServe("localhost:8000", nil))
}
func index(w http.ResponseWriter, r *http.Request) {
    content, _ := ioutil.ReadFile("./index.html")
    w.Write(content)
}
```

使用`go run`命令运行：

```go
go run main.go
```

运行成功后，在浏览器中输入 localhost:8000/index 就可以看到我们所添加的页面了，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/191205/4-191205120S94R.gif)
图：浏览 localhost:8000/index 页面

### 17. 部署go语言程序到Linux服务器

通过前面的学习相信大家对 Go 语言已经有了一定的了解，平时我们都是在本地进行开发调试访问的。那要怎么打包到服务器上呢？下面通过一个简单的实例来给大家介绍一下如何把我们写好的 Go 语言程序发布到服务 Linux 服务器上。

下面所示的是我们在 Windows 系统下开发的代码：

```go
  package main

  import (
      "fmt"
      "log"
      "net/http"
  )

  func sayHello(w http.ResponseWriter, r *http.Request) {
      fmt.Fprintf(w, "C语言中文网")
  }
  func main() {
      http.HandleFunc("/", sayHello)
      log.Println("启动成功，可以通过 localhost:9000 访问")
      err := http.ListenAndServe(":9000", nil)
      if err != nil {
          log.Fatal("List 9000")
      }
  }
```

代码已经写好了，现在需要编译了，由于是 window 环境编译到 linux 下运行，所有涉及到跨平台编译。

编译代码命令如下所示：

set GOARCH=amd64  // 设置目标可执行程序操作系统构架，包括 386，amd64，arm set GOOS=linux      // 设置可执行程序运行操作系统，支持 darwin，freebsd，linux，windows go build ./main.go    // 打包

> 注意：使用 Window 10 系统的小伙伴必须用 cmd 工具执行上述命令，不能使用 powershell。

OK，编译完成后会生成一个 main 可执行文件，没有后缀，这时只需要把这个文件上传到你的虚拟机，直接运行就好了。

[![img](http://c.biancheng.net/uploads/allimg/190905/4-1ZZ5111444Z5.gif)](http://c.biancheng.net/uploads/allimg/190905/4-1ZZ5111444Z5.gif)

运行后如果出现上图的效果，就说明已经运行起来了。这时打开你的浏览器访问服务器的 IP:9000 就能看到如下图的内容了

[![img](http://c.biancheng.net/uploads/allimg/200119/4-20011916091a26.gif)](http://c.biancheng.net/uploads/allimg/200119/4-20011916091a26.gif)

好啦！就这么简单，不需要任何语言环境，像 java 程序需要在服务器安装 java，php 需要安装 Apache，PHP 等运行环境，go 统统不需要，只需要一个 linux 系统将编译好的代码扔上去就可以了。

### 18. 音乐播放器

结合前面所学的知识，本节我们将设计并实现了一个音乐播放器程序。这个程序只是用于演示 Go 语言的特性，因此大家就不要期望能看到华丽的播放界面，听到优美的音乐。

本节我们将实现以下功能：

- 音乐库功能，使用者可以查看、添加和删除里面的音乐曲目；

- 播放音乐；

- 支持 MP3 和 WAV，但也能随时扩展以支持更多的音乐类型；

- 退出程序。

由于 Go 语言初始定位为高并发的服务器端程序，尚未在 GUI 的支持上花费大量的精力，而当前版本的 Go 语言标准库中没有提供 GUI 相关的功能，也没有成熟的第三方界面库，因此不太适合开发 GUI 程序。

因此，这个程序仍然会是一个命令行程序，我们将其命名为 Simple Media Player（SMP）。该程序在运行后进入一个循环，用于监听命令输入的状态。该程序将接受以下命令。

- 音乐库管理命令：lib，包括 list/add/remove 命令。

- 播放管理：play 命令，play 后带歌曲名参数。

- 退出程序：q 命令。

#### 音乐库

我们先来实现音乐库的管理模块，它管理的对象为音乐。每首音乐都包含以下信息：

- 唯一的 ID；

- 音乐名；

- 艺术家名；

- 音乐位置；

- 音乐文件类型（MP3 和 WAV 等）。

下面我们先定义音乐的结构体，具体如下所示：

```
1.  type Music struct {
2.      Id string
3.      Name string
4.      Artist string
5.      Source string
6.      Type string
7.  }
```

然后开始实现这个音乐库管理类型，其中我们使用了一个数组切片作为基础存储结构，其他的操作其实都只是对这个数组切片的包装，代码如下所示。

```
1.  //manager.go
2.  package library
3.  import "errors"
4.  type MusicManager struct {
5.      musics \[\]MusicEntry
6.  }
7.  func NewMusicManager() \*MusicManager {
8.      return &MusicManager{make(\[\]MusicEntry, 0)}
9.  }
10.  func (m \*MusicManager) Len() int {
11.      return len(m.musics)
12.  }
13.  func (m \*MusicManager) Get(index int) (music \*MusicEntry, err error) {
14.      if index < 0 || index >= len(m.musics) {
15.          return nil, errors.New("Index out of range.")
16.      }
17.      return &m.musics\[index\], nil
18.  }
19.  func (m \*MusicManager) Find(name string) \*MusicEntry {
20.      if len(m.musics) == 0 {
21.          return nil
22.      }
23.      for \_, m := range m.musics {
24.          if m.Name == name {
25.              return &m
26.          }
27.      }
28.      return nil
29.  }
30.  func (m \*MusicManager) Add(music \*MusicEntry) {
31.      m.musics = append(m.musics, \*music)
32.  }
33.  func (m \*MusicManager) Remove(index int) \*MusicEntry {
34.      if index < 0 || index >= len(m.musics) {
35.          return nil
36.      }
37.      removedMusic := &m.musics\[index\]
38.      // 从数组切片中删除元素
39.      if index < len(m.musics)-1 { // 中间元素
40.          m.musics = append(m.musics\[:index-1\], m.musics\[index+1:\]...)
41.      } elseif index == 0 { // 删除仅有的一个元素
42.          m.musics = make(\[\]MusicEntry, 0)
43.      } else { // 删除的是最后一个元素
44.          m.musics = m.musics\[:index-1\]
45.      }
46.      return removedMusic
47.  }
```

实现了这么重要的一个基础数据管理模块后，我们应该马上编写单元测试，而不是给自己借口说等将来有空的时候再补上。下面的代码实现了 MusicManager 类型的单元测试。

```
1.  //manager\_test.go
2.  package library
3.  import (
4.      "testing"
5.  )
6.  func TestOps(t \*testing.T) {
7.      mm := NewMusicManager()
8.      if mm == nil {
9.          t.Error("NewMusicManager failed.")
10.      }
11.      if mm.Len() != 0 {
12.          t.Error("NewMusicManager failed, not empty.")
13.      }
14.      m0 := &MusicEntry{
15.          "1", "My Heart Will Go On", "Celion Dion", Pop,
16.          "http://qbox.me/24501234", MP3}
17.      mm.Add(m0)
18.      if mm.Len() != 1 {
19.          t.Error("MusicManager.Add() failed.")
20.      }
21.      m := mm.Find(m0.Name)
22.      if m == nil {
23.          t.Error("MusicManager.Find() failed.")
24.      }
25.      if m.Id != m0.Id || m.Artist != m0.Artist ||
26.          m.Name != m0.Name || m.Genre != m0.Genre ||
27.          m.Source != m0.Source || m.Type != m0.Type {
28.          t.Error("MusicManager.Find() failed. Found item mismatch.")
29.      }
30.      m, err := mm.Get(0)
31.      if m == nil {
32.          t.Error("MusicManager.Get() failed.", err)
33.      }
34.      m = mm.Remove(0)
35.      if m == nil || mm.Len() != 0 {
36.          t.Error("MusicManager.Remove() failed.", err)
37.      }
38.  }
```

这个单元测试看起来似乎有些偷懒，但它基本上已经覆盖了 MusicManager 的所有功能，实际上也确实测出了 MusicManager 实现过程中的几个问题。因此，养成良好的单元测试习惯还是非常有价值的。

#### 音乐播放

我们接下来设计和实现音乐播放模块。按我们之前设置的目标，音乐播放模块应该是很容易扩展的，不应该在每次增加一种新音乐文件类型支持时都就需要大幅调整代码。我们来设计一个简单但又足够通用的播放函数：

```go
func Play(source, mtype string)
```

这里没有直接将 MusicEntry 作为参数传入，这是因为 MusicEntry 包含了一些多余的信息。本着最小原则，我们只需要将真正需要的信息传入即可，即音乐文件的位置以及音乐的类型。

下面我们设计一个简单的接口：

```go
type Player interface {
    Play(source string)
}
```

然后我们可以通过一批类型（比如 MP3Player 和 WAVPlayer 等）来实现这个接口，已达到尽量的架构灵活性。因此，我们可以实现如下代码所示的总入口函数。

```go
  //play.go
  package mp
  import "fmt"
  type Player interface {
      Play(source string)
  }
  func Play(source, mtype string) {
      var p Player
      switch mtype {
          case "MP3":
              p = &MP3Player{}
          case "WAV":
              p = &WAVPlayer{}
          default:
              fmt.Println("Unsupported music type", mtype)
              return
      }
      p.Play(source)
  }
```

因为我们这个例子并不会真正实现多媒体文件的解码和播放过程，所以对于 MP3Player 和 WAVPlayer，我们只实现其中一个作为示例，代码如下所示。

```go
  //mp3.go
  package mp
  import (
      "fmt"
      "time"
  )
  type MP3Player struct {
      stat int
      progress int
  }
  func (p *MP3Player)Play(source string) {
      fmt.Println("Playing MP3 music", source)
      p.progress = 0
      for p.progress < 100 {
          time.Sleep(100 * time.Millisecond) // 假装正在播放
          fmt.Print(".")
          p.progress += 10
      }
      fmt.Println("\nFinished playing", source)
  }
```

当然，我们也应该对播放流程进行单元测试。因为单元测试比较简单，这里就不再列出完整的单元测试代码了。

#### 主程序

核心模块已经设计和实现完毕，现在就该使用它们了。我们的主程序是一个命令行交互程序，用户可以通过输入命令来控制播放过程以及获取播放信息。因为主程序与面向对象关系不大，所以我们只是为了完整性而把源代码列在这里，但不作过多解释。

在这里，我们可以顺便了解一下命令行交互程序在 Go 语言中的常规实现方式。下面的代码实现了音乐播放器的主程序。

```go
  //mplayer.go
  package main
  import (
      "bufio"
      "fmt"
      "os"
      "strconv"
      "strings"

      "pkg/mplayer/mlib"
      "pkg/mplayer/mp"
  )

  var lib *library.MusicManager
  var id int = 1
  var ctrl, signal chan int

  func handleLibCommands(tokens []string) {
      switch tokens[1] {
          case "list":
              for i := 0; i < lib.Len(); i++ {
                  e, _ := lib.Get(i)
                  fmt.Println(i+1, ":", e.Name, e.Artist, e.Source, e.Type)
              }
          case "add": {
              if len(tokens) == 6 {
                  id++
                  lib.Add(&library.MusicEntry{strconv.Itoa(id),
                      tokens[2], tokens[3], tokens[4], tokens[5]})
              } else {
                  fmt.Println("USAGE: lib add <name><artist><source><type>")
              }
          }
          case "remove":
              if len(tokens) == 3 {
                  lib.RemoveByName(tokens[2])
              } else {
                  fmt.Println("USAGE: lib remove <name>")
              }
          default:
              fmt.Println("Unrecognized lib command:", tokens[1])
      }
  }
  func handlePlayCommand(tokens []string) {
      if len(tokens) != 2 {
          fmt.Println("USAGE: play <name>")
          return
      }
      e := lib.Find(tokens[1])
      if e == nil {
          fmt.Println("The music", tokens[1], "does not exist.")
          return
      }
      mp.Play(e.Source, e.Type, ctrl, signal)
  }
  func main() {
      fmt.Println(`
          Enter following commands to control the player:
          lib list -- View the existing music lib
          lib add <name><artist><source><type> -- Add a music to the music lib
          lib remove <name> -- Remove the specified music from the lib
          play <name> -- Play the specified music
      `)
      lib = library.NewMusicManager()
      r := bufio.NewReader(os.Stdin)
      for {
          fmt.Print("Enter command-> ")
          rawLine, _, _ := r.ReadLine()
          line := string(rawLine)
          if line == "q" || line == "e" {
              break
          }
          tokens := strings.Split(line, " ")
          if tokens[0] == "lib" {
              handleLibCommands(tokens)
          } elseif tokens[0] == "play" {
              handlePlayCommand(tokens)
          } else {
              fmt.Println("Unrecognized command:", tokens[0])
          }
      }
  }
```

#### 构建运行

所有代码已经写完，现在可以开始构建并运行程序了，具体如下所示：

```go
$ go run mplayer.go
Enter following commands to control the player:
lib list – View the existing music lib
lib add  – Add a music to the music lib
lib remove  – Remove the specified music from the lib
play  – Play the specified music

Enter command-> lib add HugeStone MJ ~/MusicLib/hs.mp3 MP3
Enter command-> play HugeStone
Playing MP3 music ~/MusicLib/hs.mp3
……….
Finished playing ~/MusicLib/hs.mp3
Enter command-> lib list
1 : HugeStone MJ ~/MusicLib/hs.mp3 MP3
Enter command-> lib view
Enter command-> q
```

#### 遗留问题

这个程序虽然已经写好，但是很显然它离一个可实际使用的程序还相差很远，下面我们就来谈谈遗留问题以及对策。

##### 1) 多任务

当前，我们这个程序还只是单任务程序，即同时只能执行一个任务，比如音乐正在播放时，用户不能做其他任何事情。作为一个运行在现代多任务操作系统上的应用程序，这种做法肯定是无法被用户接受的。

音乐播放过程不应导致用户界面无法响应，因此播放应该在一个单独的线程中，并能够与主程序相互通信。而且像一般的媒体播放器一样，在播放音乐的同时，我们甚至也要支持一些视觉效果的播放，即至少需要这么几个线程：用户界面、音乐播放和视频播放。

考虑到这个需求，我们自然而然地想到了使用 Go 语言的看家本领 goroutine，比如将上面的播放进行稍微修改后即可将 Play() 函数作为一个独立的 goroutine 运行。

##### 2) 控制播放

因为当前这个设计是单任务的，所以播放过程无法接受外部的输入。然而作为一个成熟的播放器，我们至少需要支持暂停和停止等功能，甚至包括设置当前播放位置等。假设我们已经将播放过程放到一个独立的 goroutine 中，那么现在就是如何对这个 goroutine 进行控制的问题，这可以使用 Go 语言的 channel 功能来实现。

### 19. 实现有限状态机（FSM）

有限状态机又简称 FSM（Finite-State Machine 的首字母缩写），也可以称为有限状态自动机。它是为研究有限内存的计算过程和某些语言类而抽象出的一种计算模型。有限状态机拥有有限数量的状态，每个状态可以迁移到零个或多个状态，输入字串决定执行哪个状态的迁移。

现实生活中，状态是随处可见的，并且通过不同的状态来做不同的事。比如冷了加衣服、饿了吃饭、困了睡觉等。这里的冷了、饿了、困了是三种不同的状态，并且根据这三个状态的转变驱动了不同行为的产生（加衣服、吃饭和睡觉）。

#### 有限状态机的组成

有限状态机有两个必要的特点，一是离散的，二是有限的。基于这两点，现实世界上绝大多数事物因为复杂的状态而无法用有限状态机表示。

而描述事物的有限状态机模型的元素由以下组成：

- 状态（State）：事物的状态，包括初始状态和所有事件触发后的状态。

- 事件（Event）：触发状态变化或者保持原状态的事件。

- 行为或转换（Action/Transition）：执行状态转换的过程。

- 检测器（Guard）：检测某种状态要转换成另一种状态的条件是否满足。

#### 有限状态机的应用领域

除了应用于数学模型外，有限状态机在许多不同领域都有重要应用，包括电气工程、语言学、计算机科学、哲学、生物学、数学和逻辑学。有限状态机归属于自动机理论，下面的自动机理论的领域分层图中就可以看出，越是外层的概念越复杂。

[![img](http://c.biancheng.net/uploads/allimg/191205/4-1912051H942642.gif)](http://c.biancheng.net/uploads/allimg/191205/4-1912051H942642.gif)

图：自动机理论

#### 有限状态机的举例

FSM 持有有限多个状态集合，有当前状态、默认状态、接收的外部数据等。并且 FSM 有一系列的行为：启动 FSM、退出 FSM 以及状态转移等。

State（状态）也会有一系列的行为：进入状态，转移状态等。并且 State 还有动作行为，比如电视机当前频道正在播放西游记，切换频道后就变成了播放封神榜，原理上是一样的。

【示例】下面以游戏中的宠物为例，将这个宠物看做一个 FSM，比如这个宠物每天 8 点开始挣金币，中午 12 点开始打坐练功，8 点和 12 点就是对这个 FSM 的输入语句，对应的状态则开始执行，代码如下所示：

运行结果如下所示：

ZazenState: 开始打坐 ZazenState: 退出打坐 WorkerState: 开始工作 WorkerState: 退出工作 WorkerState: 开始工作 WorkerState: 退出工作 ZazenState: 开始打坐 ZazenState: 退出打坐 WorkerState: 开始工作

#### 关于对 FSM 的封装

FSM 主要是处理外部数据而产生状态的转变，所以别打算去封装它。不同的条件，不同的状态以及不同的处理方式令 FSM 基本上不太可能去封装，只能做一些语法上的包装罢了。

#### 总结

真实的场景中，这个宠物所做的工作可能会非常多。比如自动判断周边的环境，发现怪物就去打怪，没血了就自动补血，然后实在打不过就逃跑等等。

上例中的 SetInputData() 就是用于模拟周边环境的数据对宠物的影响，更复杂的情况还在于宠物有时候执行的动作是不能被打断的（上例中的 Exit() 方法），它只有在完成某个周期的行为才能被终止。这个很容易理解。比如宠物发送网络数据包的时候就不能轻易的被中断，那这个时候其实是可以实现同步原语，状态之间互相 wait。

FSM 被广泛用于游戏设计和其它各方面，的确是个比较重要的数学模型。

### 20. 二叉树数据结构的应用

树型结构（Tree）是一种重要的非线性数据结构，它为计算机应用中出现的具有层次关系的数据提供了一种有效的表示方法，比如文件目录结构、源程序语法结构等。

#### 树的定义和基本术语

树是 n(n>=0) 个节点的有限集合 T。在任意一棵非空树中满足如下两个条件：

- 有且仅有一个根节点（Root）。

- 当 n>1 时，其余节点可分为 m(m>=0) 个互不相交的有限集合 T1，T2，……，Tm，其中每一个集合本身又都是一棵树，并且称为根的子树（Subtree），如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/191206/4-19120609503b07.gif)](http://c.biancheng.net/uploads/allimg/191206/4-19120609503b07.gif)

图：树型结构

由上图可知，树的定义是递归的，树是一种递归数据结构。树的这种定义为树的递归处理带来了很大方便，本节举例中几乎所有对树的处理都采用了递归算法。

在了解树型结构时，还有几个基本概念非常重要，必须要掌握：

- 节点的度：树中每个节点具有的子树数，或后继节点数称为该节点的度。

- 树的度：树中所有节点的度的最大值称为树的度。

- 分支节点：度大于 0 的节点称为分支节点或非终端节点。

- 叶子节点：度为 0 的节点称为叶子节点或终端节点。

- 儿子节点：一个节点的后继称为该节点的儿子节点。

- 父亲节点：一个节点称为其后继节点的父亲节点。

- 子孙节点：一个节点的所有子树中的节点称为该节点的子孙节点。

- 祖先节点：从根节点到达一个节点的路径上，通过的所有节点称为该节点的祖先节点。

- 兄弟节点：具有同一父亲的节点相互称为兄弟节点。

- 节点的层数：树是一种层次结构，根节点为第一层，其儿子节点为第二层，以此类推可以得到每个节点的层数。

- 树的深度：树中节点的最大层数称为树的深度或高度。

- 森林：0 个或多个不相交的树的集合称为森林。

#### 二叉树简介

二叉树是一种特殊的树，具有如下特点：

- 二叉树中每个节点最多有两棵子树，称为左子树、右子树；

- 左子树和右子树是有顺序的，有左右之分，次序不能随意颠倒；

- 即使某个节点只有一个子树，也要区分左右子树。

除了这些基本特征外，还有如下一些特殊的二叉树。

##### 1) 斜树

所有的节点只有左子树则称为左斜树；所有节点只有右子树则称为右斜树。如下图所示：

![img](https://tva1.sinaimg.cn/large/008i3skNly1guu4uclovtg609g06d74i02.gif)

图：左斜树和右斜树

##### 2) 满二叉树

在一棵二叉树中，所有的分支结点都存在左子树和右子树，并且所有的叶子结点都在同一层上，这样的二叉树称为满二叉树。就是完美圆满的意思。

[![img](http://c.biancheng.net/uploads/allimg/191206/4-191206111KL06.gif)](http://c.biancheng.net/uploads/allimg/191206/4-191206111KL06.gif)

图：满二叉树

满二叉树的特点如下所示：

- 叶子只能出现在最下一层。

- 非叶子结点度一定是 2.

- 在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。

##### 3) 完全二叉树

在一棵二叉树中，除最后一层外，若其余各层都是满的，最后一层要么是满的，要么在右边缺少若干个连续的节点，这样的二叉树被称为完全二叉树。满二叉树必须是完全二叉树，而完全二叉树不一定是满二叉树。

[![img](http://c.biancheng.net/uploads/allimg/191206/4-191206111T2U3.gif)](http://c.biancheng.net/uploads/allimg/191206/4-191206111T2U3.gif)

图：完全二叉树

完全二叉树的特点如下所示：

- 叶子结点只能出现在最下一层（满二叉树继承而来）。

- 最下层叶子结点一定集中在左部连续位置。

- 倒数第二层，如有叶子节点，一定出现在右部连续位置。

- 同样结点树的二叉树，完全二叉树的深度最小。

#### 二叉树的链接存储结构

二叉树的存储方法有顺序存储、链接存储和线索树存储等几种存储方法，顺序存储是使用数组来完成，而链接存储和线索树存储都使用了链表来完成。本节在二叉树的应用举例中使用了链接存储法。

##### 节点定义

在二叉树的链接存储结构中，通常采用的方法是：每个节点设置三个域，即值域、左指针域和右指针域，其结构如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/190826/4-1ZR6133645438.gif)](http://c.biancheng.net/uploads/allimg/190826/4-1ZR6133645438.gif)

图：二叉树链接存储结构

其中 Data 表示值域，用于存储放入节点中的数据元素，LeftChild 和 RightChild 分别表示左指针域和右指针域，用以分别存储左子树和右子树节点的指针地址。

链接存储的指针类型和节点定义如下：

type Node struct {   Left *Node   Data interface{}   Right *Node }

这里的 Data 字段可以是任意基本数据类型，如 int、float、string 等。链表所有节点的 Data 字段类型一致，比如同为 int 型或同为 string 型。在本节的应用举例中，二叉树节点的 Data 字段将被设置成空接口 interface{}，这样二叉树的叶子节点将能够存储不同类型的数据，比如一个节点为 int 型，其他节点可以为 string 型等。

##### 接口定义

二叉树的应用处理功能主要包括：

- 二叉树新节点的创建、初始化；

- 二叉树的输出、度的计算、叶子节点统计等基本操作；

- 二叉树的前序、中序、后序遍历等。

针对这些功能本例共定义了三个接口：Initer、Operater 和 Order。

###### 1) Initer 接口

当为二叉树创建了一个新节点时，Initer 接口提供了 SetData() 方法可以对节点的 Data 字段进行初始化。

Initer 接口定义如下：

```go
type Initer interface {
    SetData (data interface{})
}
```

###### 2) Operater 接口

当已经生成了一个二叉树时，可以使用 Operater 接口提供的三个方法：PrintBT()、Depth() 和 LeafCount()，对二叉树进行输出、深度计算和叶子统计等基本操作。

Operater 接口定义如下：

```go
type Operater interface {
    PrintBT()
    Depth() int
    LeafCount() int
}
```

###### 3) Order 接口

对二叉树的遍历是一个重要的功能，这些功能在接口 Order 中实现，Order 接口中共定义了三个方法，分别是 PreOrder()、InOrder() 和 PostOrder()，分别可以实现前序遍历、中序遍历和后序遍历。

Order 接口的定义如下：

```go
type Order interface {
    PreOrder()
    InOrder()
    PostOrder()
}
```

可以看到，在定义接口时，接口中的方法只需声明原型，而并不需在此实现。这些方法的实现可以在其他 Go 包文件中实现，或者直接由其他用户提供。

接口的意义也在于此，即同一个接口可以有不同的实现方式，甚至由不同的人去完成。

##### 方法的实现

通过接口的概念知道接口是方法的组合，而在定义接口时不必马上实现方法，方法可由设计者自己或交由其他人单独设计。本例三个接口中共有 7 个方法，下面分别介绍一下它们是怎么实现的。

###### 1) SetData 方法

SetData() 通过空接口 interface{}，可以将任意类型数据赋值给二叉树节点的 Data 字段，实现二叉树对任意数据类型的存储。

SetData 方法的定义如下：

```go
func (n *Node) SetData(data interface{}) {
    n.Data = data
}
```

###### 2) PrintBT 方法

PrintBT() 调用底层函数 PrintBT()，输出一个给定二叉树的嵌套括号表示。

PrintBT 方法的定义如下：

```go
func (n *Node) PrintBT() {
    PrintBT(n)
}
```

###### 3) Depth 方法

Depth() 调用底层函数 Depth()，返回二叉树的深度。

Depth 方法的定义如下：

```go
func (n *Node) Depth() int {   
  return Depth(n) 
}
```

###### 4) LeafCount 方法

LeafCount() 调用底层函数 LeafCount()，返回二叉树的叶子节点数。

LeafCount 方法的定义如下：

```go
func (n *Node) LeafCount() int {  
  return LeafCount(n)
}
```

###### 5) PreOrder 方法

PreOrder() 调用底层函数 PreOrder() 对二叉树进行前序遍历。

PreOrder 方法的定义如下：

```go
func (n *Node) PreOrder() {   
  PreOrder(n) 
}
```

###### 6) InOrder 方法

InOrder() 调用底层函数 InOrder() 对二叉树进行中序遍历。

InOrder 方法的定义如下：

```go
func (n *Node) InOrder() {   
  InOrder(n) 
}
```

###### 7) PostOrder 方法

PostOrder() 调用底层函数 PostOrder() 对二叉树进行后序遍历。

PostOrder 方法的定义如下：

```go
func (n *Node) PostOrder() {   
  PostOrder(n) 
}
```

##### 底层函数设计

在面向对象程序设计中，上层方法的功能实现还要依赖底层函数，本例中大部分方法也是这样，现将所有底层函数一一列举如下。

###### 1) NewNode 函数

NewNode() 按照链接存储方式生成一个新的二叉树节点，参数 left 指向左指针域，参数 right 指向右指针域。

NewNode 函数的定义如下：

```go
func NewNode(left, right *Node) *Node {   
  return &Node{left, nil, right} 
}
```

###### 2) PrintBT 函数

PrintBT() 用于输出一个给定二叉树的嵌套括号表示，采用递归算法：

- 首先输出根节点，然后再依次输出左子树和右子树，在输出左子树前打印输出左括号 “(”，在输出右子树后打印输出右括号 “)”；

- 另外，依次输出的左、右子树要至少有一个不为空，若都为空就不必输出了。

PrintBT 函数的定义如下：

```go
  func PrintBT(n *Node) {
      if n != nil {
          fmt.Printf("%v", n.Data)
          if n.Left != nil || n.Right != nil {
              fmt.Printf("(")
              PrintBT(n.Left)
              if n.Right != nil {
                  fmt.Printf(",")
              }
              PrintBT(n.Right)
              fmt.Printf(")")
          }
      }
  }
```

###### 3) Depth 函数

Depth() 用于计算二叉树的深度，采用递归算法：

- 若一棵二叉树为空，则其深度为 0；

- 否则，其深度等于左子树或右子树的最大深度加 1。

Depth 函数的定义如下：

```go
  func Depth(n *Node) int {
      var depleft, depright int
      if n == nil {
          return 0
      } else {
          depleft = Depth(n.Left)
          depright = Depth(n.Right)
          if depleft > depright {
              return depleft + 1
          } else {
              return depright + 1
          }
      }
  }
```

###### 4) LeafCount 函数

LeafCount() 用于统计二叉树叶子节点数，采用递归算法：

- 若一棵二叉树为空，则其叶子节点数为 0；

- 若一棵二叉树的左、右子树均为空，则其叶子节点数为 1；

- 否则叶子数等于左子树与右子树叶子总数之和。

LeafCount 函数的定义如下：

```go
  func LeafCount(n *Node) int {
      if n == nil {
          return 0
      } else if (n.Left == nil) && (n.Right == nil) {
          return 1
      } else {
          return (LeafCount(n.Left) + LeafCount(n.Right))
      }
  }
```

###### 5) PreOrder 函数

PreOrder() 可以对二叉树进行前序遍历，采用递归算法，按照先访问根节点，再访问左子树，最后访问右子树的次序访问二叉树中的所有节点，且每个节点仅访问一次。

PreOrder 函数的定义如下：

```go
  func PreOrder(n *Node) {
      if n != nil {
          fmt.Printf("%v", n.Data)
          PreOrder(n.Left)
          PreOrder(n.Right)
      }
  }
```

###### 6) InOrder 函数

InOrder() 可以对二叉树进行中序遍历，采用递归算法，按照先访问左子树，再访问根节点，最后访问右子树的次序访问二叉树中的所有节点，且每个节点仅访问一次。

InOrder 函数的定义如下：

```go
  func InOrder(n *Node) {
      if n != nil {
          PreOrder(n.Left)
          fmt.Printf("%v", n.Data)
          PreOrder(n.Right)
      }
  }
```

###### 7) PostOrder 函数

PostOrder() 可以对二叉树进行后序遍历，采用递归算法，按照先访问左子树，再访问右子树，最后访问根节点的次序访问二叉树中的所有节点，且每个节点仅访问一次。

PostOrder 函数的定义如下：

```go
  func PostOrder(n *Node) {
      PreOrder(n.Left)
      PreOrder(n.Right)
      fmt.Printf("%v", n.Data)
  }
```

#### 二叉树基本应用测试

前面介绍了二叉树链接存储结构，以及节点定义、接口定义、方法实现和底层函数设计，并在包 btree 中实现。接下来将利用这些知识实现几个二叉树的基本应用，包括二叉树的创建、基本操作和遍历。

##### 二叉树创建

二叉树的创建过程一般如下：

- 首先调用 NewNode() 函数创建根节点，再调用 SetData() 方法初始化根节点。

- 使用同样的方法创建左子树和右子树，并将左、右子树链接到根节点上。

- 如果左、右子树有叶子节点，则插入叶子节点并和左、右子树建立链接。

【示例 1】二叉树的建立，本例将演示如何使用 Initer 接口实现根节点的初始化。

```go
  // 二叉树的建立
  package main

  import(
      "fmt"
      "btree"
  )

  func main() {
      //创建根节点
      root := NewNode(nil, nil)
      var it Initer
      it = root
      it.SetData("root node")
      //创建左子树
      a := NewNode(nil, nil)
      a.SetData("left node")
      al := NewNode(nil, nil)     //左叶子节点
      al.SetData(100)
      ar := NewNode(nil, nil)     //右叶子节点
      ar.SetData(3.14)
      a.Left = al
      a.Right = ar
      //创建右子树
      b := NewNode(nil, nil)
      b.SetData("right node")
      root.Left = a
      root.Right = b
      root.PrintBT()
  }
```

编译并运行该程序，输出结果为：

```go
root node (left node ( 100,3.14),right node)
```

通过输出结果可以看出，在示例中首先创建了根节点 root node，然后创建左子树 left node 和右子树 right node。左子树有两个叶子节点，左叶子的值为 int 型 “100”，右叶子的值为 float 型 “3.14”。即该二叉树可以存储不同类型的值，这些都是由空接口 interface{} 实现的。

##### 二叉树基本操作

对一个已存在的二叉树的基本操作包括二叉树的输出、深度计算、叶子数统计等，在下面将演示如何使用 Operater 接口实现这些基本操作。

【示例 2】二叉树的基本操作。

```go
  // 二叉树的基本操作
  package main

  import(
      "fmt"
      "btree"
  )

  func main() {
      //创建二叉树
      root := NewNode(nil, nil)
      root.SetData("root node")
      a := NewNode(nil, nil)
      a.SetData("left node")
      al := NewNode(nil, nil)
      al.SetData(100)
      ar := NewNode(nil, nil)
      ar.SetData(3.14)
      a.Left = al
      a.Right = ar
      b := NewNode(nil, nil)
      b.SetData("right node")
      root.Left = a
      root.Right = b
      // 使用 Operater 接口实现对二叉树的基本操作
      var it Operater
      it = root
      it.PrintBT()
      fmt.Println()
      fmt.Println("The depths of the Btree is:", it.Depth())
      fmt.Println("The leaf counts of the Btree is:", it.LeafCount())
  }
```

编译并运行该程序，输出结果为：

```go
root node (left node (100,3.14),right node )
The depths of the Btree is: 3
The leaf counts of the Btree is: 3
```

通过输出结果可以看出，上面示例中二叉树的深度为 3，叶子节点数也为 3，这和验证结果完全一致。另外，对二叉树的操作还有査找、插入、删除节点等，大家可以在上面的基础上自行完成。

##### 二叉树遍历

在二叉树的一些基本应用中，常常需要在树中查找具有某种特征的节点，或者对树中全部节点逐一进行某种处理，这就是二叉树的遍历（Traversing binary tree）。即如何按某条搜索路径访问树中的每个节点，使得每个节点均能被访问一次，而且仅被访问一次。

二叉树的遍历方法一般分为前序遍历、中序遍历和后序遍历，下面示例将演示如何使用 Order 接口实现二叉树的三种遍历。

【示例 3】二叉树的遍历。

```go
  // 二叉树的遍历
  package main

  import(
      "fmt"
      "btree"
  )

  func main() {
      //创建二叉树
      root := NewNode(nil, nil)
      root.SetData("root node")
      a := NewNode(nil, nil)
      a.SetData("left node")
      al := NewNode(nil, nil)
      al.SetData(100)
      ar := NewNode(nil, nil)
      ar.SetData(3.14)
      a.Left = al
      a.Right = ar
      b := NewNode(nil, nil)
      b.SetData("right node")
      root.Left = a
      root.Right = b
      // 使用 Order 接口实现对二叉树的基本操作
      var it Order
      it = root
      it.PreOrder()       //先序遍历
      fmt.Println()
      it.InOrder()        //中序遍历
      fmt.Println()
      it.PostOrder()      //后序遍历
  }
```

编译并运行该程序，输出结果为：

```go
root node left node 100 3.14 right node
left node 100 3.14 root node right node
left node 100 3.14 right node root node
```

通过输出结果可以看出，示例的三种遍历方法输出结果和验证结果完全一致。当然在对二叉树进行遍历的同时，用户也可以对树中的节点做各种处理，比如修改节点信息等。

## 第八章 语言包

### 1. 包的基本概念

Go语言是使用包来组织源代码的，包（package）是多个 Go 源码的集合，是一种高级的代码复用方案。Go语言中为我们提供了很多内置包，如 fmt、os、io 等。

任何源代码文件必须属于某个包，同时源码文件的第一行有效代码必须是`package pacakgeName `语句，通过该语句声明自己所在的包。

#### 包的基本概念

Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。

包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在`GOPATH/src/a/b/ `下定义一个包 c。在包 c 的源码中只需声明为`package c`，而不是声明为`package a/b/c`，但是在导入 c 包时，需要带上路径，例如`import "a/b/c"`。

包的习惯用法：

- 包名一般是小写的，使用一个简短且有意义的名称。
- 包名一般要和所在的目录同名，也可以不同，包名中不能包含`- `等特殊符号。
- 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到`GOPATH/src/github.com/userName/projectName `目录下。
- 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。
- 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。

#### 包的导入

要在代码中引用其他包的内容，需要使用 import 关键字导入使用的包。具体语法如下：

```go
import "包的路径"
```

注意事项：

- import 导入语句通常放在源码文件开头包声明语句的下面；
- 导入的包名需要使用双引号包裹起来；
- 包名是从`GOPATH/src/ `后开始计算的，使用`/ `进行路径分隔。


包的导入有两种写法，分别是单行导入和多行导入。

##### 单行导入

单行导入的格式如下：

```go
import "包 1 的路径"
import "包 2 的路径"
```

##### 多行导入

多行导入的格式如下：

```go
import (
  "包 1 的路径"
  "包 2 的路径"
)
```

#### 包的导入路径

包的引用路径有两种写法，分别是全路径导入和相对路径导入。

##### 全路径导入

包的绝对路径就是`GOROOT/src/`或`GOPATH/src/`后面包的存放路径，如下所示：

```go
import "lab/test"
import "database/sql/driver"
import "database/sql"
```

上面代码的含义如下：

- test 包是自定义的包，其源码位于`GOPATH/src/lab/test `目录下；
- driver 包的源码位于`GOROOT/src/database/sql/driver `目录下；
- sql 包的源码位于`GOROOT/src/database/sql `目录下。

##### 相对路径导入

相对路径只能用于导入`GOPATH `下的包，标准包的导入只能使用全路径导入。

例如包 a 的所在路径是`GOPATH/src/lab/a`，包 b 的所在路径为`GOPATH/src/lab/b`，如果在包 b 中导入包 a ，则可以使用相对路径导入方式。示例如下：

```go
// 相对路径导入
import "../a
```

当然了，也可以使用上面的全路径导入，如下所示：

```go
// 全路径导入
import "lab/a"
```

#### 包的引用格式

包的引用有四种格式，下面以 fmt 包为例来分别演示一下这四种格式。

##### 1) 标准引用格式

```go
import "fmt"
```

此时可以用`fmt.`作为前缀来使用 fmt 包中的方法，这是常用的一种方式。

示例代码如下：

```go
package main
import "fmt"
func main() {
    fmt.Println("C语言中文网")
}

```

##### 2) 自定义别名引用格式

在导入包的时候，我们还可以为导入的包设置别名，如下所示：

```go
import F "fmt"
```

其中 F 就是 fmt 包的别名，使用时我们可以使用`F.`来代替标准引用格式的`fmt.`来作为前缀使用 fmt 包中的方法。

示例代码如下：

```go
package main
import F "fmt"
func main() {
    F.Println("C语言中文网")
}
```

##### 3) 省略引用格式

```go
import . "fmt"
```

这种格式相当于把 fmt 包直接合并到当前程序中，在使用 fmt 包内的方法是可以不用加前缀`fmt.`，直接引用。

示例代码如下：

```go
package main
import . "fmt"
func main() {
    //不需要加前缀 fmt.
    Println("C语言中文网")
}
```

##### 4) 匿名引用格式

在引用某个包时，如果只是希望执行包初始化的 init 函数，而不使用包内部的数据时，可以使用匿名引用格式，如下所示：

```go
import _ "fmt"
```

匿名导入的包与其他方式导入的包一样都会被编译到可执行文件中。

使用标准格式引用包，但是代码中却没有使用包，编译器会报错。如果包中有 init 初始化函数，则通过`import _ "包的路径" `这种方式引用包，仅执行包的初始化函数，即使包没有 init 初始化函数，也不会引发编译器报错。

示例代码如下：

```go
package main
import (
    _ "database/sql"
    "fmt"
)
func main() {
    fmt.Println("C语言中文网")
}
```

注意：

- 一个包可以有多个 init 函数，包加载时会执行全部的 init 函数，但并不能保证执行顺序，所以不建议在一个包中放入多个 init 函数，将需要初始化的逻辑放到一个 init 函数里面。
- 包不能出现环形引用的情况，比如包 a 引用了包 b，包 b 引用了包 c，如果包 c 又引用了包 a，则编译不能通过。
- 包的重复引用是允许的，比如包 a 引用了包 b 和包 c，包 b 和包 c 都引用了包 d。这种场景相当于重复引用了 d，这种情况是允许的，并且 Go 编译器保证包 d 的 init 函数只会执行一次。

#### 包加载

通过前面一系列的学习相信大家已经大体了解了 Go 程序的启动和加载过程，在执行 main 包的 mian 函数之前， Go 引导程序会先对整个程序的包进行初始化。整个执行的流程如下图所示。



![Go 包的初始化](http://c.biancheng.net/uploads/allimg/190821/4-1ZR1102245R8.gif)
图：Go 包的初始化


Go语言包的初始化有如下特点：

- 包初始化程序从 main 函数引用的包开始，逐级查找包的引用，直到找到没有引用其他包的包，最终生成一个包引用的有向无环图。
- Go 编译器会将有向无环图转换为一棵树，然后从树的叶子节点开始逐层向上对包进行初始化。
- 单个包的初始化过程如上图所示，先初始化常量，然后是全局变量，最后执行包的 init 函数。

### 2. 封装简介及实现细节

在Go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只能通过被授权的方法，才能对字段进行操作。

封装的好处：

- 隐藏实现细节；
- 可以对数据进行验证，保证数据安全合理。


如何体现封装：

- 对结构体中的属性进行封装；
- 通过方法，包，实现封装。


封装的实现步骤：

- 将结构体、字段的首字母小写；
- 给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；
- 提供一个首字母大写的 Set 方法（类似其它语言的 public），用于对属性判断并赋值；
- 提供一个首字母大写的 Get 方法（类似其它语言的 public），用于获取属性的值。


【示例】对于员工，不能随便查看年龄，工资等隐私，并对输入的年龄进行合理的验证。代码结构如下：



![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ6101Q0445.gif)


person.go 中的代码如下所示：

```go
package model
import "fmt"
type person struct {
    Name string
    age int   //其它包不能直接访问..
    sal float64
}
//写一个工厂模式的函数，相当于构造函数
func NewPerson(name string) *person {
    return &person{
        Name : name,
    }
}
//为了访问age 和 sal 我们编写一对SetXxx的方法和GetXxx的方法
func (p *person) SetAge(age int) {
    if age >0 && age <150 {
        p.age = age
    } else {
        fmt.Println("年龄范围不正确..")
        //给程序员给一个默认值
    }
}
func (p *person) GetAge() int {
    return p.age
}
func (p *person) SetSal(sal float64) {
    if sal >= 3000 && sal <= 30000 {
        p.sal = sal
    } else {
        fmt.Println("薪水范围不正确..")
    }
}
func (p *person) GetSal() float64 {
    return p.sal
}
```

main.go 中的代码如下所示：

```go
package main
import (
    "fmt"
    "../model"
)
func main() {
    p := model.NewPerson("smith")
    p.SetAge(18)
    p.SetSal(5000)
    fmt.Println(p)
    fmt.Println(p.Name, " age =", p.GetAge(), " sal = ", p.GetSal())
}
```

执行效果如下图所示：

![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ6101U5450.gif)

### 3. GOPATH详解（Go语言工作目录）

GOPATH 是 Go语言中使用的一个环境变量，它使用绝对路径提供项目的工作目录。

工作目录是一个工程开发的相对参考目录，好比当你要在公司编写一套服务器代码，你的工位所包含的桌面、计算机及椅子就是你的工作区。工作区的概念与工作目录的概念也是类似的。如果不使用工作目录的概念，在多人开发时，每个人有一套自己的目录结构，读取配置文件的位置不统一，输出的二进制运行文件也不统一，这样会导致开发的标准不统一，影响开发效率。

GOPATH 适合处理大量 Go语言源码、多个包组合而成的复杂工程。

#### 提示

C、[C++](http://c.biancheng.net/cplus/)、[Java](http://c.biancheng.net/java/)、[C#](http://c.biancheng.net/csharp/) 及其他语言发展到后期，都拥有自己的 IDE（集成开发环境），并且工程（Project）、解决方案（Solution）和工作区（Workspace）等概念将源码和资源组织了起来，方便编译和输出。

#### 使用命令行查看GOPATH信息

在《[安装Go语言开发包](http://c.biancheng.net/view/3992.html)》一节中我们已经介绍过 Go语言的安装方法。在安装过 Go 开发包的操作系统中，可以使用命令行查看 Go 开发包的环境变量配置信息，这些配置信息里可以查看到当前的 GOPATH 路径设置情况。在命令行中运行`go env`后，命令行将提示以下信息：

```go
$ go env
GOARCH="amd64"
GOBIN=""
GOEXE=""
GOHOSTARCH="amd64"
GOHOSTOS="linux"
GOOS="linux"
GOPATH="/home/davy/go"
GORACE=""
GOROOT="/usr/local/go"
GOTOOLDIR="/usr/local/go/pkg/tool/linux_amd64"
[GCC](http://c.biancheng.net/gcc/)GO="gccgo"
CC="gcc"
GOGCCFLAGS="-fPIC -m64 -pthread -fmessage-length=0"
CXX="g++"
CGO_ENABLED="1"
CGO_CFLAGS="-g -O2"
CGO_CPPFLAGS=""
CGO_CXXFLAGS="-g -O2"
CGO_FFLAGS="-g -O2"
CGO_LDFLAGS="-g -O2"
PKG_CONFIG="pkg-config"
```

命令行说明如下：

- 第 1 行，执行 go env 指令，将输出当前 Go 开发包的环境变量状态。
- 第 2 行，GOARCH 表示目标处理器架构。
- 第 3 行，GOBIN 表示编译器和链接器的安装位置。
- 第 7 行，GOOS 表示目标操作系统。
- 第 8 行，GOPATH 表示当前工作目录。
- 第 10 行，GOROOT 表示 Go 开发包的安装目录。


从命令行输出中，可以看到 GOPATH 设定的路径为：/home/davy/go（davy 为笔者的用户名）。

在 Go 1.8 版本之前，GOPATH 环境变量默认是空的。从 Go 1.8 版本开始，Go 开发包在安装完成后，将 GOPATH 赋予了一个默认的目录，参见下表。



| 平  台       | GOPATH 默认值    | 举 例              |
| ------------ | ---------------- | ------------------ |
| Windows 平台 | %USERPROFILE%/go | C:\Users\用户名\go |
| Unix 平台    | $HOME/go         | /home/用户名/go    |

#### 使用GOPATH的工程结构

在 GOPATH 指定的工作目录下，代码总是会保存在 $GOPATH/src 目录下。在工程经过 go build、go install 或 go get 等指令后，会将产生的二进制可执行文件放在 $GOPATH/bin 目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。

如果需要将整个源码添加到版本管理工具（Version Control System，VCS）中时，只需要添加 $GOPATH/src 目录的源码即可。bin 和 pkg 目录的内容都可以由 src 目录生成。

#### 设置和使用GOPATH

本节以 Linux 为演示平台，为大家演示使用 GOPATH 的方法。

##### 1) 设置当前目录为GOPATH

选择一个目录，在目录中的命令行中执行下面的指令：

```go
export GOPATH=`pwd
```

该指令中的 pwd 将输出当前的目录，使用反引号```将 pwd 指令括起来表示命令行替换，也就是说，使用``pwd``将获得 pwd 返回的当前目录的值。例如，假设你的当前目录是“/home/davy/go”，那么使用``pwd``将获得返回值“/home/davy/go”。

使用 export 指令可以将当前目录的值设置到环境变量 GOPATH中。

##### 2) 建立GOPATH中的源码目录

使用下面的指令创建 GOPATH 中的 src 目录，在 src 目录下还有一个 hello 目录，该目录用于保存源码。

```go
mkdir -p src/hell
```

mkdir 指令的 -p 可以连续创建一个路径。

##### 3) 添加main.go源码文件

使用 Linux 编辑器将下面的源码保存为 main.go 并保存到 $GOPATH/src/hello 目录下。

```go
package main
import "fmt"
func main(){
    fmt.Println("hello")
}
```

##### 4) 编译源码并运行

此时我们已经设定了 GOPATH，因此在 Go语言中可以通过 GOPATH 找到工程的位置。

在命令行中执行如下指令编译源码：

```go
go install hello
```

编译完成的可执行文件会保存在 $GOPATH/bin 目录下。

在 bin 目录中执行 ./hello，命令行输出如下：

```go
hello world
```

#### 在多项目工程中使用GOPATH

在很多与 Go语言相关的书籍、文章中描述的 GOPATH 都是通过修改系统全局的环境变量来实现的。然而，根据笔者多年的 Go语言使用和实践经验及周边朋友、同事的反馈，这种设置全局 GOPATH 的方法可能会导致当前项目错误引用了其他目录的 Go 源码文件从而造成编译输出错误的版本或编译报出一些无法理解的错误提示。

比如说，将某项目代码保存在 /home/davy/projectA 目录下，将该目录设置为 GOPATH。随着开发进行，需要再次获取一份工程项目的源码，此时源码保存在 /home/davy/projectB 目录下，如果此时需要编译 projectB 目录的项目，但开发者忘记设置 GOPATH 而直接使用命令行编译，则当前的 GOPATH 指向的是 /home/davy/projectA 目录，而不是开发者编译时期望的 projectB 目录。编译完成后，开发者就会将错误的工程版本发布到外网。

因此，建议大家无论是使用命令行或者使用集成开发环境编译 Go 源码时，GOPATH 跟随项目设定。在 Jetbrains 公司的 GoLand 集成开发环境（IDE）中的 GOPATH 设置分为全局 GOPATH 和项目 GOPATH，如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180816/1-1PQ615311aL.jpg)
图：全局和项目GOPATH


图中的 Global GOPATH 代表全局 GOPATH，一般来源于系统环境变量中的 GOPATH；Project GOPATH 代表项目所使用的 GOPATH，该设置会被保存在工作目录的 .idea 目录下，不会被设置到环境变量的 GOPATH 中，但会在编译时使用到这个目录。建议在开发时只填写项目 GOPATH，每一个项目尽量只设置一个 GOPATH，不使用多个 GOPATH 和全局的 GOPATH。

#### 提示

Visual Studio 早期在设计时，允许 C++ 语言在全局拥有一个包含路径。当一个工程多个版本的编译，或者两个项目混杂有不同的共享全局包含时，会发生难以察觉的错误。在新版本 Visual Studio 中已经废除了这种全局包含的路径设计，并建议开发者将包含目录与项目关联。

Go语言中的 GOPATH 也是一种类似全局包含的设计，因此鉴于 Visual Studio 在设计上的失误，建议开发者不要设置全局的 GOPATH，而是随项目设置 GOPATH。

### 4. 常用内置包简介

标准的Go语言代码库中包含了大量的包，并且在安装 Go 的时候多数会自动安装到系统中。我们可以在 $GOROOT/src/pkg 目录中查看这些包。下面简单介绍一些我们开发中常用的包。

#### 1) fmt

fmt 包实现了格式化的标准输入输出，这与C语言中的 printf 和 scanf 类似。其中的 fmt.Printf() 和 fmt.Println() 是开发者使用最为频繁的函数。

格式化短语派生于C语言，一些短语（%- 序列）是这样使用：

- %v：默认格式的值。当打印结构时，加号（%+v）会增加字段名；
- %#v：Go样式的值表达；
- %T：带有类型的 Go 样式的值表达。

#### 2) io

这个包提供了原始的 I/O 操作界面。它主要的任务是对 os 包这样的原始的 I/O 进行封装，增加一些其他相关，使其具有抽象功能用在公共的接口上。

#### 3) bufio

bufio 包通过对 io 包的封装，提供了数据缓冲功能，能够一定程度减少大块数据读写带来的开销。

在 bufio 各个组件内部都维护了一个缓冲区，数据读写操作都直接通过缓存区进行。当发起一次读写操作时，会首先尝试从缓冲区获取数据，只有当缓冲区没有数据时，才会从数据源获取数据更新缓冲。

#### 4) sort

sort 包提供了用于对切片和用户定义的集合进行排序的功能。

#### 5) strconv

strconv 包提供了将字符串转换成基本数据类型，或者从基本数据类型转换为字符串的功能。

#### 6) os

os 包提供了不依赖平台的操作系统函数接口，设计像 Unix 风格，但错误处理是 go 风格，当 os 包使用时，如果失败后返回错误类型而不是错误数量。

#### 7) sync

sync 包实现多线程中锁机制以及其他同步互斥机制。

#### 8) flag

flag 包提供命令行参数的规则定义和传入参数解析的功能。绝大部分的命令行程序都需要用到这个包。

#### 9) encoding/json

JSON 目前广泛用做网络程序中的通信格式。encoding/json 包提供了对 JSON 的基本支持，比如从一个对象序列化为 JSON 字符串，或者从 JSON 字符串反序列化出一个具体的对象等。

#### 10) html/template

主要实现了 web 开发中生成 html 的 template 的一些函数。

#### 11) net/http

net/http 包提供 HTTP 相关服务，主要包括 http 请求、响应和 URL 的解析，以及基本的 http 客户端和扩展的 http 服务。

通过 net/http 包，只需要数行代码，即可实现一个爬虫或者一个 Web 服务器，这在传统语言中是无法想象的。

#### 12) reflect

reflect 包实现了运行时反射，允许程序通过抽象类型操作对象。通常用于处理静态类型 interface{} 的值，并且通过 Typeof 解析出其动态类型信息，通常会返回一个有接口类型 Type 的对象。

#### 13) os/exec

os/exec 包提供了执行自定义 linux 命令的相关实现。

#### 14) strings

strings 包主要是处理字符串的一些函数集合，包括合并、查找、分割、比较、后缀检查、索引、大小写处理等等。

strings 包与 bytes 包的函数接口功能基本一致。

#### 15) bytes

bytes 包提供了对字节切片进行读写操作的一系列函数。字节切片处理的函数比较多，分为基本处理函数、比较函数、后缀检查函数、索引函数、分割函数、大小写处理函数和子切片处理函数等。

#### 16) log

log 包主要用于在程序中输出日志。

log 包中提供了三类日志输出接口，Print、Fatal 和 Panic。

- Print 是普通输出；
- Fatal 是在执行完 Print 后，执行 os.Exit(1)；
- Panic 是在执行完 Print 后调用 panic() 方法。

### 5. 自定义包

包是Go语言中代码组成和代码编译的主要方式。关于包的基本信息我们已经在前面介绍过了，本节我们主要来介绍一下如何自定义一个包并使用它。

到目前为止，我们所使用的例子都是以一个包的形式存在的，比如 main 包。在Go语言里，允许我们将同一个包的代码分隔成多个独立的源码文件来单独保存，只需要将这些文件放在同一个目录下即可。

我们创建的自定义的包需要将其放在 GOPATH 的 src 目录下（也可以是 src 目录下的某个子目录），而且两个不同的包不能放在同一目录下，这样会引起编译错误。

一个包中可以有任意多个文件，文件的名字也没有任何规定（但后缀必须是 .go），这里我们假设包名就是 .go 的文件名（如果一个包有多个 .go 文件，则其中会有一个 .go 文件的文件名和包名相同）。

下面通过示例来演示一下如何创建一个名为 demo 的自定义包，并在 main 包中使用自定义包 demo 中的方法。

首先，在 GOPATH 下的 src 目录中新建一个 demo 文件夹 ，并在 demo 文件夹下创建 demo.go 文件，如下所示：



![img](http://c.biancheng.net/uploads/allimg/191211/4-191211143234M9.gif)
图：demo 文件夹


demo.go 文件的代码如下所示：

```go
package demo
import (
    "fmt"
)
func PrintStr() {
    fmt.Println("C语言中文网")
}
```

然后，在 GOPATH 下的 src 目录中新建一个 main 文件夹，并在 main 文件夹下创建 mian.go 文件，如下所示：



![img](http://c.biancheng.net/uploads/allimg/191211/4-191211143301c4.gif)
图：main 文件夹


main.go 文件的代码如下所示：

```go
package main
import (
    "demo"
)
func main() {
    demo.PrintStr()
}
```

运行结果如下所示：

```go
go run main.go
C语言中文网
```

对引用自定义包需要注意以下几点：

- 如果项目的目录不在 GOPATH 环境变量中，则需要把项目移到 GOPATH 所在的目录中，或者将项目所在的目录设置到 GOPATH 环境变量中，否则无法完成编译；
- 使用 import 语句导入包时，使用的是包所属文件夹的名称；
- 包中的函数名第一个字母要大写，否则无法在外部调用；
- 自定义包的包名不必与其所在文件夹的名称保持一致，但为了便于维护，建议保持一致；
- 调用自定义包时使用 `包名 . 函数名` 的方式，如上例：demo.PrintStr()。

### 6. 导出包中的标识符——让外部访问包的类型和值

在 Go语言中，如果想在一个包里引用另外一个包里的标识符（如类型、变量、常量等）时，必须首先将被引用的标识符导出，将要导出的标识符的首字母大写就可以让引用者可以访问这些标识符了。

#### 导出包内标识符

下面代码中包含一系列未导出标识符，它们的首字母都为小写，这些标识符可以在包内自由使用，但是包外无法访问它们，代码如下：

```go
package mypkg
var myVar = 100
const myConst = "hello"
type myStruct struct {
}
```

将 myStruct 和 myConst 首字母大写，导出这些标识符，修改后代码如下：

```go
package mypkg
var myVar = 100
const MyConst = "hello"
type MyStruct struct {
}
```

此时，MyConst 和 MyStruct 可以被外部访问，而 myVar 由于首字母是小写，因此只能在 mypkg 包内使用，不能被外部包引用。

#### 导出结构体及接口成员

在被导出的结构体或接口中，如果它们的字段或方法首字母是大写，外部可以访问这些字段和方法，代码如下：

```go
type MyStruct struct {
    // 包外可以访问的字段
    ExportedField int
    // 仅限包内访问的字段
    privateField int
}
type MyInterface interface {
    // 包外可以访问的方法
    ExportedMethod()
    // 仅限包内访问的方法
    privateMethod()
}
```

在代码中，MyStruct 的 ExportedField 和 MyInterface 的 ExportedMethod() 可以被包外访问。

### 7. import导入包——在代码中使用其他的代码

可以在一个 Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。要引用其他包的标识符，可以使用 import 关键字，导入的包名使用双引号包围，包名是从 GOPATH 开始计算的路径，使用`/`进行路径分隔。

#### 默认导入的写法

导入有两种基本格式，即单行导入和多行导入，两种导入方法的导入代码效果是一致的。

##### 1) 单行导入

单行导入格式如下：

```go
import "包1"
import "包2
```

##### 2) 多行导入

当多行导入时，包名在 import 中的顺序不影响导入效果，格式如下：

```go
import(
  "包1"
  "包2"
  …

```

参考代码 8-1 的例子来理解 import 的机制。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ   提取密码：hfyf

代码 8-1 的目录层次如下：

```go
.
└── src
  └── chapter08
    └── importadd
      ├── main.go
      └── mylib
        └── add.go
```

代码8-1　加函数（具体文件：…/chapter08/importadd/mylib/add.go）

```go
package mylib
func Add(a, b int) int {
    return a + b
}
```

第 3 行中的 Add() 函数以大写 A 开头，表示将 Add() 函数导出供包外使用。当首字母小写时，为包内使用，包外无法引用到。

add.go 在 mylib 文件夹下，习惯上将文件夹的命名与包名一致，命名为 mylib 包。

代码8-2　导入包（具体文件：…/chapter08/importadd/main.go）

```go
package main
import (
    "chapter08/importadd/mylib"
    "fmt"
)
func main() {
    fmt.Println(mylib.Add(1, 2))
}
```

代码说明如下：

- 第 4 行，导入 chapter08/importadd/mylib 包。
- 第 9 行，使用 mylib 作为包名，并引用 Add() 函数调用。


在命令行中运行下面代码：

```go
export GOPATH=/home/davy/golangbook/code
go install chapter08/importadd
$GOPATH/bin/importadd
```

命令说明如下：

- 第 1 行，根据你的 GOPATH 不同，设置 GOPATH。
- 第 2 行，使用 go install 指令编译并安装 chapter08/code8-1 到 GOPATH 的 bin 目录下。
- 第 3 行，执行 GOPATH 的 bin 目录下的可执行文件 code8-1。


运行代码，输出结果如下：

```go

```

导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt 和 goimports 工具都可以将不同分组导入的包独立排序。）

```go
import (
    "fmt"
    "html/template"
    "os"
    "golang.org/x/net/html"
    "golang.org/x/net/ipv4"
)
```

#### 导入包后自定义引用的包名

如果我们想同时导入两个有着名字相同的包，例如 math/rand 包和 crypto/rand 包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。

```go
import (
    "crypto/rand"
    mrand "math/rand" // 将名称替换为mrand避免冲突
)
```

导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。

导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为 path 的变量，那么我们可以将"path"标准包重命名为 pathpkg。

每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。

#### 匿名导入包——只导入包但不使用包内类型和数值

如果只希望导入包，而不使用任何包内的结构和类型，也不调用包内的任何函数时，可以使用匿名导入包，格式如下：

```go
import (
    _ "path/to/package"
)
```

其中，path/to/package 表示要导入的包名，下画线`_`表示匿名导入包。

匿名导入的包与其他方式导入包一样会让导入包编译到可执行文件中，同时，导入包也会触发 init() 函数调用。

#### 包在程序启动前的初始化入口：init

在某些需求的设计上需要在程序启动时统一调用程序引用到的所有包的初始化函数，如果需要通过开发者手动调用这些初始化函数，那么这个过程可能会发生错误或者遗漏。我们希望在被引用的包内部，由包的编写者获得代码启动的通知，在程序启动时做一些自己包内代码的初始化工作。

例如，为了提高数学库计算三角函数的执行效率，可以在程序启动时，将三角函数的值提前在内存中建成索引表，外部程序通过查表的方式迅速获得三角函数的值。但是三角函数索引表的初始化函数的调用不希望由每一个外部使用三角函数的开发者调用，如果在三角函数的包内有一个机制可以告诉三角函数包程序何时启动，那么就可以解决初始化的问题。

Go 语言为以上问题提供了一个非常方便的特性：init() 函数。

init() 函数的特性如下：

- 每个源码可以使用 1 个 init() 函数。
- init() 函数会在程序执行前（main() 函数执行前）被自动调用。
- 调用顺序为 main() 中引用的包，以深度优先顺序初始化。


例如，假设有这样的包引用关系：main→A→B→C，那么这些包的 init() 函数调用顺序为：

```go
C.init→B.init→A.init→main
```

说明：

- 同一个包中的多个 init() 函数的调用顺序不可预期。
- init() 函数不能被其他函数调用。

#### 理解包导入后的init()函数初始化顺序

Go 语言包会从 main 包开始检查其引用的所有包，每个包也可能包含其他的包。Go 编译器由此构建出一个树状的包引用关系，再根据引用顺序决定编译顺序，依次编译这些包的代码。

在运行时，被最后导入的包会最先初始化并调用 init() 函数。

通过下面的代码理解包的初始化顺序。

代码8-3　包导入初始化顺序入口（…/chapter08/pkginit/main.go）

```go
package main
import "chapter08/code8-2/pkg1"
func main() {
    pkg1.ExecPkg1()
}
```

代码说明如下：

- 第 3 行，导入 pkg1 包。
- 第 7 行，调用 pkg1 包的 ExecPkg1() 函数。


代码8-4　包导入初始化顺序pkg1（…/chapter08/pkginit/pkg1/pkg1.go）

```go
package pkg1
import (
    "chapter08/code8-2/pkg2"
    "fmt"
)
func ExecPkg1() {
    fmt.Println("ExecPkg1")
    pkg2.ExecPkg2()
}
func init() {
    fmt.Println("pkg1 init")
}
```

代码说明如下：

- 第 4 行，导入 pkg2 包。
- 第 8 行，声明 ExecPkg1() 函数。
- 第 12 行，调用 pkg2 包的 ExecPkg2() 函数。
- 第 15 行，在 pkg1 包初始化时，打印 pkg1 init。


代码8-5　包导入初始化顺序pkg2（…/chapter08/pkginit/pkg2/pkg2.go）

```go
package pkg2
import "fmt"
func ExecPkg2() {
    fmt.Println("ExecPkg2")
}
func init() {
    fmt.Println("pkg2 init")
}
```

代码说明如下：

- 第 5 行，声明 ExecPkg2() 函数。
- 第 10 行，在 pkg2 包初始化时，打印 pkg2 init。


执行代码，输出如下：

```go
pkg2 init
pkg1 init
ExecPkg1
ExecPkg2
```

### 8. package（创建包）

包（package）是多个 Go 源码的集合，是一种高级的代码复用方案，像 fmt、os、io 等这样具有常用功能的内置包在 Go语言中有 150 个以上，它们被称为标准库，大部分（一些底层的除外）内置于 Go 本身。

包要求在同一个目录下的所有文件的第一行添加如下代码，以标记该文件归属的包：

```go
package 包
```

包的特性如下：

- 一个目录下的同级文件归属一个包。
- 包名可以与其目录不同名。
- 包名为 main 的包为应用程序的入口包，编译源码没有 main 包时，将无法编译输出可执行的文件。


任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。

每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以避免在我们使用它们的时候减少和其它部分名字的冲突。

每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包 API 的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。

当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。

- 第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。
- 第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。
- 第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件。



### 9. 工厂模式自动注册

本例利用包的 init 特性，将 cls1 和 cls2 两个包注册到工厂，使用字符串创建这两个注册好的结构实例。

完整代码的结构如下：

```go
.
└── src
    └── chapter08
        └── clsfactory
            ├── main.go
            └── base
                └── factory.go
            └── cls1
                └── reg.go
            └── cls2
                └── reg.go
```

类工厂（具体文件：…/chapter08/clsfactory/base/factory.go）

```go
  package base

  // 类接口
  type Class interface {
      Do()
  }

  var (
  // 保存注册好的工厂信息
      factoryByName = make(map[string]func() Class)
  )

  // 注册一个类生成工厂
  func Register(name string, factory func() Class) {
      factoryByName[name] = factory
  }

  // 根据名称创建对应的类
  func Create(name string) Class {
      if f, ok := factoryByName[name]; ok {
          return f()
      } else {
          panic("name not found")
      }
  }
```

这个包叫 base，负责处理注册和使用工厂的基础代码，该包不会引用任何外部的包。

以下是对代码的说明：

- 第 4 行定义了 “产品”：类。

- 第 10 行使用了一个 map 保存注册的工厂信息。

- 第 14 行提供给工厂方注册使用，所谓的 “工厂”，就是一个定义为`func() Class`的普通函数，调用此函数，创建一个类实例，实现的工厂内部结构体会实现 Class 接口。

- 第 19 行定义通过名字创建类实例的函数，该函数会在注册好后调用。

- 第 20 行在已经注册的信息中查找名字对应的工厂函数，找到后，在第 21 行调用并返回接口。

- 第 23 行是如果创建的名字没有找到时，报错。

类 1 及注册代码（具体文件：…/chapter08/clsfactory/cls1/reg.go）

```go
  package cls1

  import (
      "chapter08/clsfactory/base"
      "fmt"
  )

  // 定义类1
  type Class1 struct {
  }

  // 实现Class接口
  func (c *Class1) Do() {
      fmt.Println("Class1")
  }

  func init() {

      // 在启动时注册类1工厂
      base.Register("Class1", func() base.Class {
          return new(Class1)
      })
  }
```

上面的代码展示了 Class1 的工厂及产品定义过程。

- 第 9～15 行定义 Class1 结构，该结构实现了 base 中的 Class 接口。

- 第 20 行，Class1 结构的实例化过程叫 Class1 的工厂，使用 base.Register() 函数在 init() 函数被调用时与一个字符串关联，这样，方便以后通过名字重新调用该函数并创建实例。

类 2 及注册代码（具体文件：…/chapter08/clsfactory/cls2/reg.go）

```go
  package cls2

  import (
      "chapter08/clsfactory/base"
      "fmt"
  )

  // 定义类2
  type Class2 struct {
  }

  // 实现Class接口
  func (c *Class2) Do() {
      fmt.Println("Class2")
  }

  func init() {

      // 在启动时注册类2工厂
      base.Register("Class2", func() base.Class {
          return new(Class2)
      })
  }
```

Class2 的注册与 Class1 的定义和注册过程类似。

类工程主流程（具体文件：…/chapter08/clsfactory/main.go）

```go
  package main

  import (
      "chapter08/clsfactory/base"
      _ "chapter08/clsfactory/cls1"  // 匿名引用cls1包, 自动注册
      _ "chapter08/clsfactory/cls2"  // 匿名引用cls2包, 自动注册
  )

  func main() {

      // 根据字符串动态创建一个Class1实例
      c1 := base.Create("Class1")
      c1.Do()

      // 根据字符串动态创建一个Class2实例
      c2 := base.Create("Class2")
      c2.Do()

  }
```

下面是对代码的说明：

- 第 5 和第 6 行使用匿名引用方法导入了 cls1 和 cls2 两个包。在 main() 函数调用前，这两个包的 init() 函数会被自动调用，从而自动注册 Class1 和 Class2。

- 第 12 和第 16 行，通过 base.Create() 方法查找字符串对应的类注册信息，调用工厂方法进行实例创建。

- 第 13 和第 17 行，调用类的方法。

执行下面的指令进行编译：

```shell
export GOPATH=/home/davy/golangbook/code go install chapter08/clsfactory $GOPATH/bin/clsfactory
```

代码输出如下：

```go
Class1 Class2
```



### 10. 单例模式

设计模式的重要性不用多说，也是面试时常常会被问到的问题。对于设计模式，更多的则是仁者见仁智者见智，要在实际工作中不断的积累，再进行深度的思考，才能逐渐形成的一种思维。

单例模式也叫单子模式，是常用的模式之一，在它的核心结构中只包含一个被称为单例的特殊类，能够保证系统运行中一个类只创建一个实例，本节我们就来介绍一下 Go 语言中的单例模式。

#### 单例模式实现

Go 语言实现单例模式的有四种方式，分别是懒汉式、饿汉式、双重检查和 sync.Once。

懒汉式就是创建对象时比较懒，先不急着创建对象，在需要加载配置文件的时候再去创建；饿汉式则是在系统初始化的时候就已经把对象创建好了，需要用的时候直接拿过来用就好了。

不管那种模式最终目的只有一个，就是只实例化一次，只允许一个实例存在。

下面就来分别介绍一下这四种实现方式：

##### 1) 懒汉式——非线程安全

非线程安全，指的是在多线程下可能会创建多次对象。

```go
  //使用结构体代替类
  type Tool struct {
      values int
  }

  //建立私有变量
  var instance *Tool

  //获取单例对象的方法，引用传递返回
  func GetInstance() *Tool {
      if instance == nil {
          instance = new(Tool)
      }
      return instance
  }
```

在非线程安全的基本上，利用 Sync.Mutex 进行加锁保证线程安全，但由于每次调用该方法都进行了加锁操作，在性能上不是很高效。

```go
  //锁对象
  var lock sync.Mutex

  //加锁保证线程安全
  func GetInstance() *Tool {
      lock.Lock()
      defer lock.Unlock()
      if instance == nil {
          instance = new(Tool)
      }

      return instance
  }
```

##### 2) 饿汉式

直接创建好对象，不需要判断为空，同时也是线程安全，唯一的缺点是在导入包的同时会创建该对象，并持续占有在内存中。

Go 语言饿汉式可以使用 init 函数，也可以使用全局变量。

```go
  type cfg struct {
  }
  var cfg *config
  func init()  {
     cfg = new(config)
  }
  // NewConfig 提供获取实例的方法
  func NewConfig() *config {
     return cfg
  }
  type config struct {
  }
  //全局变量
  var cfg *config = new(config)
  // NewConfig 提供获取实例的方法
  func NewConfig() *config {
     return cfg
  }
```

##### 3) 双重检查

在懒汉式（线程安全）的基础上再进行优化，减少加锁的操作，保证线程安全的同时不影响性能。

```go
  //锁对象
  var lock sync.Mutex

  //第一次判断不加锁，第二次加锁保证线程安全，一旦对象建立后，获取对象就不用加锁了。
  func GetInstance() *Tool {
      if instance == nil {
          lock.Lock()
          if instance == nil {
              instance = new(Tool)
          }
          lock.Unlock()
      }
      return instance
  }
```

##### 5) sync.Once

通过 sync.Once 来确保创建对象的方法只执行一次

```go
  var once sync.Once

  func GetInstance() *Tool {
      once.Do(func() {
          instance = new(Tool)

      })
      return instance
  }
```

sync.Once 内部本质上也是双重检查的方式，但在写法上会比自己写双重检查更简洁，以下是 Once 的源码

```go
  func (o *Once) Do(f func()) {
  　　//判断是否执行过该方法，如果执行过则不执行
      if atomic.LoadUint32(&o.done) == 1 {
          return
      }
      // Slow-path.
      o.m.Lock()
      defer o.m.Unlock()
  　　//进行加锁，再做一次判断，如果没有执行，则进行标志已经扫行并调用该方法
      if o.done == 0 {
          defer atomic.StoreUint32(&o.done, 1)
          f()
      }
  }
```



### 11. sync包与锁：限制线程对变量的访问

Go语言中 sync 包里提供了互斥锁 Mutex 和读写锁 RWMutex 用于处理并发过程中可能出现同时两个或多个协程（或线程）读或写同一个变量的情况。

#### 为什么需要锁

锁是 sync 包中的核心，它主要有两个方法，分别是加锁（Lock）和解锁（Unlock）。

在并发的情况下，多个线程或协程同时其修改一个变量，使用锁能保证在某一时间内，只有一个协程或线程修改这一变量。

不使用锁时，在并发的情况下可能无法得到想要的结果，如下所示：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    var a = 0
    for i := 0; i < 1000; i++ {
        go func(idx int) {
            a += 1
            fmt.Println(a)
        }(i)
    }
    time.Sleep(time.Second)
}
```

从理论上来说，上面的程序会将 a 的值依次递增输出，然而实际结果却是下面这样子的。

```go
537
995
996
997
538
999
1000
```

通过运行结果可以看出 a 的值并不是按顺序递增输出的，这是为什么呢？

协程的执行顺序大致如下所示：

- 从寄存器读取 a 的值；
- 然后做加法运算；
- 最后写到寄存器。


按照上面的顺序，假如有一个协程取得 a 的值为 3，然后执行加法运算，此时又有一个协程对 a 进行取值，得到的值同样是 3，最终两个协程的返回结果是相同的。

而锁的概念就是，当一个协程正在处理 a 时将 a 锁定，其它协程需要等待该协程处理完成并将 a 解锁后才能再进行操作，也就是说同时处理 a 的协程只能有一个，从而避免上面示例中的情况出现。

#### 互斥锁 Mutex

上面的示例中出现的问题怎么解决呢？加一个互斥锁 Mutex 就可以了。那什么是互斥锁呢 ？互斥锁中其有两个方法可以调用，如下所示：

```go
func (m *Mutex) Lock()
func (m *Mutex) Unlock(
```

将上面的代码略作修改，如下所示：

```go
package main
import (
    "fmt"
    "sync"
    "time"
)
func main() {
    var a = 0
    var lock sync.Mutex
    for i := 0; i < 1000; i++ {
        go func(idx int) {
            lock.Lock()
            defer lock.Unlock()
            a += 1
            fmt.Printf("goroutine %d, a=%d\n", idx, a)
        }(i)
    }
    // 等待 1s 结束主程序
    // 确保所有协程执行完
    time.Sleep(time.Second)
}
```

运行结果如下：

```go
goroutine 995, a=996
goroutine 996, a=997
goroutine 997, a=998
goroutine 998, a=999
goroutine 999, a=1000
```

需要注意的是一个互斥锁只能同时被一个 goroutine 锁定，其它 goroutine 将阻塞直到互斥锁被解锁（重新争抢对互斥锁的锁定），示例代码如下：

```go
package main
import (
    "fmt"
    "sync"
    "time"
)
func main() {
    ch := make(chan struct{}, 2)
    var l sync.Mutex
    go func() {
        l.Lock()
        defer l.Unlock()
        fmt.Println("goroutine1: 我会锁定大概 2s")
        time.Sleep(time.Second * 2)
        fmt.Println("goroutine1: 我解锁了，你们去抢吧")
        ch <- struct{}{}
    }()
    go func() {
        fmt.Println("goroutine2: 等待解锁")
        l.Lock()
        defer l.Unlock()
        fmt.Println("goroutine2: 欧耶，我也解锁了")
        ch <- struct{}{}
    }()
    // 等待 goroutine 执行结束
    for i := 0; i < 2; i++ {
        <-ch
    }
}
```

上面的代码运行结果如下：

```go
goroutine1: 我会锁定大概 2s
goroutine2: 等待解锁
goroutine1: 我解锁了，你们去抢吧
goroutine2: 欧耶，我也解锁了
```

#### 读写锁

读写锁有如下四个方法：

- 写操作的锁定和解锁分别是`func (*RWMutex) Lock`和`func (*RWMutex) Unlock`；

- 读操作的锁定和解锁分别是`func (*RWMutex) Rlock`和`func (*RWMutex) RUnlock`。


读写锁的区别在于：

- 当有一个 goroutine 获得写锁定，其它无论是读锁定还是写锁定都将阻塞直到写解锁；
- 当有一个 goroutine 获得读锁定，其它读锁定仍然可以继续；
- 当有一个或任意多个读锁定，写锁定将等待所有读锁定解锁之后才能够进行写锁定。


所以说这里的读锁定（RLock）目的其实是告诉写锁定，有很多协程或者进程正在读取数据，写操作需要等它们读（读解锁）完才能进行写（写锁定）。

我们可以将其总结为如下三条：

- 同时只能有一个 goroutine 能够获得写锁定；
- 同时可以有任意多个 gorouinte 获得读锁定；
- 同时只能存在写锁定或读锁定（读和写互斥）。


示例代码如下所示：

```go
package main
import (
    "fmt"
    "math/rand"
    "sync"
)
var count int
var rw sync.RWMutex
func main() {
    ch := make(chan struct{}, 10)
    for i := 0; i < 5; i++ {
        go read(i, ch)
    }
    for i := 0; i < 5; i++ {
        go write(i, ch)
    }
    for i := 0; i < 10; i++ {
        <-ch
    }
}
func read(n int, ch chan struct{}) {
    rw.RLock()
    fmt.Printf("goroutine %d 进入读操作...\n", n)
    v := count
    fmt.Printf("goroutine %d 读取结束，值为：%d\n", n, v)
    rw.RUnlock()
    ch <- struct{}{}
}
func write(n int, ch chan struct{}) {
    rw.Lock()
    fmt.Printf("goroutine %d 进入写操作...\n", n)
    v := rand.Intn(1000)
    count = v
    fmt.Printf("goroutine %d 写入结束，新值为：%d\n", n, v)
    rw.Unlock()
    ch <- struct{}{}
}
```

其执行结果如下：

```go
goroutine 0 进入读操作...
goroutine 0 读取结束，值为：0
goroutine 3 进入读操作...
goroutine 1 进入读操作...
goroutine 3 读取结束，值为：0
goroutine 1 读取结束，值为：0
goroutine 4 进入写操作...
goroutine 4 写入结束，新值为：81
goroutine 4 进入读操作...
goroutine 4 读取结束，值为：81
goroutine 2 进入读操作...
goroutine 2 读取结束，值为：81
goroutine 0 进入写操作...
goroutine 0 写入结束，新值为：887
goroutine 1 进入写操作...
goroutine 1 写入结束，新值为：847
goroutine 2 进入写操作...
goroutine 2 写入结束，新值为：59
goroutine 3 进入写操作...
goroutine 3 写入结束，新值为：81
```



下面再来看两个示例。

【示例 1】多个读操作同时读取一个变量时，虽然加了锁，但是读操作是不受影响的。（读和写是互斥的，读和读不互斥）

```go
package main
import (
    "sync"
    "time"
)
var m *sync.RWMutex
func main() {
    m = new(sync.RWMutex)
    // 多个同时读
    go read(1)
    go read(2)
    time.Sleep(2*time.Second)
}
func read(i int) {
    println(i,"read start")
    m.RLock()
    println(i,"reading")
    time.Sleep(1*time.Second)
    m.RUnlock()
    println(i,"read over")
}
```

运行结果如下：

```go
1 read start
1 reading
2 read start
2 reading
1 read over
2 read over
```

【示例 2】由于读写互斥，所以写操作开始的时候，读操作必须要等写操作进行完才能继续，不然读操作只能继续等待。

```go
package main
import (
    "sync"
    "time"
)
var m *sync.RWMutex
func main() {
    m = new(sync.RWMutex)
    // 写的时候啥也不能干
    go write(1)
    go read(2)
    go write(3)
    time.Sleep(2*time.Second)
}
func read(i int) {
    println(i,"read start")
    m.RLock()
    println(i,"reading")
    time.Sleep(1*time.Second)
    m.RUnlock()
    println(i,"read over")
}
func write(i int) {
    println(i,"write start")
    m.Lock()
    println(i,"writing")
    time.Sleep(1*time.Second)
    m.Unlock()
    println(i,"write over")
}
```

运行结果如下：

```go
1 write start
3 write start
1 writing
2 read start
1 write over
2 reading
```

### 12. big包：对整数的高精度计算

实际开发中，对于超出 int64 或者 uint64 类型的大数进行计算时，如果对精度没有要求，使用 float32 或者 float64 就可以胜任，但如果对精度有严格要求的时候，我们就不能使用浮点数了，因为浮点数在内存中只能被近似的表示。

Go语言中 math/big 包实现了大数字的多精度计算，支持 Int（有符号整数）、Rat（有理数）和 Float（浮点数）等数字类型。

这些类型可以实现任意位数的数字，只要内存足够大，但缺点是需要更大的内存和处理开销，这使得它们使用起来要比内置的数字类型慢很多。

在 math/big 包中，Int 类型定义如下所示：

```go
// An Int represents a signed multi-precision integer.
// The zero value for an Int represents the value 0.
type Int struct {
    neg bool // sign
    abs nat  // absolute value of the integer
}
```

生成 Int 类型的方法为 NewInt()，如下所示：

```go
// NewInt allocates and returns a new Int set to x.
func NewInt(x int64) *Int {
    return new(Int).SetInt64(x)
}
```

注意：NewInt() 函数只对 int64 有效，其他类型必须先转成 int64 才行。

Go语言中还提供了许多 Set 函数，可以方便的把其他类型的整形存入 Int ，因此，我们可以先 new(int) 然后再调用 Set 函数，Set 函数有如下几种：

```go
// SetInt64 函数将 z 转换为 x 并返回 z。
func (z *Int) SetInt64(x int64) *Int {
    neg := false
    if x < 0 {
        neg = true
        x = -x
    }
    z.abs = z.abs.setUint64(uint64(x))
    z.neg = neg
    return z
}
​
// SetUint64 函数将 z 转换为 x 并返回 z。
func (z *Int) SetUint64(x uint64) *Int {
    z.abs = z.abs.setUint64(x)
    z.neg = false
    return z
}
​
// Set 函数将 z 转换为 x 并返回 z。
func (z *Int) Set(x *Int) *Int {
    if z != x {
        z.abs = z.abs.set(x.abs)
        z.neg = x.neg
    }
    return z
}
```

示例代码如下所示：

```go
package main
import (
    "fmt"
    "math/big"
)
func main() {
    big1 := new(big.Int).SetUint64(uint64(1000))
    fmt.Println("big1 is: ", big1)
    big2 := big1.Uint64()
    fmt.Println("big2 is: ", big2)
}
```

运行结果如下：

```go
big1 is: 1000
big2 is: 1000
```

除了上述的 Set 函数，math/big 包中还提供了一个 SetString() 函数，可以指定进制数，比如二进制、十进制或者十六进制等！

```go
// SetString sets z to the value of s, interpreted in the given base,
// and returns z and a boolean indicating success. The entire string
// (not just a prefix) must be valid for success. If SetString fails,
// the value of z is undefined but the returned value is nil.
//
// The base argument must be 0 or a value between 2 and MaxBase. If the base
// is 0, the string prefix determines the actual conversion base. A prefix of
// ``0x'' or ``0X'' selects base 16; the ``0'' prefix selects base 8, and a
// ``0b'' or ``0B'' prefix selects base 2. Otherwise the selected base is 10.
//
func (z *Int) SetString(s string, base int) (*Int, bool) {
    r := strings.NewReader(s)
    if _, _, err := z.scan(r, base); err != nil {
        return nil, false
    }
    // entire string must have been consumed
    if _, err := r.ReadByte(); err != io.EOF {
        return nil, false
    }
    return z, true // err == io.EOF => scan consumed all of s
}

```

示例代码如下所示：

```go
package main
import (
    "fmt"
    "math/big"
)
func main() {
    big1, _ := new(big.Int).SetString("1000", 10)
    fmt.Println("big1 is: ", big1)
    big2 := big1.Uint64()
    fmt.Println("big2 is: ", big2)
}
```

运行结果如下：

```go
big1 is: 1000
big2 is: 1000
```

因为Go语言不支持运算符重载，所以所有大数字类型都有像是 Add() 和 Mul() 这样的方法。

Add 方法的定义如下所示：

```go
func (z *) Add(x, y *Int) *Int
```

该方法会将 z 转换为 x + y 并返回 z。

【示例】计算第 1000 位的斐波那契数列。

```go
package main
import (
    "fmt"
    "math/big"
    "time"
)
const LIM = 1000 //求第1000位的斐波那契数列
var fibs [LIM]*big.Int //使用数组保存计算出来的数列的指针
func main() {
    result := big.NewInt(0)
    start := time.Now()
    for i := 0; i < LIM; i++ {
        result = fibonacci(i)
        fmt.Printf("数列第 %d 位: %d\n", i+1, result)
    }
    end := time.Now()
    delta := end.Sub(start)
    fmt.Printf("执行完成，所耗时间为: %s\n", delta)
}
func fibonacci(n int) (res *big.Int) {
    if n <= 1 {
        res = big.NewInt(1)
    } else {
        temp := new(big.Int)
        res = temp.Add(fibs[n-1], fibs[n-2])
    }
    fibs[n] = res
    return
}
```

运行结果如下：

```go
数列第 1 位: 1
数列第 2 位: 1
数列第 3 位: 2
数列第 4 位: 3
数列第 5 位: 5
...
数列第 997 位: 10261062362033262336604926729245222132668558120602124277764622905699407982546711488272859468887457959
08773311924256407785074365766118082732679853917775891982813511440749936979646564952426675539110499009
9120377
数列第 998 位: 16602747662452097049541800472897701834948051198384828062358553091918573717701170201065510185595898605
10409473691887927846223301598102952299783631123261876053919903676539979992673143323971886037334508837
5054249
数列第 999 位: 26863810024485359386146727202142923967616609318986952340123175997617981700247881689338369654483356564
19182785616144335631297667364221035032463485041037768036733415117289916972319708276398561576445007847
4174626
数列第 1000 位: 4346655768693745643568852767504062580256466051737178040248172908953655541794905189040387984007925516
92959225930803226347752096896232398733224711616429964409065331879382989696499285160037044761377951668
49228875
执行完成，所耗时间为: 6.945ms
```



### 13. 使用图像包制作gif动画

本节将通过示例来介绍一下 Go 语言标准库中图像包的使用，并使用这些图像包来创建一系列的位图图像，然后将位图序列编码为 GIF 动画。

下面的图像叫作利萨茹图形，它类似于 20 世纪 60 年代科幻片中出现的一种纤维状视觉效果，利萨茹图形是由在互相垂直的方向上的两个频率成简单整数比的简谐振动所合成的规则的、稳定的曲线。

[![img](http://c.biancheng.net/uploads/allimg/190806/4-1ZP6095311296.gif)](http://c.biancheng.net/uploads/allimg/190806/4-1ZP6095311296.gif)

图：四种利萨茹图形

上图中所示的图像看似复杂，利用 Go 语言标准库中的图像包可以很轻松的实现，代码如下所示：

```go
  package main

  import (
      "image"
      "image/color"
      "image/gif"
      "io"
      "math"
      "math/rand"
      "os"
      "time"
  )

  var palette = []color.Color{color.White, color.Black} //调色板
  const (
      whiteIndex = 0
      blackIndex = 1
  )

  func main() {
      rand.Seed(time.Now().UTC().UnixNano())
      lissajous(os.Stdout)
  }
  func lissajous(out io.Writer) {
      const (
          cycles  = 5     //完整的x振荡器变化的个数
          res     = 0.001 //角度分辨率
          size    = 100   //图像画布包含\[-size. .+size\]
          nframes = 64    //动画中的帧数
          delay   = 8     //以10ms为单位的帧间延迟
      )
      freq := rand.Float64() * 3.0 //y 振荡器的相对频率
      anim := gif.GIF{LoopCount: nframes}
      phase := 0.0
      for i := 0; i < nframes; i++ {
          rect := image.Rect(0, 0, 2*size+1, 2*size+1)
          img := image.NewPaletted(rect, palette)
          for t := 0.0; t < cycles*2*math.Pi; t += res {
              x := math.Sin(t)
              y := math.Sin(t*freq + phase)
              img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)
          }
          phase += 0.1
          anim.Delay = append(anim.Delay, delay)
          anim.Image = append(anim.Image, img)
      }
      gif.EncodeAll(out, &anim)
  }
```

其中，lissajous 函数内部包含两层嵌套的 for 循环，外层循环会循环 64 次，每一次都会生成一个单独的动画帧，即生成一个只有黑色和白色，且大小为 201*201 的图片。

而 lissajous 函数的内层循环则设置了两个偏振值 x 和 y，x 轴偏振使用 sin 函数，y 轴偏振也是正弦波，但其相对 x 轴的偏振是一个 0~3 的随机值。初始偏振值是一个零值，随着动画的每一帧逐渐增加，循环会一直跑到 x 轴完成五次完整的循环，每一步它都会调用 SetColorIndex 来把 (x, y) 点来染成黑色。

想要成功的生成 gif 图像需要我们先使用`go build `命令将代码编译为可执行文件，然后在 CMD（命令行工具）中运行所生成的可执行文件，如下所示：

go build main.go main.exe >1.gif

其中，`>`在这里用来指定生成图像的文件名，1.gif 为文件名。

执行成功后就可以在当前目录下找到生成的 gif 文件了，如下图所示：

[![img](http://c.biancheng.net/uploads/allimg/191210/4-1912101H22M08.gif)](http://c.biancheng.net/uploads/allimg/191210/4-1912101H22M08.gif)

图：利萨如图形

### 14. 正则表达式：regexp包

正则表达式是一种进行模式匹配和文本操纵的复杂而又强大的工具。虽然正则表达式比纯粹的文本匹配效率低，但是它却更灵活，按照它的语法规则，根据需求构造出的正则表达式能够从原始文本中筛选出几乎任何你想要得到的字符组合。

Go语言通过 regexp 包为正则表达式提供了官方支持，其采用 RE2 语法，除了`\c`、`\C`外，Go语言和 Perl、[Python](http://c.biancheng.net/python/) 等语言的正则基本一致。

#### 正则表达式语法规则

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）构成的文字序列，可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

下面的表格中列举了构成正则表达式的一些语法规则及其含义。

##### 1) 字符

| 语法     | 说明                                                         | 表达式示例 | 匹配结果          |
| -------- | ------------------------------------------------------------ | ---------- | ----------------- |
| 一般字符 | 匹配自身                                                     | abc        | abc               |
| .        | 匹配任意除换行符"\n"外的字符， 在 DOTALL 模式中也能匹配换行符 | a.c        | abc               |
| \        | 转义字符，使后一个字符改变原来的意思； 如果字符串中有字符 * 需要匹配，可以使用 \* 或者字符集［*]。 | a\.c a\\c  | a.c a\c           |
| [...]    | 字符集（字符类），对应的位置可以是字符集中任意字符。 字符集中的字符可以逐个列出，也可以给出范围，如 [abc] 或 [a-c]， 第一个字符如果是 ^ 则表示取反，如 [^abc] 表示除了abc之外的其他字符。 | a[bcd]e    | abe 或 ace 或 ade |
| \d       | 数字：[0-9]                                                  | a\dc       | a1c               |
| \D       | 非数字：[^\d]                                                | a\Dc       | abc               |
| \s       | 空白字符：[<空格>\t\r\n\f\v]                                 | a\sc       | a c               |
| \S       | 非空白字符：[^\s]                                            | a\Sc       | abc               |
| \w       | 单词字符：[A-Za-z0-9]                                        | a\wc       | abc               |
| \W       | 非单词字符：[^\w]                                            | a\Wc       | a c               |

##### 2) 数量词（用在字符或 (...) 之后）

| 语法  | 说明                                                         | 表达式示例 | 匹配结果     |
| ----- | ------------------------------------------------------------ | ---------- | ------------ |
| *     | 匹配前一个字符 0 或无限次                                    | abc*       | ab 或 abccc  |
| +     | 匹配前一个字符 1 次或无限次                                  | abc+       | abc 或 abccc |
| ?     | 匹配前一个字符 0 次或 1 次                                   | abc?       | ab 或 abc    |
| {m}   | 匹配前一个字符 m 次                                          | ab{2}c     | abbc         |
| {m,n} | 匹配前一个字符 m 至 n 次，m 和 n 可以省略，若省略 m，则匹配 0 至 n 次； 若省略 n，则匹配 m 至无限次 | ab{1,2}c   | abc 或 abbc  |

##### 3) 边界匹配

| 语法                                                       | 说明                                         | 表达式示例 | 匹配结果 |
| ---------------------------------------------------------- | -------------------------------------------- | ---------- | -------- |
| ^                                                          | 匹配字符串开头，在多行模式中匹配每一行的开头 | ^abc       | abc      |
| $    | 匹配字符串末尾，在多行模式中匹配每一行的末尾 | abc$ | abc                                          |            |          |
| \A                                                         | 仅匹配字符串开头                             | \Aabc      | abc      |
| \Z                                                         | 仅匹配字符串末尾                             | abc\Z      | abc      |
| \b                                                         | 匹配 \w 和 \W 之间                           | a\b!bc     | a!bc     |
| \B                                                         | [^\b]                                        | a\Bbc      | abc      |

##### 4) 逻辑、分组

| 语法          | 说明                                                         | 表达式示例           | 匹配结果       |
| ------------- | ------------------------------------------------------------ | -------------------- | -------------- |
| \|            | \| 代表左右表达式任意匹配一个，优先匹配左边的表达式          | abc\|def             | abc 或 def     |
| (...)         | 括起来的表达式将作为分组，分组将作为一个整体，可以后接数量词 | (abc){2}             | abcabc         |
| (?P<name>...) | 分组，功能与 (...) 相同，但会指定一个额外的别名              | (?P<id>abc){2}       | abcabc         |
| \<number>     | 引用编号为 <number> 的分组匹配到的字符串                     | (\d)abc\1            | 1abe1 或 5abc5 |
| (?P=name)     | 引用别名为 <name> 的分组匹配到的字符串                       | (?P<id>\d)abc(?P=id) | 1abe1 或 5abc5 |

##### 5) 特殊构造（不作为分组）

| 语法      | 说明                                                         | 表达式示例        | 匹配结果         |
| --------- | ------------------------------------------------------------ | ----------------- | ---------------- |
| (?:...)   | (…) 的不分组版本，用于使用 "\|" 或后接数量词                 | (?:abc){2}        | abcabc           |
| (?iLmsux) | iLmsux 中的每个字符代表一种匹配模式，只能用在正则表达式的开头，可选多个 | (?i)abc           | AbC              |
| (?#...)   | # 后的内容将作为注释被忽略。                                 | abc(?#comment)123 | abc123           |
| (?=...)   | 之后的字符串内容需要匹配表达式才能成功匹配                   | a(?=\d)           | 后面是数字的 a   |
| (?!...)   | 之后的字符串内容需要不匹配表达式才能成功匹配                 | a(?!\d)           | 后面不是数字的 a |
| (?<=...)  | 之前的字符串内容需要匹配表达式才能成功匹配                   | (?<=\d)a          | 前面是数字的a    |
| (?<!...)  | 之前的字符串内容需要不匹配表达式才能成功匹配                 | (?<!\d)a          | 前面不是数字的a  |

#### Regexp 包的使用

下面通过几个示例来演示一下 regexp 包的使用。

【示例 1】匹配指定类型的字符串。

```go
package main
import (
    "fmt"
    "regexp"
)
func main() {
    buf := "abc azc a7c aac 888 a9c  tac"
    //解析正则表达式，如果成功返回解释器
    reg1 := regexp.MustCompile(`a.c`)
    if reg1 == nil {
        fmt.Println("regexp err")
        return
    }
    //根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
}
```

运行结果如下：

```go
result1 = [[abc] [azc] [a7c] [aac] [a9c]]　
```

【示例 2】匹配 a 和 c 中间包含一个数字的字符串。

```go
package main
import (
    "fmt"
    "regexp"
)
func main() {
    buf := "abc azc a7c aac 888 a9c  tac"
    //解析正则表达式，如果成功返回解释器
    reg1 := regexp.MustCompile(`a[0-9]c`)
    if reg1 == nil { //解释失败，返回nil
        fmt.Println("regexp err")
        return
    }
    //根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
}
```

运行结果如下：

```go
result1 = [[a7c] [a9c]]
```

【示例 3】使用 \d 来匹配 a 和 c 中间包含一个数字的字符串。

```go
package main
import (
    "fmt"
    "regexp"
)
func main() {
    buf := "abc azc a7c aac 888 a9c  tac"
    //解析正则表达式，如果成功返回解释器
    reg1 := regexp.MustCompile(`a\dc`)
    if reg1 == nil { //解释失败，返回nil
        fmt.Println("regexp err")
        return
    }
    //根据规则提取关键信息
    result1 := reg1.FindAllStringSubmatch(buf, -1)
    fmt.Println("result1 = ", result1)
}
```

运行结果如下：

```go
result1 = [[a7c] [a9c]]
```

【示例 4】匹配字符串中的小数。

```go
package main
import (
    "fmt"
    "regexp"
)
func main() {
    buf := "43.14 567 agsdg 1.23 7. 8.9 1sdljgl 6.66 7.8   "
    //解释正则表达式
    reg := regexp.MustCompile(`\d+\.\d+`)
    if reg == nil {
        fmt.Println("MustCompile err")
        return
    }
    //提取关键信息
    //result := reg.FindAllString(buf, -1)
    result := reg.FindAllStringSubmatch(buf, -1)
    fmt.Println("result = ", result)
}
```

运行结果如下：

```go
result = [[43.14] [1.23] [8.9] [6.66] [7.8]]
```

【示例 5】匹配 div 标签中的内容。

```go
package main
import (
    "fmt"
    "regexp"
)
func main() {
    // 原生字符串
    buf := `
    
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>C语言中文网 | Go语言入门教程</title>
</head>
<body>
    <div>Go语言简介</div>
    <div>Go语言基本语法
    Go语言变量的声明
    Go语言教程简明版
    </div>
    <div>Go语言容器</div>
    <div>Go语言函数</div>
</body>
</html>
    `
    //解释正则表达式
    reg := regexp.MustCompile(`<div>(?s:(.*?))</div>`)
    if reg == nil {
        fmt.Println("MustCompile err")
        return
    }
    //提取关键信息
    result := reg.FindAllStringSubmatch(buf, -1)
    //过滤<></>
    for _, text := range result {
        fmt.Println("text[1] = ", text[1])
    }
}
```

运行结果如下：

```go
text[1] = Go语言简介
text[1] = Go语言基本语法
  Go语言变量的声明
  Go语言教程简明版
  
text[1] = Go语言容器
text[1] = Go语言函数
```

【示例 6】通过 Compile 方法返回一个 Regexp 对象，实现匹配，查找，替换相关的功能。

```go
package main
import (
    "fmt"
    "regexp"
    "strconv"
)
func main() {
    //目标字符串
    searchIn := "John: 2578.34 William: 4567.23 Steve: 5632.18"
    pat := "[0-9]+.[0-9]+"          //正则
    f := func(s string) string{
        v, _ := strconv.ParseFloat(s, 32)
        return strconv.FormatFloat(v * 2, 'f', 2, 32)
    }
    if ok, _ := regexp.Match(pat, []byte(searchIn)); ok {
        fmt.Println("Match Found!")
    }
    re, _ := regexp.Compile(pat)
    //将匹配到的部分替换为 "##.#"
    str := re.ReplaceAllString(searchIn, "##.#")
    fmt.Println(str)
    //参数为函数时
    str2 := re.ReplaceAllStringFunc(searchIn, f)
    fmt.Println(str2)
}
```

输出结果：

```go
Match Found!
John: ##.# William: ##.# Steve: ##.#
John: 5156.68 William: 9134.46 Steve: 11264.36
```

上面代码中 Compile 方法可以解析并返回一个正则表达式，如果成功返回，则说明该正则表达式正确可用于匹配文本。

另外我们也可以使用 MustCompile 方法，它也可以像 Compile 方法一样检验正则的有效性，但是当正则不合法时程序将 panic。

### 15. time包：时间和日期

时间和日期是我们开发中经常会用到的，Go语言中的 time 包提供了时间显示和测量等所用的函数，本节我们就来介绍一下 time 包的基本用法。

#### time 包简介

时间一般包含时间值和时区，可以从Go语言中 time 包的源码中看出：

```go
type Time struct {
    // wall and ext encode the wall time seconds, wall time nanoseconds,
    // and optional monotonic clock reading in nanoseconds.
    //
    // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),
    // a 33-bit seconds field, and a 30-bit wall time nanoseconds field.
    // The nanoseconds field is in the range [0, 999999999].
    // If the hasMonotonic bit is 0, then the 33-bit field must be zero
    // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.
    // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit
    // unsigned wall seconds since Jan 1 year 1885, and ext holds a
    // signed 64-bit monotonic clock reading, nanoseconds since process start.
    wall uint64
    ext  int64
    // loc specifies the Location that should be used to
    // determine the minute, hour, month, day, and year
    // that correspond to this Time.
    // The nil location means UTC.
    // All UTC times are represented with loc==nil, never loc==&utcLoc.
    loc *Location
}
```

上面代码中：

- wall：表示距离公元 1 年 1 月 1 日 00:00:00UTC 的秒数；
- ext：表示纳秒；
- loc：代表时区，主要处理偏移量，不同的时区，对应的时间不一样。

#### 如何正确表示时间呢？

公认最准确的计算应该是使用“原子震荡周期”所计算的物理时钟了（Atomic Clock, 也被称为原子钟），这也被定义为标准时间（International Atomic Time）。

而我们常常看见的 UTC（Universal Time Coordinated，世界协调时间）就是利用这种 Atomic Clock 为基准所定义出来的正确时间。UTC 标准时间是以 GMT（Greenwich Mean Time，格林尼治时间）这个时区为主，所以本地时间与 UTC 时间的时差就是本地时间与 GMT 时间的时差。

UTC + 时区差 ＝ 本地时间

国内一般使用的是北京时间，与 UTC 的时间关系如下：

UTC + 8 个小时 = 北京时间

在Go语言的 time 包里面有两个时区变量，如下：

- time.UTC：UTC 时间
- time.Local：本地时间


同时，Go语言还提供了 LoadLocation 方法和 FixedZone 方法来获取时区变量，如下：

```go
FixedZone(name string, offset int) *Location
```

其中，name 为时区名称，offset 是与 UTC 之前的时差。

```go
LoadLocation(name string) (*Location, error)
```

其中，name 为时区的名字。

#### 时间的获取

##### 1) 获取当前时间

我们可以通过 time.Now() 函数来获取当前的时间对象，然后通过事件对象来获取当前的时间信息。示例代码如下：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    now := time.Now() //获取当前时间
    fmt.Printf("current time:%v\n", now)
    year := now.Year()     //年
    month := now.Month()   //月
    day := now.Day()       //日
    hour := now.Hour()     //小时
    minute := now.Minute() //分钟
    second := now.Second() //秒
    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
}
```

运行结果如下：

```go
current time:2019-12-12 12:33:19.4712277 +0800 CST m=+0.006980401
2019-12-12 12:33:19
```

##### 2) 获取时间戳

时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的总毫秒数，它也被称为 Unix 时间戳（UnixTimestamp）。

基于时间对象获取时间戳的示例代码如下：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    now := time.Now()            //获取当前时间
    timestamp1 := now.Unix()     //时间戳
    timestamp2 := now.UnixNano() //纳秒时间戳
    fmt.Printf("现在的时间戳：%v\n", timestamp1)
    fmt.Printf("现在的纳秒时间戳：%v\n", timestamp2)
}
```

运行结果如下：

```go
现在的时间戳：1576127858
现在的纳秒时间戳：1576127858829900100
```

使用 time.Unix() 函数可以将时间戳转为时间格式，示例代码如下

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    now := time.Now()                  //获取当前时间
    timestamp := now.Unix()            //时间戳
    timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式
    fmt.Println(timeObj)
    year := timeObj.Year()     //年
    month := timeObj.Month()   //月
    day := timeObj.Day()       //日
    hour := timeObj.Hour()     //小时
    minute := timeObj.Minute() //分钟
    second := timeObj.Second() //秒
    fmt.Printf("%d-%02d-%02d %02d:%02d:%02d\n", year, month, day, hour, minute, second)
}
```

运行结果如下：

```go
2019-12-12 13:24:09 +0800 CST
2019-12-12 13:24:09
```

##### 3) 获取当前是星期几

time 包中的 Weekday 函数能够返回某个时间点所对应是一周中的周几，示例代码如下：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    //时间戳
    t := time.Now()
    fmt.Println(t.Weekday().String())
}
```

运行结果如下：

```go
Thursday
```

#### 时间操作函数

##### 1) Add

我们在日常的开发过程中可能会遇到要求某个时间 + 时间间隔之类的需求，Go语言中的 Add 方法如下：

```go
func (t Time) Add(d Duration) Time
```

Add 函数可以返回时间点 t + 时间间隔 d 的值。

【示例】求一个小时之后的时间：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    now := time.Now()
    later := now.Add(time.Hour) // 当前时间加1小时后的时间
    fmt.Println(later)
}
```

运行结果如下：

```go
2019-12-12 16:00:29.9866943 +0800 CST m=+3600.007978201
```

##### 2) Sub

求两个时间之间的差值：

```go
func (t Time) Sub(u Time) Duration
```

返回一个时间段 t - u 的值。如果结果超出了 Duration 可以表示的最大值或最小值，将返回最大值或最小值，要获取时间点 t - d（d 为 Duration），可以使用 t.Add(-d)。

##### 3) Equal

判断两个时间是否相同：

```go
func (t Time) Equal(u Time) bool
```

Equal 函数会考虑时区的影响，因此不同时区标准的时间也可以正确比较，Equal 方法和用 t==u 不同，Equal 方法还会比较地点和时区信息。

#### 4) Before

判断一个时间点是否在另一个时间点之前：

```go
func (t Time) Before(u Time) bool
```

如果 t 代表的时间点在 u 之前，则返回真，否则返回假。

##### 5) After

判断一个时间点是否在另一个时间点之后：

```go
func (t Time) After(u Time) bool
```

如果 t 代表的时间点在 u 之后，则返回真，否则返回假。

#### 定时器

使用 time.Tick(时间间隔) 可以设置定时器，定时器的本质上是一个通道（channel），示例代码如下：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器
    for i := range ticker {
        fmt.Println(i) //每秒都会执行的任务
    }
}
```

运行结果如下：

```go
2019-12-12 15:14:26.4158067 +0800 CST m=+16.007460701
2019-12-12 15:14:27.4159467 +0800 CST m=+17.007600701
2019-12-12 15:14:28.4144689 +0800 CST m=+18.006122901
2019-12-12 15:14:29.4159581 +0800 CST m=+19.007612101
2019-12-12 15:14:30.4144337 +0800 CST m=+20.006087701
...
```

#### 时间格式化

时间类型有一个自带的 Format 方法进行格式化，需要注意的是Go语言中格式化时间模板不是常见的`Y-m-d H:M:S `而是使用Go语言的诞生时间 2006 年 1 月 2 号 15 点 04 分 05 秒。

提示：如果想将时间格式化为 12 小时格式，需指定 PM。

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    now := time.Now()
    // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan
    // 24小时制
    fmt.Println(now.Format("2006-01-02 15:04:05.000 Mon Jan"))
    // 12小时制
    fmt.Println(now.Format("2006-01-02 03:04:05.000 PM Mon Jan"))
    fmt.Println(now.Format("2006/01/02 15:04"))
    fmt.Println(now.Format("15:04 2006/01/02"))
    fmt.Println(now.Format("2006/01/02"))
}
```

运行结果如下：

```go
2019-12-12 15:20:52.037 Thu Dec
2019-12-12 03:20:52.037 PM Thu Dec
2019/12/12 15:20
15:20 2019/12/12
2019/12/12
```

#### 解析字符串格式的时间

Parse 函数可以解析一个格式化的时间字符串并返回它代表的时间。

```go
func Parse(layout, value string) (Time, error)
```

与 Parse 函数类似的还有 ParseInLocation 函数。

```go
func ParseInLocation(layout, value string, loc *Location) (Time, error)
```

ParseInLocation与 Parse 函数类似，但有两个重要的不同之处：

- 第一，当缺少时区信息时，Parse 将时间解释为 UTC 时间，而 ParseInLocation 将返回值的 Location 设置为 loc；
- 第二，当时间字符串提供了时区偏移量信息时，Parse 会尝试去匹配本地时区，而 ParseInLocation 会去匹配 loc。


示例代码如下：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    var layout string = "2006-01-02 15:04:05"
    var timeStr string = "2019-12-12 15:22:12"
    timeObj1, _ := time.Parse(layout, timeStr)
    fmt.Println(timeObj1)
    timeObj2, _ := time.ParseInLocation(layout, timeStr, time.Local)
    fmt.Println(timeObj2)
}
```

运行结果如下：

```go
2019-12-12 15:22:12 +0000 UTC
2019-12-12 15:22:12 +0800 CST
```

### 16. os包用法简述

Go语言的 os 包中提供了操作系统函数的接口，是一个比较重要的包。顾名思义，os 包的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。

#### os 包中的常用函数

##### 1) Hostname

函数定义:

```go
func Hostname() (name string, err error)
```

Hostname 函数会返回内核提供的主机名。

##### 2) Environ

函数定义:

```go
func Environ() []string
```

Environ 函数会返回所有的环境变量，返回值格式为“key=value”的字符串的切片拷贝。

##### 3) Getenv

函数定义:

```go
func Getenv(key string) string
```

Getenv 函数会检索并返回名为 key 的环境变量的值。如果不存在该环境变量则会返回空字符串。

##### 4) Setenv

函数定义:

```go
func Setenv(key, value string) error
```

Setenv 函数可以设置名为 key 的环境变量，如果出错会返回该错误。

##### 5) Exit

函数定义:

```go
func Exit(code int)
```

Exit 函数可以让当前程序以给出的状态码 code 退出。一般来说，状态码 0 表示成功，非 0 表示出错。程序会立刻终止，并且 defer 的函数不会被执行。

##### 6) Getuid

函数定义:

```go
func Getuid() int
```

Getuid 函数可以返回调用者的用户 ID。

##### 7) Getgid

函数定义:

```go
func Getgid() int
```

Getgid 函数可以返回调用者的组 ID。

##### 8) Getpid

函数定义:

```go
func Getpid() int
```

Getpid 函数可以返回调用者所在进程的进程 ID。

##### 9) Getwd

函数定义:

```go
func Getwd() (dir string, err error)
```

Getwd 函数可以返回一个对应当前工作目录的根路径。如果当前目录可以经过多条路径抵达（因为硬链接），Getwd 会返回其中一个。

##### 10) Mkdir

函数定义:

```go
func Mkdir(name string, perm FileMode) error
```

Mkdir 函数可以使用指定的权限和名称创建一个目录。如果出错，会返回 *PathError 底层类型的错误。

##### 11) MkdirAll

函数定义:

```go
func MkdirAll(path string, perm FileMode) error
```

MkdirAll 函数可以使用指定的权限和名称创建一个目录，包括任何必要的上级目录，并返回 nil，否则返回错误。权限位 perm 会应用在每一个被该函数创建的目录上。如果 path 指定了一个已经存在的目录，MkdirAll 不做任何操作并返回 nil。

##### 12) Remove

函数定义:

```go
func Remove(name string) error
```

Remove 函数会删除 name 指定的文件或目录。如果出错，会返回 *PathError 底层类型的错误。

Removell 函数跟 Remove 用法一样，区别是会递归的删除所有子目录和文件。

在 os 包下，有 exec，signal，user 三个子包，下面来分别介绍一下。

#### os/exec 执行外部命令

exec 包可以执行外部命令，它包装了 os.StartProcess 函数以便更容易的修正输入和输出，使用管道连接 I/O，以及作其它的一些调整。

```go
func LookPath(file string) (string, error)
```

在环境变量 PATH 指定的目录中搜索可执行文件，如果 file 中有斜杠，则只在当前目录搜索。返回完整路径或者相对于当前目录的一个相对路径。

示例代码如下：

```go
package main
import (
    "fmt"
    "os/exec"
)
func main() {
    f, err := exec.LookPath("main")
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(f)
}
```

运行结果如下：

```go
main.exe
```

#### os/user 获取当前用户信息

可以通过 os/user 包中的 Current() 函数来获取当前用户信息，该函数会返回一个 User 结构体，结构体中的 Username、Uid、HomeDir、Gid 分别表示当前用户的名称、用户 id、用户主目录和用户所属组 id，函数原型如下：

```go
func Current() (*User, error)
```

示例代码如下：

```go
package main
import (
    "log"
    "os/user"
)
func main() {
    u, _ := user.Current()
    log.Println("用户名：", u.Username)
    log.Println("用户id", u.Uid)
    log.Println("用户主目录：", u.HomeDir)
    log.Println("主组id：", u.Gid)
    // 用户所在的所有的组的id
    s, _ := u.GroupIds()
    log.Println("用户所在的所有组：", s)
}
```

运行结果如下：

```go
2019/12/13 15:12:14 用户名： LENOVO-PC\Administrator
2019/12/13 15:12:14 用户id S-1-5-21-711400000-2334436127-1750000211-000
2019/12/13 15:12:14 用户主目录： C:\Users\Administrator
2019/12/13 15:12:14 主组id： S-1-5-22-766000000-2300000100-1050000262-000
2019/12/13 15:12:14 用户所在的所有组： [S-1-5-32-544 S-1-5-22-000 S-1-5-21-777400999-2344436111-1750000262-003]
```

#### os/signal 信号处理

一个运行良好的程序在退出（正常退出或者强制退出，如 Ctrl+C，kill 等）时是可以执行一段清理代码的，将收尾工作做完后再真正退出。一般采用系统 Signal 来通知系统退出，如 kill pid，在程序中针对一些系统信号设置了处理函数，当收到信号后，会执行相关清理程序或通知各个子进程做自清理。

Go语言中对信号的处理主要使用 os/signal 包中的两个方法，一个是 Notify 方法用来监听收到的信号，一个是 stop 方法用来取消监听。

```go
func Notify(c chan<- os.Signal, sig ...os.Signal)
```

其中，第一个参数表示接收信号的 channel，第二个及后面的参数表示设置要监听的信号，如果不设置表示监听所有的信号。

【示例 1】使用 Notify 方法来监听收到的信号：

```go
package main
import (
    "fmt"
    "os"
    "os/signal"
)
func main() {
    c := make(chan os.Signal, 0)
    signal.Notify(c)
    // Block until a signal is received.
    s := <-c
    fmt.Println("Got signal:", s)
}
```

运行该程序，然后在 CMD 窗口中通过 Ctrl+C 来结束该程序，便会得到输出结果：

```go
Got signal: interrupt
```

【示例 2】使用 stop 方法来取消监听：

```go
package main
import (
    "fmt"
    "os"
    "os/signal"
)
func main() {
    c := make(chan os.Signal, 0)
    signal.Notify(c)
    signal.Stop(c) //不允许继续往c中存入内容
    s := <-c       //c无内容，此处阻塞，所以不会执行下面的语句，也就没有输出
    fmt.Println("Got signal:", s)
}
```

因为使用 Stop 方法取消了 Notify 方法的监听，所以运行程序没有输出结果。

### 17. flag包：命令行参数解析

在编写命令行程序（工具、server）时，我们有时需要对命令参数进行解析，各种编程语言一般都会提供解析命令行参数的方法或库，以方便程序员使用。在Go语言中的 flag 包中，提供了命令行参数解析的功能。

下面我们就来看一下 flag 包可以做什么，它具有什么样的能力。

这里介绍几个概念：

- 命令行参数（或参数）：是指运行程序时提供的参数；
- 已定义命令行参数：是指程序中通过 flag.Type 这种形式定义了的参数；
- 非 flag（non-flag）命令行参数（或保留的命令行参数）：可以简单理解为 flag 包不能解析的参数。

#### flag 包概述

Go语言内置的 flag 包实现了命令行参数的解析，flag 包使得开发命令行工具更为简单。若要使用 flag 包，首先需要使用 import 关键字导入 flag 包，如下所示：

```go
import "flag"
```

#### flag 参数类型

flag 包支持的命令行参数类型有 bool、int、int64、uint、uint64、float、float64、string、duration，如下表所示：

| flag 参数      | 有效值                                                       |
| -------------- | ------------------------------------------------------------ |
| 字符串 flag    | 合法字符串                                                   |
| 整数 flag      | 1234、0664、0x1234 等类型，也可以是负数                      |
| 浮点数 flag    | 合法浮点数                                                   |
| bool 类型 flag | 1、0、t、f、T、F、true、false、TRUE、FALSE、True、False      |
| 时间段 flag    | 任何合法的时间段字符串，如“300ms”、“-1.5h”、“2h45m”， 合法的单位有“ns”、“us”、“µs”、“ms”、“s”、“m”、“h” |

#### flag 包基本使用

有以下两种常用的定义命令行 flag 参数的方法：

##### 1) flag.Type()

基本格式如下：

```go
flag.Type(flag 名, 默认值, 帮助信息) *Type
```

Type 可以是 Int、String、Bool 等，返回值为一个相应类型的指针，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：

```go
name := flag.String("name", "张三", "姓名")
age := flag.Int("age", 18, "年龄")
married := flag.Bool("married", false, "婚否")
delay := flag.Duration("d", 0, "时间间隔")
```

需要注意的是，此时 name、age、married、delay 均为对应类型的指针。

##### 2) flag.TypeVar()

基本格式如下：

```go
flag.TypeVar(Type 指针, flag 名, 默认值, 帮助信息)
```

TypeVar 可以是 IntVar、StringVar、BoolVar 等，其功能为将 flag 绑定到一个变量上，例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：

```go
var name string
var age int
var married bool
var delay time.Duration
flag.StringVar(&name, "name", "张三", "姓名")
flag.IntVar(&age, "age", 18, "年龄")
flag.BoolVar(&married, "married", false, "婚否")
flag.DurationVar(&delay, "d", 0, "时间间隔")
```

##### flag.Parse()

通过以上两种方法定义好命令行 flag 参数后，需要通过调用 flag.Parse() 来对命令行参数进行解析。

支持的命令行参数格式有以下几种：

- -flag：只支持 bool 类型；
- -flag=x；
- -flag x：只支持非 bool 类型。


其中，布尔类型的参数必须使用等号的方式指定。

flag 包的其他函数：

```go
flag.Args() //返回命令行参数后的其他参数，以 []string 类型
flag.NArg() //返回命令行参数后的其他参数个数
flag.NFlag() //返回使用的命令行参 数个数
```

结合上面的介绍知识，我们来看一个实例，代码如下：

```go
package main
import (
    "flag"
    "fmt"
)
var Input_pstrName = flag.String("name", "gerry", "input ur name")
var Input_piAge = flag.Int("age", 20, "input ur age")
var Input_flagvar int
func Init() {
    flag.IntVar(&Input_flagvar, "flagname", 1234, "help message for flagname")
}
func main() {
    Init()
    flag.Parse()
    // After parsing, the arguments after the flag are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1
    // Args returns the non-flag command-line arguments
    // NArg is the number of arguments remaining after flags have been processed
    fmt.Printf("args=%s, num=%d\n", flag.Args(), flag.NArg())
    for i := 0; i != flag.NArg(); i++ {
        fmt.Printf("arg[%d]=%s\n", i, flag.Arg(i))
    }
    fmt.Println("name=", *Input_pstrName)
    fmt.Println("age=", *Input_piAge)
    fmt.Println("flagname=", Input_flagvar)
}
```

运行结果如下：

```go
go run main.go -name "aaa" -age=123 -flagname=999
args=[], num=0
name= aaa
age= 123
flagname= 999
```

##### 自定义 Value

另外，我们还可以创建自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针类型），这时候可以通过如下方式定义该 flag：

```go
flag.Var(&flagVal, "name", "help message for flagname")
```

【示例】解析喜欢的编程语言，并直接解析到 slice 中，我们可以定义如下 sliceValue 类型，然后实现 Value 接口：

```go
package main
import (
    "flag"
    "fmt"
    "strings"
)
//定义一个类型，用于增加该类型方法
type sliceValue []string
//new一个存放命令行参数值的slice
func newSliceValue(vals []string, p *[]string) *sliceValue {
    *p = vals
    return (*sliceValue)(p)
}
/*
Value接口：
type Value interface {
    String() string
    Set(string) error
}
实现flag包中的Value接口，将命令行接收到的值用,分隔存到slice里
*/
func (s *sliceValue) Set(val string) error {
    *s = sliceValue(strings.Split(val, ","))
    return nil
}
//flag为slice的默认值default is me,和return返回值没有关系
func (s *sliceValue) String() string {
    *s = sliceValue(strings.Split("default is me", ","))
    return "It's none of my business"
}
/*
可执行文件名 -slice="java,go"  最后将输出[java,go]
可执行文件名 最后将输出[default is me]
*/
func main(){
    var languages []string
    flag.Var(newSliceValue([]string{}, &languages), "slice", "I like programming `languages`")
    flag.Parse()
    //打印结果slice接收到的值
    fmt.Println(languages)
}
```

通过`-slice go,php `这样的形式传递参数，languages 得到的就是 [go, php]，如果不加`-slice `参数则打印默认值`[default is me]`，如下所示：

```go
go run main.go -slice go,php,java
[go php java]
```

flag 中对 Duration 这种非基本类型的支持，使用的就是类似这样的方式，即同样实现了 Value 接口。

### 18. go mod包依赖管理工具使用详解

最早的时候，Go语言所依赖的所有的第三方库都放在 GOPATH 这个目录下面，这就导致了同一个库只能保存一个版本的代码。如果不同的项目依赖同一个第三方的库的不同版本，应该怎么解决？

go module 是Go语言从 1.11 版本之后官方推出的版本管理工具，并且从 Go1.13 版本开始，go module 成为了Go语言默认的依赖管理工具。

Modules 官方定义为：

Modules 是相关 Go 包的集合，是源代码交换和版本控制的单元。Go语言命令直接支持使用 Modules，包括记录和解析对其他模块的依赖性，Modules 替换旧的基于 GOPATH 的方法，来指定使用哪些源文件。

#### 如何使用 Modules？

1) 首先需要把 golang 升级到 1.11 版本以上（现在 1.13 已经发布了，建议使用 1.13）。

2) 设置 GO111MODULE。

##### GO111MODULE

在Go语言 1.12 版本之前，要启用 go module 工具首先要设置环境变量 GO111MODULE，不过在Go语言 1.13 及以后的版本则不再需要设置环境变量。通过 GO111MODULE 可以开启或关闭 go module 工具。

- GO111MODULE=off 禁用 go module，编译时会从 GOPATH 和 vendor 文件夹中查找包；
- GO111MODULE=on 启用 go module，编译时会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod下载依赖；
- GO111MODULE=auto（默认值），当项目在 GOPATH/src 目录之外，并且项目根目录有 go.mod 文件时，开启 go module。


Windows 下开启 GO111MODULE 的命令为：

```go
set GO111MODULE=on 或者 set GO111MODULE=auto
```

MacOS 或者 Linux 下开启 GO111MODULE 的命令为：

```go
export GO111MODULE=on 或者 export GO111MODULE=auto
```

在开启 GO111MODULE 之后就可以使用 go module 工具了，也就是说在以后的开发中就没有必要在 GOPATH 中创建项目了，并且还能够很好的管理项目依赖的第三方包信息。

常用的`go mod`命令如下表所示：

| 命令            | 作用                                           |
| --------------- | ---------------------------------------------- |
| go mod download | 下载依赖包到本地（默认为 GOPATH/pkg/mod 目录） |
| go mod edit     | 编辑 go.mod 文件                               |
| go mod graph    | 打印模块依赖图                                 |
| go mod init     | 初始化当前文件夹，创建 go.mod 文件             |
| go mod tidy     | 增加缺少的包，删除无用的包                     |
| go mod vendor   | 将依赖复制到 vendor 目录下                     |
| go mod verify   | 校验依赖                                       |
| go mod why      | 解释为什么需要依赖                             |

##### GOPROXY

proxy 顾名思义就是代理服务器的意思。大家都知道，国内的网络有防火墙的存在，这导致有些Go语言的第三方包我们无法直接通过`go get`命令获取。GOPROXY 是Go语言官方提供的一种通过中间代理商来为用户提供包下载服务的方式。要使用 GOPROXY 只需要设置环境变量 GOPROXY 即可。

目前公开的代理服务器的地址有：

- goproxy.io；
- goproxy.cn：（推荐）由国内的七牛云提供。


Windows 下设置 GOPROXY 的命令为：

```go
go env -w GOPROXY=https://goproxy.cn,direct
```

MacOS 或 Linux 下设置 GOPROXY 的命令为：

```go
export GOPROXY=https://goproxy.cn
```

Go语言在 1.13 版本之后 GOPROXY 默认值为 https://proxy.golang.org，在国内可能会存在下载慢或者无法访问的情况，所以十分建议大家将 GOPROXY 设置为国内的 goproxy.cn。

##### 使用go get命令下载指定版本的依赖包

执行`go get `命令，在下载依赖包的同时还可以指定依赖包的版本。

- 运行`go get -u`命令会将项目中的包升级到最新的次要版本或者修订版本；
- 运行`go get -u=patch`命令会将项目中的包升级到最新的修订版本；
- 运行`go get [包名]@[版本号]`命令会下载对应包的指定版本或者将对应包升级到指定的版本。

提示：`go get [包名]@[版本号]`命令中版本号可以是 x.y.z 的形式，例如 go get foo@v1.2.3，也可以是 git 上的分支或 tag，例如 go get foo@master，还可以是 git 提交时的哈希值，例如 go get foo@e3702bed2。

##### 如何在项目中使用

【示例 1】创建一个新项目：

1. 在 GOPATH 目录之外新建一个目录，并使用`go mod init`初始化生成 go.mod文件。

   ```go
   go mod init hello
   go: creating new go.mod: module hello
   ```

go.mod 文件一旦创建后，它的内容将会被 go toolchain 全面掌控，go toolchain 会在各类命令执行时，比如`go get`、`go build`、`go mod`等修改和维护 go.mod 文件。

go.mod 提供了 module、require、replace 和 exclude 四个命令：

- module 语句指定包的名字（路径）；
- require 语句指定的依赖项模块；
- replace 语句可以替换依赖项模块；
- exclude 语句可以忽略依赖项模块。


初始化生成的 go.mod 文件如下所示：

```go
module hello
go 1.13
```

2) 添加依赖。

新建一个 main.go 文件，写入以下代码：

```go
package main
import (
    "net/http"
    "github.com/labstack/echo"
)
func main() {
    e := echo.New()
    e.GET("/", func(c echo.Context) error {
        return c.String(http.StatusOK, "Hello, World!")
    })
    e.Logger.Fatal(e.Start(":1323"))
}
```

执行`go run main.go`运行代码会发现 go mod 会自动查找依赖自动下载：

```go
go run main.go
go: finding github.com/labstack/echo v3.3.10+incompatible
go: downloading github.com/labstack/echo v3.3.10+incompatible
go: extracting github.com/labstack/echo v3.3.10+incompatible
go: finding github.com/labstack/gommon v0.3.0
......
go: finding golang.org/x/text v0.3.0

  ____  __
 / __/___/ / ___
/ _// __/ _ \/ _ \
/___/\__/_//_/\___/ v3.3.10-dev
High performance, minimalist Go web framework
https://echo.labstack.com
____________________________________O/_______
                           O\
⇨ http server started on [::]:1323
```

现在查看 go.mod 内容：

```go
module hello

go 1.13

require (
  github.com/labstack/echo v3.3.10+incompatible // indirect
  github.com/labstack/gommon v0.3.0 // indirect
  golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413 // indirect
)
```

go module 安装 package 的原则是先拉取最新的 release tag，若无 tag 则拉取最新的 commit，详见[ Modules 官方](https://github.com/golang/go/wiki/Modules)介绍。

go 会自动生成一个 go.sum 文件来记录 dependency tree：

```go
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=
github.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=
github.com/labstack/gommon v0.3.0 h1:JEeO0bvc78PKdyHxloTKiF8BD5iGrH8T6MSeGvSgob0=
github.com/labstack/gommon v0.3.0/go.mod h1:MULnywXg0yavhxWKc+lOruYdAhDwPK9wf0OL7NoOu+k=
github.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=
... 省略很多行
```

再次执行脚本`go run main.go`发现跳过了检查并安装依赖的步骤。

可以使用命令`go list -m -u all`来检查可以升级的 package，使用`go get -u need-upgrade-package`升级后会将新的依赖版本更新到 go.mod * 也可以使用`go get -u`升级所有依赖。

【示例 2】改造现有项目。

项目目录结构为：

```go
├─ main.go
│
└─ api
   └─ apis.go
```

main.go 源码为：

```go
package main
import (
    api "./api"  // 这里使用的是相对路径
    "github.com/labstack/echo"
)
func main() {
    e := echo.New()
    e.GET("/", api.HelloWorld)
    e.Logger.Fatal(e.Start(":1323"))
}
```

api/apis.go 源码为：

```go
package api
import (
    "net/http"
    "github.com/labstack/echo"
)
func HelloWorld(c echo.Context) error {
    return c.JSON(http.StatusOK, "hello world")
}
```

1. 使用 `go mod init ***` 初始化 go.mod。

   ```go
   go mod init hello
   go: creating new go.mod: module hello
   ```

2. 运行`go run main.go`。

   ```go
   go run main.go
   go: finding golang.org/x/crypto latest
   build _/D_/code/src/api: cannot find module for path _/D_/code/src/api
   ```

首先还是会查找并下载安装依赖，然后运行脚本 main.go，这里会抛出一个错误：

```go
build _/D_/code/src/api: cannot find module for path _/D_/code/src/api
```

但是 go.mod 已经更新：

```go
module hello

go 1.13

require (
  github.com/labstack/echo v3.3.10+incompatible // indirect
  github.com/labstack/gommon v0.3.0 // indirect
  golang.org/x/crypto v0.0.0-20191206172530-e9b2fee46413 // indirect
)


```

那为什么会抛出这个错误呢？

这是因为 main.go 中使用 internal package 的方法跟以前已经不同了，由于 go.mod 会扫描同工作目录下所有 package 并且变更引入方法，必须将 hello 当成路径的前缀，也就是需要写成 import hello/api，以往 GOPATH/dep 模式允许的 import ./api 已经失效。

3) 更新旧的 package import 方式。

所以 main.go 需要改写成：

```go
package main
import (
    api "hello/api" // 这里使用的是相对路径
    "github.com/labstack/echo"
)
func main() {
    e := echo.New()
    e.GET("/", api.HelloWorld)
    e.Logger.Fatal(e.Start(":1323"))
}
```

> 提示：在 Go语言 1.11 版本下使用 go mod 时可能会遇到 go build github.com/valyala/fasttemplate: module requires go 1.12 这种错误，遇到类似这种需要升级到 1.12 的问题，直接升级到Go语言1.12 版本以上就好了。

4) 到这里就和新创建一个项目没什么区别了。

#### 使用 replace 替换无法直接取的 package

由于某些已知的原因，并不是所有的 package 都能成功下载，比如：golang.org 下的包。

modules 可以通过在 go.mod 文件中使用 replace 指令替换成 github 上对应的库，比如：

```go
replace (
  golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a
)
```

或者

```go
replace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a
```



### 19. 生成二维码

二维码作为一种快速的输入手段越来越流行，支付，添加好友，买东西，扫个二维码即可，可以说二维码已经深深地融入了我们的生活中。那么二维码是如何制作生成的呢？我们如何制作自己的二维码呢？

#### 什么是二维码？

二维条码是指在一维条码的基础上扩展出另一维具有可读性的条码，使用黑白矩形图案表示二进制数据，被设备扫描后可获取其中所包含的信息。一维条码的宽度记载着数据，但其长度没有记载数据，而二维条码的长度、宽度均记载着数据。

二维条码有一维条码没有的 “定位点” 和“容错机制”，容错机制在即使没有辨识到全部的条码、或是说条码有污损时，也可以正确地还原条码上的信息。

#### 使用 Go 语言生成二维码图片

使用 Go 语言编程时，生成任意内容的二维码是非常方便的，因为我们有 go-qrcode 这个库。该库的源代码托管在 github 上，大家可以从 github 上（https://github.com/skip2/go-qrcode）下载并使用这个库。

go-qrcode 的使用很简单，假如要为我们的官网 http://c.biancheng.net/ 生成一张 256*256 的图片，可以使用如下代码：

```
1.  package main

3.  import "github.com/skip2/go-qrcode"

5.  func main() {
6.      qrcode.WriteFile("http://c.biancheng.net/",qrcode.Medium,256,"./golang\_qrcode.png")
7.  }
```

这样我们运行代码的时候，就在当前目录下，生成一张 256*256 的二维码，扫描后就可以自动跳转到我们的官网，如下所示：

[![img](http://c.biancheng.net/uploads/allimg/191217/4-19121G053004M.gif)](http://c.biancheng.net/uploads/allimg/191217/4-19121G053004M.gif)

图：二维码

```go
func WriteFile(content string, level RecoveryLevel, size int, filename string) error
```

WriteFile 函数的原型定义如上，它有几个参数，大概意思如下：

- content 表示要生成二维码的内容，可以是任意字符串；

- level 表示二维码的容错级别，取值有 Low、Medium、High、Highest；

- size 表示生成图片的 width 和 height，像素单位；

- filename 表示生成的文件名路径；

- RecoveryLevel 类型其实是个 int，它的定义和常量如下：

```go
type RecoveryLevel int

const (   // Level L: 7% error recovery.   Low RecoveryLevel = iota

// Level M: 15% error recovery. Good default choice.   Medium

// Level Q: 25% error recovery.   High

// Level H: 30% error recovery.   Highest )
```

RecoveryLevel 越高，二维码的容错能力越好。

#### 生成二维码图片字节

有时候我们不想直接生成一个 PNG 文件存储，我们想对 PNG 图片做一些处理，比如缩放了，旋转了，或者网络传输了等，基于此，我们可以使用 Encode 函数，生成一个 PNG 图片的字节流，这样我们就可以进行各种处理了。

```go
func Encode(content string, level RecoveryLevel, size int) ([]byte, error)
```

用法和 WriteFile 函数差不多，只不过返回的是一个 []byte 字节数组，这样我们就可以对这个字节数组进行处理了。

#### 自定义二维码

除了以上两种快捷方式，go-qrcode 库还为我们提供了对二维码的自定义方式，比如我们可以自定义二维码的前景色和背景色等。qrcode.New 函数可以返回一个 *QRCode，我们可以对 *QRCode 设置，实现对二维码的自定义。

比如我们设置背景色为绿色，前景色为白色的二维码

```go
  package main

  import(
      "github.com/skip2/go-qrcode"
      "image/color"
      "log"
  )
  func main() {
      qr,err:=qrcode.New("http://c.biancheng.net/",qrcode.Medium)
      if err != nil {
          log.Fatal(err)
      } else {
          qr.BackgroundColor = color.RGBA{50,205,50,255}
          qr.ForegroundColor = color.White
          qr.WriteFile(256,"./golang\_qrcode.png")
      }
  }
```

指定 *QRCode 的 BackgroundColor 和 ForegroundColor 即可，然后调用 WriteFile 方法生成这个二维码文件，如下所示：

[![img](http://c.biancheng.net/uploads/allimg/191217/4-19121G05319218.gif)](http://c.biancheng.net/uploads/allimg/191217/4-19121G05319218.gif)

图：二维码

```go
  func New(content string, level RecoveryLevel) (\*QRCode, error)

  // A QRCode represents a valid encoded QRCode.
  type QRCode struct {
      // Original content encoded.
      Content string

      // QR Code type.
      Level         RecoveryLevel
      VersionNumber int

      // User settable drawing options.
      ForegroundColor color.Color
      BackgroundColor color.Color
  }
```

以上 QRCode 的这些字段都是可以设置的，这样我们就可以灵活自定义二维码了。

小结：二维码是一种流行的输入技术手段，不光 Go 可以生成，其他语言也可以生成，并且生成的二维码是标准的，都可以扫描和识别，比如 Java 可以通过 https://github.com/kenglxn/QRGen 库来生成。

### 20. Context(上下文)

Context 在 Go1.7 之后就加入到了 Go 语言标准库中，准确说它是 Goroutine 的上下文，包含 Goroutine 的运行状态、环境、现场等信息。

随着 Context 包的引入，标准库中很多接口因此加上了 Context 参数，例如 database/sql 包，Context 几乎成为了并发控制和超时控制的标准做法。

#### 什么是 Context

Context 也叫作 “上下文”，是一个比较抽象的概念，一般理解为程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元则指的是 Goroutine。

每个 Goroutine 在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个 Context 变量中，传递给要执行的 Goroutine 中。

在网络编程下，当接收到一个网络请求 Request，在处理 Request 时，我们可能需要开启不同的 Goroutine 来获取数据与逻辑处理，即一个请求 Request，会在多个 Goroutine 中处理。而这些 Goroutine 可能需要共享 Request 的一些信息，同时当 Request 被取消或者超时的时候，所有从这个 Request 创建的所有 Goroutine 也应该被结束。

#### Context 接口

Context 包的核心就是 Context 接口，其定义如下：

```go
  type Context interface {
      Deadline() (deadline time.Time, ok bool)
      Done() <-chan struct{}
      Err() error
      Value(key interface{}) interface{}
  }
```

其中：

- Deadline 方法需要返回当前 Context 被取消的时间，也就是完成工作的截止时间（deadline）；

- Done 方法需要返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个 Channel；

- Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值：

- 如果当前 Context 被取消就会返回 Canceled 错误；

- 如果当前 Context 超时就会返回 DeadlineExceeded 错误；

- Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法仅用于传递跨 API 和进程间跟请求域的数据。

#### Background() 和 TODO()

Go 语言内置两个函数：Background() 和 TODO()，这两个函数分别返回一个实现了 Context 接口的 background 和 todo。

Background() 主要用于 main 函数、初始化以及测试代码中，作为 Context 这个树结构的最顶层的 Context，也就是根 Context。

TODO()，它目前还不知道具体的使用场景，在不知道该使用什么 Context 的时候，可以使用这个。

background 和 todo 本质上都是 emptyCtx 结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的 Context。

#### With 系列函数

此外，Context 包中还定义了四个 With 系列函数。

#### WithCancel

WithCancel 的函数签名如下：

```go
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)
```

WithCancel 返回带有新 Done 通道的父节点的副本，当调用返回的 cancel 函数或当关闭父上下文的 Done 通道时，将关闭返回上下文的 Done 通道，无论先发生什么情况。

取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：

```go
  package main

  import (
      "context"
      "fmt"
  )

  func main() {
      gen := func(ctx context.Context) <-chan int {
          dst := make(chan int)
          n := 1
          go func() {
              for {
                  select {
                  case <-ctx.Done():
                      return // return结束该goroutine，防止泄露
                  case dst <- n:
                      n++
                  }
              }
          }()
          return dst
      }

      ctx, cancel := context.WithCancel(context.Background())
      defer cancel() // 当我们取完需要的整数后调用cancel

      for n := range gen(ctx) {
          fmt.Println(n)
          if n == 5 {
              break
          }
      }
  }
```

上面的代码中，gen 函数在单独的 Goroutine 中生成整数并将它们发送到返回的通道，gen 的调用者在使用生成的整数之后需要取消上下文，以免 gen 启动的内部 Goroutine 发生泄漏。

运行结果如下：

```go
go run main.go 1 2 3 4 5
```

#### WithDeadline

WithDeadline 的函数签名如下：

```go
func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)
```

WithDeadline 函数会返回父上下文的副本，并将 deadline 调整为不迟于 d。如果父上下文的 deadline 已经早于 d，则 WithDeadline(parent, d) 在语义上等同于父上下文。当截止日过期时，当调用返回的 cancel 函数时，或者当父上下文的 Done 通道关闭时，返回上下文的 Done 通道将被关闭，以最先发生的情况为准。

取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：

```go
  package main

  import (
      "context"
      "fmt"
      "time"
  )

  func main() {
      d := time.Now().Add(50 * time.Millisecond)
      ctx, cancel := context.WithDeadline(context.Background(), d)

      // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。
      // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。
      defer cancel()

      select {
      case <-time.After(1 * time.Second):
          fmt.Println("overslept")
      case <-ctx.Done():
          fmt.Println(ctx.Err())
      }
  }
```

运行结果如下：

```go
go run main.go context deadline exceeded
```

上面的代码中，定义了一个 50 毫秒之后过期的 deadline，然后我们调用 context.WithDeadline(context.Background(), d) 得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个 select 让主程序陷入等待，等待 1 秒后打印 overslept 退出或者等待 ctx 过期后退出。因为 ctx 50 秒后就过期，所以 ctx.Done() 会先接收到值，然后打印 ctx.Err() 取消原因。

#### WithTimeout

WithTimeout 的函数签名如下：

```go
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
```

WithTimeout 函数返回 WithDeadline(parent, time.Now().Add(timeout))。

取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下：

```go
  package main

  import (
      "context"
      "fmt"
      "time"
  )

  func main() {
      // 传递带有超时的上下文
      // 告诉阻塞函数在超时结束后应该放弃其工作。
      ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
      defer cancel()

      select {
      case <-time.After(1 * time.Second):
          fmt.Println("overslept")
      case <-ctx.Done():
          fmt.Println(ctx.Err()) // 终端输出"context deadline exceeded"
      }
  }
```

运行结果如下：

```go
go run main.go context deadline exceeded
```

#### WithValue

WithValue 函数能够将请求作用域的数据与 Context 对象建立关系。函数声明如下：

```go
func WithValue(parent Context, key, val interface{}) Context
```

WithValue 函数接收 context 并返回派生的 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。不建议使用 context 值传递关键参数，函数应接收签名中的那些值，使其显式化。

所提供的键必须是可比较的，并且不应该是 string 类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue 的用户应该为键定义自己的类型，为了避免在分配给接口`{ } `时进行分配，上下文键通常具有具体类型 struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。

```go
  package main

  import (
      "context"
      "fmt"
  )

  func main() {
      type favContextKey string // 定义一个key类型
      // f:一个从上下文中根据key取value的函数
      f := func(ctx context.Context, k favContextKey) {
          if v := ctx.Value(k); v != nil {
              fmt.Println("found value:", v)
              return
          }
          fmt.Println("key not found:", k)
      }
      k := favContextKey("language")
      // 创建一个携带key为k，value为"Go"的上下文
      ctx := context.WithValue(context.Background(), k, "Go")

      f(ctx, k)
      f(ctx, favContextKey("color"))
  }
```

运行结果如下：

```go
go run main.go found value: Go key not found: color
```

使用 Context 的注意事项：

- 不要把 Context 放在结构体中，要以参数的方式显示传递；

- 以 Context 作为参数的函数方法，应该把 Context 作为第一个参数；

- 给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO；

- Context 的 Value 相关方法应该传递请求域的必要数据，不应该用于传递可选参数；

- Context 是线程安全的，可以放心的在多个 Goroutine 中传递。

#### 总结

Go 语言中的 Context 的主要作用还是在多个 Goroutine 或者模块之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费，虽然传值也是它的功能之一，但是这个功能我们还是很少用到。

在真正使用传值的功能时我们也应该非常谨慎，不能将请求的所有参数都使用 Context 进行传递，这是一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。

### 21. 客户信息管理系统

本节带领大家实现一个基于文本界面的客户关系管理软件，该软件可以实现对客户的插入、修改和删除，并且可以打印客户信息明细表。

软件由一下三个模块组成：

[![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ614464c54.gif)](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ614464c54.gif)

项目结构如下所示：

[![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ6144G15E.gif)](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ6144G15E.gif)

在 costumer.go 中，代码如下：

```go
  package model

  import (
      "fmt"
  )

  //声明一个Customer结构体，表示一个客户信息
  type Customer struct {
      Id int
      Name string
      Gender string
      Age int
      Phone string
      Email string
  }

  //使用工厂模式，返回一个Customer的实例
  func NewCustomer(id int, name string, gender string, age int, phone string, email string ) Customer {
      return Customer{
          Id : id,
          Name : name,
          Gender : gender,
          Age : age,
          Phone : phone,
          Email : email,
      }
  }

  //第二种创建Customer实例方法，不带id
  func NewCustomer2(name string, gender string,
      age int, phone string, email string ) Customer {
      return Customer{
          Name : name,
          Gender : gender,
          Age : age,
          Phone : phone,
          Email : email,
      }
  }

  //返回用户的信息,格式化的字符串
  func (this Customer) GetInfo()  string {
      info := fmt.Sprintf("%v\t %v\t %v\t %v\t %v\t %v\t", this.Id,
          this.Name, this.Gender,this.Age, this.Phone, this.Email)
      return info

  }
```

在 costumerService.go 中，代码如下：

```go
  package service

  import (
      "../model"
  )

  //该CustomerService， 完成对Customer的操作,包括
  //增删改查
  type CustomerService struct {
      customers []model.Customer
      //声明一个字段，表示当前切片含有多少个客户
      //该字段后面，还可以作为新客户的id+1
      customerNum int
  }

  //编写一个方法，可以返回 \*CustomerService
  func NewCustomerService() *CustomerService {
      //为了能够看到有客户在切片中，我们初始化一个客户
      customerService := &CustomerService{}
      customerService.customerNum = 1
      customer := model.NewCustomer(1, "张三", "男", 20, "010-56253825", "zs@sohu.com")
      customerService.customers = append(customerService.customers, customer)
      return customerService
  }

  //返回客户切片
  func (this *CustomerService) List() []model.Customer {
      return this.customers
  }

  //添加客户到customers切片
  func (this *CustomerService) Add(customer model.Customer) bool {

      //我们确定一个分配id的规则,就是添加的顺序
      this.customerNum++
      customer.Id = this.customerNum
      this.customers = append(this.customers, customer)
      return true
  }

  //根据id删除客户(从切片中删除)
  func (this *CustomerService) Delete(id int) bool {
      index := this.FindById(id)
      //如果index == -1, 说明没有这个客户
      if index == -1 {
          return false
      }
      //如何从切片中删除一个元素
      this.customers = append(this.customers[:index], this.customers[index+1:]...)
      return true
  }

  //根据id查找客户在切片中对应下标,如果没有该客户，返回-1
  func (this *CustomerService) FindById(id int)  int {
      index := -1
      //遍历this.customers 切片
      for i := 0; i < len(this.customers); i++ {
          if this.customers[i].Id == id {
              //找到
              index = i
          }
      }
      return index
  }
```

在 costumerView.go 中，代码如下：

```go
  package main

  import (
      "fmt"
      "../model"
      "../service"
  )

  type customerView struct {

      //定义必要字段
      key string //接收用户输入...
      loop bool  //表示是否循环的显示主菜单
      //增加一个字段customerService
      customerService *service.CustomerService

  }

  //显示所有的客户信息
  func (this *customerView) list() {

      //首先，获取到当前所有的客户信息(在切片中)
      customers := this.customerService.List()
      //显示
      fmt.Println("---------------------------客户列表---------------------------")
      fmt.Println("编号\t姓名\t性别\t年龄\t电话\t邮箱")
      for i := 0; i < len(customers); i++ {
          //fmt.Println(customers\[i\].Id,"\t", customers[i].Name...)
          fmt.Println(customers\[i\].GetInfo())
      }
      fmt.Printf("\n-------------------------客户列表完成-------------------------\n\n")
  }

  //得到用户的输入，信息构建新的客户，并完成添加
  func (this *customerView) add() {
      fmt.Println("---------------------添加客户---------------------")
      fmt.Print("姓名:")
      name := ""
      fmt.Scanln(&name)
      fmt.Print("性别:")
      gender := ""
      fmt.Scanln(&gender)
      fmt.Print("年龄:")
      age := 0
      fmt.Scanln(&age)
      fmt.Print("电话:")
      phone := ""
      fmt.Scanln(&phone)
      fmt.Print("邮箱:")
      email := ""
      fmt.Scanln(&email)
      //构建一个新的Customer实例
      //注意: id号，没有让用户输入，id是唯一的，需要系统分配
      customer := model.NewCustomer2(name, gender, age, phone, email)
      //调用
      if this.customerService.Add(customer) {
          fmt.Println("---------------------添加完成---------------------")
      } else {
          fmt.Println("---------------------添加失败---------------------")
      }
  }

  //得到用户的输入id，删除该id对应的客户
  func (this *customerView) delete() {
      fmt.Println("---------------------删除客户---------------------")
      fmt.Print("请选择待删除客户编号(-1退出)：")
      id := -1
      fmt.Scanln(&id)
      if id == -1 {
          return //放弃删除操作
      }
      fmt.Println("确认是否删除(Y/N)：")
      //这里同学们可以加入一个循环判断，直到用户输入 y 或者 n,才退出..
      choice := ""
      fmt.Scanln(&choice)
      if choice == "y" || choice == "Y" {
          //调用customerService 的 Delete方法
          if this.customerService.Delete(id) {
              fmt.Println("---------------------删除完成---------------------")
          } else {
              fmt.Println("---------------------删除失败，输入的id号不存在----")
          }
      }
  }

  //退出软件
  func (this *customerView) exit() {

      fmt.Print("确认是否退出(Y/N)：")
      for {
          fmt.Scanln(&this.key)
          if this.key == "Y" || this.key == "y" || this.key == "N" || this.key == "n" {
              break
          }

          fmt.Print("你的输入有误，确认是否退出(Y/N)：")
      }

      if this.key == "Y" || this.key == "y" {
          this.loop = false
      }

  }

  //显示主菜单
  func (this *customerView) mainMenu() {

      for {
          fmt.Println("-----------------客户信息管理软件-----------------")
          fmt.Println("                 1 添 加 客 户")
          fmt.Println("                 2 修 改 客 户")
          fmt.Println("                 3 删 除 客 户")
          fmt.Println("                 4 客 户 列 表")
          fmt.Println("                 5 退       出")
          fmt.Print("请选择(1-5)：")

          fmt.Scanln(&this.key)
          switch this.key {
              case "1" :
                  this.add()
              case "2" :
                  fmt.Println("修 改 客 户")
              case "3" :
                  this.delete()
              case "4" :
                  this.list()
              case "5" :
                  this.exit()
              default :
                  fmt.Println("你的输入有误，请重新输入...")
          }

          if !this.loop {
              break
          }

      }
      fmt.Println("已退出了客户关系管理系统...")
  }

  func main() {
      //在main函数中，创建一个customerView,并运行显示主菜单..
      customerView := customerView{
          key : "",
          loop : true,
      }
      //这里完成对customerView结构体的customerService字段的初始化
      customerView.customerService = service.NewCustomerService()
      //显示主菜单..
      customerView.mainMenu()

  }
```

执行结果如下所示：

```go
D:\code\demo\view>go run customerView.go
—————– 客户信息管理软件 —————–
                 1 添 加 客 户
                 2 修 改 客 户
                 3 删 除 客 户
                 4 客 户 列 表
                 5 退       出
请选择 (1-5)：1
——————— 添加客户 ———————
姓名: 李四
性别: 男
年龄: 22
电话: 15611112222
邮箱: lisi@qq.com
——————— 添加完成 ———————
—————– 客户信息管理软件 —————–
                 1 添 加 客 户
                 2 修 改 客 户
                 3 删 除 客 户
                 4 客 户 列 表
                 5 退       出
请选择 (1-5)：4
————————— 客户列表 —————————
编号    姓名    性别    年龄    电话    邮箱
1        张三    男      20      010-56253825    zs@sohu.com
2        李四    男      22      15611112222     lisi@qq.com

———————— 客户列表完成 ————————-
—————- 客户信息管理软件 —————– 1 添 加 客 户 2 修 改 客 户 3 删 除 客 户 4 客 户 列 表 5 退 出
请选择 (1-5)：
```



### 22. 发送电子邮件

电子邮件在日常工作中有很大用途，凡项目或任务，有邮件来往可避免扯皮背锅。而在一些自动化的应用场合，也使用得广泛，特别是系统监控方面，如果在资源使用达到警戒线之前自动发邮件通知运维人员，能消除隐患于前期，而不至于临时临急去做善后方案。

对于多人协合（不管是不是异地）场合，邮件也有用武之地，当有代码或文档更新时，自动发邮件通知项目成员或领导，提醒各方人员知晓并及时更新。

说到发邮件，不得不提用程序的方式实现。下面就来为大家介绍一下怎么使用 Go 语言来实现发送电子邮件。Go 语言拥有大量的库，非常方便使用。

Go 语言使用 gomail 包来发送邮箱，代码如下所示：

```go
  package main

  import (
      "strings"
      "github.com/go-gomail/gomail"
  )

  type EmailParam struct {
      // ServerHost 邮箱服务器地址，如腾讯邮箱为smtp.qq.com
      ServerHost string
      // ServerPort 邮箱服务器端口，如腾讯邮箱为465
      ServerPort int
      // FromEmail　发件人邮箱地址
      FromEmail string
      // FromPasswd 发件人邮箱密码（注意，这里是明文形式），TODO：如果设置成密文？
      FromPasswd string
      // Toers 接收者邮件，如有多个，则以英文逗号(“,”)隔开，不能为空
      Toers string
      // CCers 抄送者邮件，如有多个，则以英文逗号(“,”)隔开，可以为空
      CCers string
  }

  // 全局变量，因为发件人账号、密码，需要在发送时才指定
  // 注意，由于是小写，外面的包无法使用
  var serverHost, fromEmail, fromPasswd string
  var serverPort int

  var m \*gomail.Message

  func InitEmail(ep \*EmailParam) {
      toers := \[\]string{}

      serverHost = ep.ServerHost
      serverPort = ep.ServerPort
      fromEmail = ep.FromEmail
      fromPasswd = ep.FromPasswd

      m = gomail.NewMessage()

      if len(ep.Toers) == 0 {
          return
      }

      for \_, tmp := range strings.Split(ep.Toers, ",") {
          toers = append(toers, strings.TrimSpace(tmp))
      }

      // 收件人可以有多个，故用此方式
      m.SetHeader("To", toers...)

      //抄送列表
      if len(ep.CCers) != 0 {
          for \_, tmp := range strings.Split(ep.CCers, ",") {
              toers = append(toers, strings.TrimSpace(tmp))
          }
          m.SetHeader("Cc", toers...)
      }

      // 发件人
      // 第三个参数为发件人别名，如"李大锤"，可以为空（此时则为邮箱名称）
      m.SetAddressHeader("From", fromEmail, "")
  }

  // SendEmail body支持html格式字符串
  func SendEmail(subject, body string) {
      // 主题
      m.SetHeader("Subject", subject)

      // 正文
      m.SetBody("text/html", body)

      d := gomail.NewPlainDialer(serverHost, serverPort, fromEmail, fromPasswd)
      // 发送
      err := d.DialAndSend(m)
      if err != nil {
          panic(err)
      }
  }

  func main() {
      serverHost := "smtp.qq.com"
      serverPort := 465
      fromEmail := "xxxxxxx@qq.com"     //发件人邮箱
      fromPasswd := "xumkkzfscmxxxxxx"    //授权码

      myToers := "xxxxxxx@qq.com" // 收件人邮箱，逗号隔开
      myCCers := "" //"readchy@163.com"

      subject := "这是主题"
      body := \`这是正文<br>
               Hello <a href = "http://c.biancheng.net/">C语言中文网</a>\`
      // 结构体赋值
      myEmail := &EmailParam {
          ServerHost: serverHost,
          ServerPort: serverPort,
          FromEmail:  fromEmail,
          FromPasswd: fromPasswd,
          Toers:      myToers,
          CCers:      myCCers,
      }

      InitEmail(myEmail)
      SendEmail(subject, body)
  }
```

使用自定义客户端发放邮件需要以下两个要素:

1. 发送方的邮箱必须开启 stmt 和 pop3 通道，以 qq 邮箱为例，登陆 qq 邮箱 -> 设置 -> 账户 -> 开启 pop3 和 stmt 服务

[![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ61G630217.gif)](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ61G630217.gif)

1. 开启后会获得该账户的授权码，如果忘记也可以重新生成。

[![img](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ61GA44D.gif)](http://c.biancheng.net/uploads/allimg/190906/4-1ZZ61GA44D.gif)

### 23. （Pingo）插件化开发

Pingo 是一个用来为 Go 语言程序编写插件的简单独立库，因为 Go 本身是静态链接的，因此所有插件都以外部进程方式存在。Pingo 旨在简化标准 RPC 包，支持 TCP 和 Unix 套接字作为通讯协议。当前还不支持远程插件，如果有需要，远程插件很快会提供。

使用 Pingo 创建一个插件非常简单，首先新建目录，如 “plugins/hello-world” ，然后在该目录下编写 main.go：

```go
  // 创建新的二进制文件
  package main

  import "github.com/dullgiulio/pingo"

  // 创建要导出的对象
  type MyPlugin struct{}

  // 导出的方法，带有rpc签名
  func (p *MyPlugin) SayHello(name string, msg *string) error {
      *msg = "Hello, " + name
      return nil
  }

  func main() {
      plugin := &MyPlugin{}

      // 注册要导出的对象
      pingo.Register(plugin)
      // 运行主程序
      pingo.Run()
  }
```

使用 `go build` 命令编译并生成可执行文件：

cd plugins/hello-world go build

接下来就可以调用该插件：

```go
  package main

  import (
      "log"
      "github.com/dullgiulio/pingo"
  )

  func main() {
      // 从创建的可执行文件中创建一个新插件。通过 TCP 连接到它
      p := pingo.NewPlugin("tcp", "plugins/hello-world/hello-world")
      // 启动插件
      p.Start()
      // 使用完插件后停止它
      defer p.Stop()

      var resp string

      // 从先前创建的对象调用函数
      if err := p.Call("MyPlugin.SayHello", "Go developer", &resp); err != nil {
          log.Print(err)
      } else {
          log.Print(resp)
      }
  }
```

运行结果如下：

go run main.go 2019/12/17 18:00:20 Hello, Go developer

### 24. 定时器实现原理及作用

对于任何一个正在运行的应用，如何获取准确的绝对时间都非常重要，但是在一个分布式系统中我们很难保证各个节点上绝对时间的一致性，哪怕通过 NTP 这种标准的对时协议也只能把时间的误差控制在毫秒级，所以相对时间在一个分布式系统中显得更为重要，在接下来的讲解中我们将会介绍一下 Go 语言中的定时器以及它在并发编程中起到什么样的作用。

绝对时间一定不会是完全准确的，它对于一个运行中的分布式系统其实没有太多指导意义，但是由于相对时间的计算不依赖于外部的系统，所以它的计算可以做的比较准确，首先介绍一下 Go 语言中用于计算相对时间的定时器的实现原理。

#### 结构

timer 就是 Go 语言定时器的内部表示，每一个 timer 其实都存储在堆中，tb 就是用于存储当前定时器的桶，而 i 是当前定时器在堆中的索引，我们可以通过这两个变量找到当前定时器在堆中的位置：

```go
type timer struct {
    tb *timersBucket
    i  int

    when   int64
    period int64
    f      func(interface{}, uintptr)
    arg    interface{}
    seq    uintptr
}
```

when 表示当前定时器（Timer）被唤醒的时间，而 period 表示两次被唤醒的间隔，每当定时器被唤醒时都会调用 f(args, now) 函数并传入 args 和当前时间作为参数。

然而这里的 timer 作为一个私有结构体其实只是定时器的运行时表示，time 包对外暴露的定时器使用了如下所示的结构体：

```go
type Timer struct {
    C <-chan Time
    r runtimeTimer
}
```

Timer 定时器必须通过 NewTimer 或者 AfterFunc 函数进行创建，其中的 runtimeTimer 其实就是上面介绍的 timer 结构体，当定时器失效时，失效的时间就会被发送给当前定时器持有的 Channel C，订阅管道中消息的 Goroutine 就会收到当前定时器失效的时间。

在 time 包中，除了 timer 和 Timer 两个分别用于表示运行时定时器和对外暴露的 API 之外，timersBucket 这个用于存储定时器的结构体也非常重要，它会存储一个处理器上的全部定时器，不过如果当前机器的核数超过了 64 核，也就是机器上的处理器 P 的个数超过了 64 个，多个处理器上的定时器就可能存储在同一个桶中：

```go
type timersBucket struct {
    lock         mutex
    gp           *g
    created      bool
    sleeping     bool
    rescheduling bool
    sleepUntil   int64
    waitnote     note
    t            []*timer
}
```

每一个 timersBucket 中的 t 就是用于存储定时器指针的切片，每一个运行的 Go 语言程序都会在内存中存储着 64 个桶，这些桶中都存储定时器的信息：

[![img](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4105556204.gif)](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4105556204.gif)

每一个桶持有的 timer 切片其实都是一个最小堆，这个最小堆会按照 timer 应该触发的时间对它们进行排序，最小堆最上面的定时器就是最近需要被唤醒的 timer，下面来介绍下定时器的创建和触发过程。

#### 工作原理

既然我们已经介绍了定时器的数据结构，接下来我们就可以开始分析它的常见操作以及工作原理了，在这一节中我们将介绍定时器的创建、触发、time.Sleep 与定时器的关系以及计时器 Ticker 的实现原理。

##### 创建

time 包对外提供了两种创建定时器的方法，第一种方法就是 NewTimer 接口，这个接口会创建一个用于通知触发时间的 Channel、调用 startTimer 方法并返回一个创建指向 Timer 结构体的指针：

```go
  func NewTimer(d Duration) *Timer {
      c := make(chan Time, 1)
      t := &Timer{
          C: c,
          r: runtimeTimer{
              when: when(d),
              f:    sendTime,
              arg:  c,
          },
      }
      startTimer(&t.r)
      return t
  }
```

另一个用于创建 Timer 的方法 AfterFunc 其实也提供了非常相似的结构，与 NewTimer 方法不同的是该方法没有创建一个用于通知触发时间的 Channel，它只会在定时器到期时调用传入的方法：

```go
  func AfterFunc(d Duration, f func()) *Timer {
      t := &Timer{
          r: runtimeTimer{
              when: when(d),
              f:    goFunc,
              arg:  f,
          },
      }
      startTimer(&t.r)
      return t
  }
```

startTimer 基本上就是创建定时器的入口了，所有定时器的创建和重启基本上都需要调用该函数：

```go
  func startTimer(t *timer) {
      addtimer(t)
  }

  func addtimer(t *timer) {
      tb := t.assignBucket()
      tb.addtimerLocked(t)
  }
```

它会调用 addtimer 函数，这个函数总共做了两件事情，首先通过 assignBucket 方法为当前定时器选择一个 timersBucket 桶，我们会根据当前 Goroutine 所在处理器 P 的 id 选择一个合适的桶，随后调用 addtimerLocked 方法将当前定时器加入桶中：

```go
  func (tb *timersBucket) addtimerLocked(t *timer) bool {
      t.i = len(tb.t)
      tb.t = append(tb.t, t)
      if !siftupTimer(tb.t, t.i) {
          return false
      }
      if t.i == 0 {
          if tb.sleeping && tb.sleepUntil > t.when {
              tb.sleeping = false
              notewakeup(&tb.waitnote)
          }
          if tb.rescheduling {
              tb.rescheduling = false
              goready(tb.gp, 0)
          }
          if !tb.created {
              tb.created = true
              go timerproc(tb)
          }
      }
      return true
  }
```

addtimerLocked 会先将最新加入的定时器加到队列的末尾，随后调用 siftupTimer 将当前定时器与四叉树（或者四叉堆）中的父节点进行比较，保证父节点的到期时间一定小于子节点：

[![img](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4105AWQ.gif)](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4105AWQ.gif)

这个四叉树只能保证父节点的到期时间大于子节点，这对于我们来说其实也足够了，因为我们只关心即将被触发的计数器，如果当前定时器是第一个被加入四叉树的定时器，我们还会通过 go timerproc(tb) 启动一个 Goroutine 用于处理当前树中的定时器，这也是处理定时器的核心方法。

##### 触发

定时器的触发都是由 timerproc 中的一个双层 for 循环控制的，外层的 for 循环主要负责对当前 Goroutine 进行控制，它不仅会负责锁的获取和释放，还会在合适的时机触发当前 Goroutine 的休眠：

```go
  func timerproc(tb *timersBucket) {
      tb.gp = getg()
      for {
          tb.sleeping = false
          now := nanotime()
          delta := int64(-1)

          // inner loop

          if delta < 0 {
              tb.rescheduling = true
              goparkunlock(&tb.lock, waitReasonTimerGoroutineIdle, traceEvGoBlock, 1)
              continue
          }
          tb.sleeping = true
          tb.sleepUntil = now + delta
          noteclear(&tb.waitnote)
          notetsleepg(&tb.waitnote, delta)
      }
  }
```

如果距离下一个定时器被唤醒的时间小于 0，当前的 timerproc 就会将 rescheduling 标记设置成 true 并立刻陷入休眠，这其实也意味着当前 timerproc 中不包含任何待处理的定时器，当我们再向该 timerBucket 加入定时器时就会重新唤醒 timerproc Goroutine。

在其他情况下，也就是下一次计数器的响应时间是 now + delta 时，timerproc 中的外层循环会通过 notesleepg 将当前 Goroutine 陷入休眠。

```go
  func notetsleepg(n *note, ns int64) bool {
      gp := getg()
      if gp == gp.m.g0 {
          throw("notetsleepg on g0")
      }
      semacreate(gp.m)
      entersyscallblock()
      ok := notetsleep_internal(n, ns, nil, 0)
      exitsyscall()
      return ok
  }
```

该函数会先获取当前的 Goroutine 并在当前的 CPU 上创建一个信号量，随后在 entersyscallblock 和 exitsyscall 之间执行系统调用让当前的 Goroutine 陷入休眠并在 ns 纳秒后返回。

内部循环的主要作用就是触发已经到期的定时器，在这个内部循环中，我们会按照以下的流程对当前桶中的定时器进行处理：

- 如果桶中不包含任何定时器就会直接返回并陷入休眠等待定时器加入当前桶；

- 如果四叉树最上面的定时器还没有到期会通过 notetsleepg 方法陷入休眠等待最近定时器的到期；

- 如果四叉树最上面的定时器已经到期；

- 当定时器的 period > 0 就会设置下一次会触发定时器的时间并将当前定时器向下移动到对应的位置；

- 当定时器的 period <= 0 就会将当前定时器从四叉树中移除；

- 在每次循环的最后都会从定时器中取出定时器中的函数、参数和序列号并调用函数触发该计数器；

```go
  for {
      if len(tb.t) == 0 {
          delta = -1
          break
      }
      t := tb.t[0]
      delta = t.when - now
      if delta > 0 {
          break
      }
      ok := true
      if t.period > 0 {
          t.when += t.period * (1 + -delta/t.period)
          if !siftdownTimer(tb.t, 0) {
              ok = false
          }
      } else {
          last := len(tb.t) - 1
          if last > 0 {
              tb.t[0] = tb.t[last]
              tb.t[0].i = 0
          }
          tb.t[last] = nil
          tb.t = tb.t[:last]
          if last > 0 {
              if !siftdownTimer(tb.t, 0) {
                  ok = false
              }
          }
          t.i = -1 // mark as removed
      }
      f := t.f
      arg := t.arg
      seq := t.seq
      f(arg, seq)
  }
```

使用 NewTimer 创建的定时器，传入的函数时 sendTime，它会将当前时间发送到定时器持有的 Channel 中，而使用 AfterFunc 创建的定时器，在内层循环中调用的函数就会是调用方传入的函数了。

##### 休眠

如果你使用过一段时间的 Go 语言，一定在项目中使用过 time 包中的 Sleep 方法让当前的 Goroutine 陷入休眠以等待某些条件的完成或者触发一些定时任务，time.Sleep 就是通过如下所示的 timeSleep 方法完成的：

```go
  func timeSleep(ns int64) {
      if ns <= 0 {
          return
      }

      gp := getg()
      t := gp.timer
      if t == nil {
          t = new(timer)
          gp.timer = t
      }
      *t = timer{}
      t.when = nanotime() + ns
      t.f = goroutineReady
      t.arg = gp
      tb := t.assignBucket()
      lock(&tb.lock)
      if !tb.addtimerLocked(t) {
          unlock(&tb.lock)
          badTimer()
      }
      goparkunlock(&tb.lock, waitReasonSleep, traceEvGoSleep, 2)
  }
```

timeSleep 会创建一个新的 timer 结构体，在初始化的过程中我们会传入当前 Goroutine 应该被唤醒的时间以及唤醒时需要调用的函数 goroutineReady，随后会调用 goparkunlock 将当前 Goroutine 陷入休眠状态，当定时器到期时也会调用 goroutineReady 方法唤醒当前的 Goroutine：

```go
func goroutineReady(arg interface{}, seq uintptr) {
    goready(arg.(*g), 0)
}
```

time.Sleep 方法其实只是创建了一个会在到期时唤醒当前 Goroutine 的定时器并通过 goparkunlock 将当前的协程陷入休眠状态等待定时器触发的唤醒。

##### Ticker

除了只用于一次的定时器（Timer）之外，Go 语言的 time 包中还提供了用于多次通知的 Ticker 计时器，计时器中包含了一个用于接受通知的 Channel 和一个定时器，这两个字段共同组成了用于连续多次触发事件的计时器：

```go
type Ticker struct {
    C <-chan Time // The channel on which the ticks are delivered.
    r runtimeTimer
}
```

想要在 Go 语言中创建一个计时器只有两种方法，一种是使用 NewTicker 方法显示地创建 Ticker 计时器指针，另一种可以直接通过 Tick 方法获取一个会定期发送消息的 Channel：

```go
  func NewTicker(d Duration) *Ticker {
      if d <= 0 {
          panic(errors.New("non-positive interval for NewTicker"))
      }
      c := make(chan Time, 1)
      t := &Ticker{
          C: c,
          r: runtimeTimer{
              when:   when(d),
              period: int64(d),
              f:      sendTime,
              arg:    c,
          },
      }
      startTimer(&t.r)
      return t
  }

  func Tick(d Duration) <-chan Time {
      if d <= 0 {
          return nil
      }
      return NewTicker(d).C
  }
```

Tick 其实也只是对 NewTicker 的简单封装，从实现上我们就能看出来它其实就是调用了 NewTicker 获取了计时器并返回了计时器中 Channel，两个创建计时器的方法的实现都并不复杂而且费容易理解，所以在这里也就不详细展开介绍了。

需要注意的是每一个 NewTicker 方法开启的计时器都需要在不需要使用时调用 Stop 进行关闭，如果不显示调用 Stop 方法，创建的计时器就没有办法被垃圾回收，而通过 Tick 创建的计时器由于只对外提供了 Channel，所以是一定没有办法关闭的，我们一定要谨慎使用这一接口创建计时器。

#### 性能分析

定时器在内部使用四叉树的方式进行实现和存储，当我们在生产环境中使用定时器进行毫秒级别的计时时，在高并发的场景下会有比较明显的性能问题，我们可以通过实验测试一下定时器在高并发时的性能，假设我们有以下的代码：

```go
  func runTimers(count int) {
      durationCh := make(chan time.Duration, count)

      wg := sync.WaitGroup{}
      wg.Add(count)
      for i := 0; i < count; i++ {
          go func() {
              startedAt := time.Now()
              time.AfterFunc(10*time.Millisecond, func() {
                  defer wg.Done()
                  durationCh <- time.Since(startedAt)
              })
          }()

      }
      wg.Wait()

      close(durationCh)

      durations := []time.Duration{}
      totalDuration := 0 * time.Millisecond
      for duration := range durationCh {
          durations = append(durations, duration)
          totalDuration += duration
      }
      averageDuration := totalDuration / time.Duration(count)
      sort.Slice(durations, func(i, j int) bool {
          return durations[i] < durations[j]
      })

      fmt.Printf("run %v timers with average=%v, pct50=%v, pct99=%v\n", count, averageDuration, durations[count/2], durations[int(float64(count)*0.99)])
  }
```

> 注意：由于机器和性能的不同，多次运行测试可能会有不一样的结果。

这段代码开了 N 个 Goroutine 并在每一个 Goroutine 中运行一个定时器，我们会在定时器到期时将开始计时到定时器到期所用的时间加入 Channel 并用于之后的统计，在函数的最后我们会计算出 N 个 Goroutine 中定时器到期时间的平均数、50 分位数和 99 分位数：

```go
$ go test ./… -v
\=== RUN   TestTimers
run 1000 timers with average=10.367111ms, pct50=10.234219ms, pct99=10.913219ms
run 2000 timers with average=10.431598ms, pct50=10.37367ms, pct99=11.025823ms
run 5000 timers with average=11.873773ms, pct50=11.986249ms, pct99=12.673725ms
run 10000 timers with average=11.954716ms, pct50=12.313613ms, pct99=13.507858ms
run 20000 timers with average=11.456237ms, pct50=10.625529ms, pct99=25.246254ms
run 50000 timers with average=21.223818ms, pct50=14.792982ms, pct99=34.250143ms
run 100000 timers with average=36.010924ms, pct50=31.794761ms, pct99=128.089527ms
run 500000 timers with average=176.676498ms, pct50=138.238588ms, pct99=676.967558ms
— PASS: TestTimers (1.21s)
```

我们将上述代码输出的结果绘制成如下图所示的折线图，其中横轴是并行定时器的个数，纵轴表示定时器从开始到触发时间的差值，三个不同的线分别表示时间的平均值、50 分位数和 99 分位数：

[![img](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ410592D13.gif)](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ410592D13.gif)

虽然测试的数据可能有一些误差，但是从图中我们也能得出一些跟定时器性能和现象有关的结论：

- 定时器触发的时间一定会晚于创建时传入的时间，假设定时器需要等待 10ms 触发，那它触发的时间一定是晚于 10ms 的；

- 当并发的定时器数量达到 5000 时，定时器的平均误差达到了 ~18%，99 分位数上的误差达到了 ~26%；

- 并发定时器的数量超过 5000 之后，定时器的误差就变得非常明显，不能有效、准确地完成计时任务；

这其实也是因为定时器从开始到触发的时间间隔非常短，当我们将计时的时间改到 100ms 时就会发现性能问题有比较明显的改善：

[![img](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4110000Y5.gif)](http://c.biancheng.net/uploads/allimg/190904/4-1ZZ4110000Y5.gif)

哪怕并行运行了 10w 个定时器，99 分位数的误差也只有 ~12%，我们其实能够发现 Go 语言标准库中的定时器在计时时间较短并且并发较高时有着非常明显的问题，所以在一些性能非常敏感的基础服务中使用定时器一定要非常注意，它可能达不到我们预期的效果。

不过哪怕我们不主动使用定时器，而是使用 context.WithDeadline 这种方法，由于它底层也会使用定时器实现，所以仍然会受到影响。

#### 总结

Go 语言的定时器在并发编程起到了非常重要的作用，它能够为我们提供比较准确的相对时间，基于它的功能，标准库中还提供了计时器、休眠等接口能够帮助我们在 Go 语言程序中更好地处理过期和超时等问题。

标准库中的定时器在大多数情况下是能够正常工作并且高效完成任务的，但是在遇到极端情况或者性能敏感场景时，它可能没有办法胜任，而在 10ms 的这个粒度下，目前也没有找到能够使用的定时器实现，一些使用时间轮算法的开源库也不能很好地完成这个任务。



## 第九章 并发

### 1. 并发简述（并发的优势）

有人把Go语言比作 21 世纪的C语言，第一是因为Go语言设计简单，第二则是因为 21 世纪最重要的就是并发程序设计，而 Go 从语言层面就支持并发。同时实现了自动垃圾回收机制。

Go语言的并发机制运用起来非常简便，在启动并发的方式上直接添加了语言级的关键字就可以实现，和其他编程语言相比更加轻量。

下面来介绍几个概念：

##### 进程/线程

进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。

线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。

一个进程可以创建和撤销多个线程，同一个进程中的多个线程之间可以并发执行。

##### 并发/并行

多线程程序在单核心的 cpu 上运行，称为并发；多线程程序在多核心的 cpu 上运行，称为并行。

并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。

##### 协程/线程

协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。

线程：一个线程上可以跑多个协程，协程是轻量级的线程。

优雅的并发编程范式，完善的并发支持，出色的并发性能是Go语言区别于其他语言的一大特色。使用Go语言开发服务器程序时，就需要对它的并发机制有深入的了解。

#### Goroutine 介绍

goroutine 是一种非常轻量级的实现，可在单个进程里执行成千上万的并发任务，它是Go语言并发设计的核心。

说到底 goroutine 其实就是线程，但是它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，而且Go语言内部也实现了 goroutine 之间的内存共享。

使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。

goroutine 的用法如下：

```go
//go 关键字放在方法调用前新建一个 goroutine 并执行方法体
go GetThingDone(param1, param2);
//新建一个匿名方法并执行
go func(param1, param2) {
}(val1, val2)
//直接新建一个 goroutine 并在 goroutine 中执行代码块
go {
    //do someting...
}
```

因为 goroutine 在多核 cpu 环境下是并行的，如果代码块在多个 goroutine 中执行，那么我们就实现了代码的并行。

如果需要了解程序的执行情况，怎么拿到并行的结果呢？需要配合使用channel进行。

#### channel

channel 是Go语言在语言级别提供的 goroutine 间的通信方式。我们可以使用 channel 在两个或多个 goroutine 之间传递消息。

channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go语言对于网络方面也有非常完善的支持。

channel 是类型相关的，也就是说，一个 channel 只能传递一种类型的值，这个类型需要在声明 channel 时指定。如果对 Unix 管道有所了解的话，就不难理解 channel，可以将其认为是一种类型安全的管道。

定义一个 channel 时，也需要定义发送到 channel 的值的类型，注意，必须使用 make 创建 channel，代码如下所示：

```go
ci := make(chan int)
cs := make(chan string)
cf := make(chan interface{})
```

回到在 Windows 和 Linux 出现之前的古老年代，在开发程序时并没有并发的概念，因为命令式程序设计语言是以串行为基础的，程序会顺序执行每一条指令，整个程序只有一个执行上下文，即一个调用栈，一个堆。

并发则意味着程序在运行时有多个执行上下文，对应着多个调用栈。我们知道每一个进程在运行时，都有自己的调用栈和堆，有一个完整的上下文，而操作系统在调度进程的时候，会保存被调度进程的上下文环境，等该进程获得时间片后，再恢复该进程的上下文到系统中。

从整个操作系统层面来说，多个进程是可以并发的，那么并发的价值何在？下面我们先看以下几种场景。

1) 一方面我们需要灵敏响应的图形用户界面，一方面程序还需要执行大量的运算或者 IO 密集操作，而我们需要让界面响应与运算同时执行。

2) 当我们的 Web 服务器面对大量用户请求时，需要有更多的“Web 服务器工作单元”来分别响应用户。

3) 我们的事务处于分布式环境上，相同的工作单元在不同的计算机上处理着被分片的数据，计算机的 CPU 从单内核（core）向多内核发展，而我们的程序都是串行的，计算机硬件的能力没有得到发挥。

4) 我们的程序因为 IO 操作被阻塞，整个程序处于停滞状态，其他 IO 无关的任务无法执行。

从以上几个例子可以看到，串行程序在很多场景下无法满足我们的要求。下面我们归纳了并发程序的几条优点，让大家认识到并发势在必行：

- 并发能更客观地表现问题模型；
- 并发可以充分利用 CPU 核心的优势，提高程序的执行效率；
- 并发能充分利用 CPU 与其他硬件设备固有的异步性。

### 2. goroutine（轻量级线程）

在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。

虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go语言中被称为 **goroutine**。

goroutine 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。

Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。

#### 使用普通函数创建 goroutine

Go 程序中使用 **go** 关键字为一个函数创建一个 goroutine。一个函数可以被创建多个 goroutine，一个 goroutine 必定对应一个函数。

##### 1) 格式

为一个普通函数创建 goroutine 的写法如下：

```go
go 函数名( 参数列表 )
```

- 函数名：要调用的函数名。
- 参数列表：调用函数需要传入的参数。


使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。

如果需要在 goroutine 中返回数据，请使用后面介绍的通道（channel）特性，通过通道把数据从 goroutine 中作为返回值传出。

##### 2) 例子

使用 go 关键字，将 running() 函数并发执行，每隔一秒打印一次计数器，而 main 的 goroutine 则等待用户输入，两个行为可以同时进行。请参考下面代码：

```go
package main
import (
    "fmt"
    "time"
)
func running() {
    var times int
    // 构建一个无限循环
    for {
        times++
        fmt.Println("tick", times)
        // 延时1秒
        time.Sleep(time.Second)
    }
}
func main() {
    // 并发执行程序
    go running()
    // 接受命令行输入, 不做任何事情
    var input string
    fmt.Scanln(&input)
}
```

命令行输出如下：

```go
tick 1
tick 2
tick 3
tick 4
tick 5
```

代码执行后，命令行会不断地输出 tick，同时可以使用 fmt.Scanln() 接受用户输入。两个环节可以同时进行。

代码说明如下：
第 12 行，使用 for 形成一个无限循环。
第 13 行，times 变量在循环中不断自增。
第 14 行，输出 times 变量的值。
第 17 行，使用 time.Sleep 暂停 1 秒后继续循环。
第 25 行，使用 go 关键字让 running() 函数并发运行。
第 29 行，接受用户输入，直到按 Enter 键时将输入的内容写入 input 变量中并返回，整个程序终止。

这段代码的执行顺序如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180816/1-1PQ61K343405.jpg)
图：并发运行图


这个例子中，Go 程序在启动时，运行时（runtime）会默认为 main() 函数创建一个 goroutine。在 main() 函数的 goroutine 中执行到 go running 语句时，归属于 running() 函数的 goroutine 被创建，running() 函数开始在自己的 goroutine 中执行。此时，main() 继续执行，两个 goroutine 通过 Go 程序的调度机制同时运作。

#### 使用匿名函数创建goroutine

go 关键字后也可以为匿名函数或闭包启动 goroutine。

##### 1) 使用匿名函数创建goroutine的格式

使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数，格式如下：

```go
go func( 参数列表 ){
  函数体
}( 调用参数列表 )
```

其中：

- 参数列表：函数体内的参数变量列表。
- 函数体：匿名函数的代码。
- 调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。

##### 2) 使用匿名函数创建goroutine的例子

在 main() 函数中创建一个匿名函数并为匿名函数启动 goroutine。匿名函数没有参数。代码将并行执行定时打印计数的效果。参见下面的代码：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    go func() {
        var times int
        for {
            times++
            fmt.Println("tick", times)
            time.Sleep(time.Second)
        }
    }()
    var input string
    fmt.Scanln(&input)
}
```

代码说明如下：

- 第 10 行，go 后面接匿名函数启动 goroutine。
- 第 12～19 行的逻辑与前面程序的 running() 函数一致。
- 第 21 行的括号的功能是调用匿名函数的参数列表。由于第 10 行的匿名函数没有参数，因此第 21 行的参数列表也是空的。

#### 提示

所有 goroutine 在 main() 函数结束时会一同结束。

goroutine 虽然类似于线程概念，但是从调度性能上没有线程细致，而细致程度取决于 Go 程序的 goroutine 调度器的实现和运行环境。

终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。虽然可以用 golang.org/x/net/context 包进行 goroutine 生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。

截止 Go 1.9 版本，暂时没有标准接口获取 goroutine 的 ID。

### 3. 并发通信

通过上一节《[Go语言goroutine](http://c.biancheng.net/view/93.html)》的学习，关键字 go 的引入使得在Go语言中并发编程变得简单而优雅，但我们同时也应该意识到并发编程的原生复杂性，并时刻对并发中容易出现的问题保持警惕。

事实上，不管是什么平台，什么编程语言，不管在哪，并发都是一个大话题。并发编程的难度在于协调，而协调就要通过交流，从这个角度看来，并发单元间的通信是最大的问题。

在工程上，有两种最常见的并发通信模型：共享数据和消息。

共享数据是指多个并发单元分别保持对同一个数据的引用，实现对该数据的共享。被共享的数据可能有多种形式，比如内存数据块、磁盘文件、网络数据等。在实际工程应用中最常见的无疑是内存了，也就是常说的共享内存。

先看看我们在C语言中通常是怎么处理线程间数据共享的，代码如下所示。

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
void *count();
pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
int counter = 0;
int main()
{
    int rc1, rc2;
    pthread_t thread1, thread2;
    /* 创建线程，每个线程独立执行函数functionC */
    if((rc1 = pthread_create(&thread1, NULL, &count, NULL)))
    {
        printf("Thread creation failed: %d\n", rc1);
    }
    if((rc2 = pthread_create(&thread2, NULL, &count, NULL)))
    {
        printf("Thread creation failed: %d\n", rc2);
    }
    /* 等待所有线程执行完毕 */
    pthread_join( thread1, NULL);
    pthread_join( thread2, NULL);
    exit(0);
}
void *count()
{
    pthread_mutex_lock( &mutex1 );
    counter++;
    printf("Counter value: %d\n",counter);
    pthread_mutex_unlock( &mutex1 );
}

```

现在我们尝试将这段C语言代码直接翻译为Go语言代码，代码如下所示。

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
)
var counter int = 0
func Count(lock *sync.Mutex) {
    lock.Lock()
    counter++
    fmt.Println(counter)
    lock.Unlock()
}
func main() {
    lock := &sync.Mutex{}
    for i := 0; i < 10; i++ {
        go Count(lock)
    }
    for {
        lock.Lock()
        c := counter
        lock.Unlock()
        runtime.Gosched()
        if c >= 10 {
            break
        }
    }
}
```

在上面的例子中，我们在 10 个 goroutine 中共享了变量 counter。每个 goroutine 执行完成后，会将 counter 的值加 1。因为 10 个 goroutine 是并发执行的，所以我们还引入了锁，也就是代码中的 lock 变量。每次对 n 的操作，都要先将锁锁住，操作完成后，再将锁打开。

在 main 函数中，使用 for 循环来不断检查 counter 的值（同样需要加锁）。当其值达到 10 时，说明所有 goroutine 都执行完毕了，这时主函数返回，程序退出。

事情好像开始变得糟糕了。实现一个如此简单的功能，却写出如此臃肿而且难以理解的代码。想象一下，在一个大的系统中具有无数的锁、无数的共享变量、无数的业务逻辑与错误处理分支，那将是一场噩梦。这噩梦就是众多 C/[C++](http://c.biancheng.net/cplus/) 开发者正在经历的，其实 [Java](http://c.biancheng.net/java/) 和 [C#](http://c.biancheng.net/csharp/) 开发者也好不到哪里去。

Go语言既然以并发编程作为语言的最核心优势，当然不至于将这样的问题用这么无奈的方式来解决。Go语言提供的是另一种通信模型，即以消息机制而非共享内存作为通信方式。

消息机制认为每个并发单元是自包含的、独立的个体，并且都有自己的变量，但在不同并发单元间这些变量不共享。每个并发单元的输入和输出只有一种，那就是消息。这有点类似于进程的概念，每个进程不会被其他进程打扰，它只做好自己的工作就可以了。不同进程间靠消息来通信，它们不会共享内存。

Go语言提供的消息通信机制被称为 channel，关于 channel 的介绍将在后续的学习中为大家讲解。

### 4. 竞争状态简述

有并发，就有资源竞争，如果两个或者多个 goroutine 在没有相互同步的情况下，访问某个共享的资源，比如同时对该资源进行读写时，就会处于相互竞争的状态，这就是并发中的资源竞争。

并发本身并不复杂，但是因为有了资源竞争的问题，就使得我们开发出好的并发程序变得复杂起来，因为会引起很多莫名其妙的问题。

下面的代码中就会出现竞争状态：

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
)
var (
    count int32
    wg    sync.WaitGroup
)
func main() {
    wg.Add(2)
    go incCount()
    go incCount()
    wg.Wait()
    fmt.Println(count)
}
func incCount() {
    defer wg.Done()
    for i := 0; i < 2; i++ {
        value := count
        runtime.Gosched()
        value++
        count = value
    }
}
```

这是一个资源竞争的例子，大家可以将程序多运行几次，会发现结果可能是 2，也可以是 3，还可能是 4。这是因为 count 变量没有任何同步保护，所以两个 goroutine 都会对其进行读写，会导致对已经计算好的结果被覆盖，以至于产生错误结果。

代码中的 runtime.Gosched() 是让当前 goroutine 暂停的意思，退回执行队列，让其他等待的 goroutine 运行，目的是为了使资源竞争的结果更明显。

下面我们来分析一下程序的运行过程，将两个 goroutine 分别假设为 g1 和 g2：

- g1 读取到 count 的值为 0；
- 然后 g1 暂停了，切换到 g2 运行，g2 读取到 count 的值也为 0；
- g2 暂停，切换到 g1，g1 对 count+1，count 的值变为 1；
- g1 暂停，切换到 g2，g2 刚刚已经获取到值 0，对其 +1，最后赋值给 count，其结果还是 1；
- 可以看出 g1 对 count+1 的结果被 g2 给覆盖了，两个 goroutine 都 +1 而结果还是 1。


通过上面的分析可以看出，之所以出现上面的问题，是因为两个 goroutine 相互覆盖结果。

所以我们对于同一个资源的读写必须是原子化的，也就是说，同一时间只能允许有一个 goroutine 对共享资源进行读写操作。

共享资源竞争的问题，非常复杂，并且难以察觉，好在 Go 为我们提供了一个工具帮助我们检查，这个就是`go build -race `命令。在项目目录下执行这个命令，生成一个可以执行文件，然后再运行这个可执行文件，就可以看到打印出的检测信息。

在`go build`命令中多加了一个`-race `标志，这样生成的可执行程序就自带了检测资源竞争的功能，运行生成的可执行文件，效果如下所示：

```go
==================
WARNING: DATA RACE
Read at 0x000000619cbc by goroutine 8:
 main.incCount()
   D:/code/src/main.go:25 +0x80

Previous write at 0x000000619cbc by goroutine 7:
 main.incCount()
   D:/code/src/main.go:28 +0x9f

Goroutine 8 (running) created at:
 main.main()
   D:/code/src/main.go:17 +0x7e

Goroutine 7 (finished) created at:
 main.main()
   D:/code/src/main.go:16 +0x66
==================
4
Found 1 data race(s)
```

通过运行结果可以看出 goroutine 8 在代码 25 行读取共享资源`value := count`，而这时 goroutine 7 在代码 28 行修改共享资源`count = value`，而这两个 goroutine 都是从 main 函数的 16、17 行通过 go 关键字启动的。

#### 锁住共享资源

Go语言提供了传统的同步 goroutine 的机制，就是对共享资源加锁。atomic 和 sync 包里的一些函数就可以对共享的资源进行加锁操作。

##### 原子函数

原子函数能够以很底层的加锁机制来同步访问整型变量和指针，示例代码如下所示：

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
)
var (
    counter int64
    wg      sync.WaitGroup
)
func main() {
    wg.Add(2)
    go incCounter(1)
    go incCounter(2)
    wg.Wait() //等待goroutine结束
    fmt.Println(counter)
}
func incCounter(id int) {
    defer wg.Done()
    for count := 0; count < 2; count++ {
        atomic.AddInt64(&counter, 1) //安全的对counter加1
        runtime.Gosched()
    }
}
```

上述代码中使用了 atmoic 包的 AddInt64 函数，这个函数会同步整型值的加法，方法是强制同一时刻只能有一个 gorountie 运行并完成这个加法操作。当 goroutine 试图去调用任何原子函数时，这些 goroutine 都会自动根据所引用的变量做同步处理。

另外两个有用的原子函数是 LoadInt64 和 StoreInt64。这两个函数提供了一种安全地读和写一个整型值的方式。下面是代码就使用了 LoadInt64 和 StoreInt64 函数来创建一个同步标志，这个标志可以向程序里多个 goroutine 通知某个特殊状态。

```go
package main
import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)
var (
    shutdown int64
    wg       sync.WaitGroup
)
func main() {
    wg.Add(2)
    go doWork("A")
    go doWork("B")
    time.Sleep(1 * time.Second)
    fmt.Println("Shutdown Now")
    atomic.StoreInt64(&shutdown, 1)
    wg.Wait()
}
func doWork(name string) {
    defer wg.Done()
    for {
        fmt.Printf("Doing %s Work\n", name)
        time.Sleep(250 * time.Millisecond)
        if atomic.LoadInt64(&shutdown) == 1 {
            fmt.Printf("Shutting %s Down\n", name)
            break
        }
    }
}
```

上面代码中 main 函数使用 StoreInt64 函数来安全地修改 shutdown 变量的值。如果哪个 doWork goroutine 试图在 main 函数调用 StoreInt64 的同时调用 LoadInt64 函数，那么原子函数会将这些调用互相同步，保证这些操作都是安全的，不会进入竞争状态。

##### 互斥锁

另一种同步访问共享资源的方式是使用互斥锁，互斥锁这个名字来自互斥的概念。互斥锁用于在代码上创建一个临界区，保证同一时间只有一个 goroutine 可以执行这个临界代码。

示例代码如下所示：

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
)
var (
    counter int64
    wg      sync.WaitGroup
    mutex   sync.Mutex
)
func main() {
    wg.Add(2)
    go incCounter(1)
    go incCounter(2)
    wg.Wait()
    fmt.Println(counter)
}
func incCounter(id int) {
    defer wg.Done()
    for count := 0; count < 2; count++ {
        //同一时刻只允许一个goroutine进入这个临界区
        mutex.Lock()
        {
            value := counter
            runtime.Gosched()
            value++
            counter = value
        }
        mutex.Unlock() //释放锁，允许其他正在等待的goroutine进入临界区
    }
}
```

同一时刻只有一个 goroutine 可以进入临界区。之后直到调用 Unlock 函数之后，其他 goroutine 才能进去临界区。当调用 runtime.Gosched 函数强制将当前 goroutine 退出当前线程后，调度器会再次分配这个 goroutine 继续运行。

### 5. GOMAXPROCS（调整并发的运行性能）

在 Go语言程序运行时（runtime）实现了一个小型的任务调度器。这套调度器的工作原理类似于操作系统调度线程，Go 程序调度器可以高效地将 CPU 资源分配给每一个任务。传统逻辑中，开发者需要维护线程池中线程与 CPU 核心数量的对应关系。同样的，Go 地中也可以通过 runtime.GOMAXPROCS() 函数做到，格式为：

```go
runtime.GOMAXPROCS(逻辑CPU数量)
```

这里的逻辑CPU数量可以有如下几种数值：

- <1：不修改任何数值。
- =1：单核心执行。
- \>1：多核并发执行。


一般情况下，可以使用 runtime.NumCPU() 查询 CPU 数量，并使用 runtime.GOMAXPROCS() 函数进行设置，例如：

```go
runtime.GOMAXPROCS(runtime.NumCPU())
```

Go 1.5 版本之前，默认使用的是单核心执行。从 Go 1.5 版本开始，默认执行上面语句以便让代码并发执行，最大效率地利用 CPU。

GOMAXPROCS 同时也是一个环境变量，在应用程序启动前设置环境变量也可以起到相同的作用。

### 6. 并发和并行的区别

在讲解并发概念时，总会涉及另外一个概念并行。下面让我们来了解并发和并行之间的区别。

- 并发（concurrency）：把任务在不同的时间点交给处理器进行处理。在同一时间点，任务并不会同时运行。
- 并行（parallelism）：把每一个任务分配给每一个处理器独立完成。在同一时间点，任务一定是同时运行。


并发不是并行。并行是让不同的代码片段同时在不同的物理处理器上执行。并行的关键是同时做很多事情，而并发是指同时管理很多事情，这些事情可能只做了一半就被暂停去做别的事情了。

在很多情况下，并发的效果比并行好，因为操作系统和硬件的总资源一般很少，但能支持系统同时做很多事情。这种“使用较少的资源做更多的事情”的哲学，也是指导 Go语言设计的哲学。

如果希望让 goroutine 并行，必须使用多于一个逻辑处理器。当有多个逻辑处理器时，调度器会将 goroutine 平等分配到每个逻辑处理器上。这会让 goroutine 在不同的线程上运行。不过要想真的实现并行的效果，用户需要让自己的程序运行在有多个物理处理器的机器上。否则，哪怕 Go语言运行时使用多个线程，goroutine 依然会在同一个物理处理器上并发运行，达不到并行的效果。

下图展示了在一个逻辑处理器上并发运行 goroutine 和在两个逻辑处理器上并行运行两个并发的 goroutine 之间的区别。调度器包含一些聪明的算法，这些算法会随着 Go语言的发布被更新和改进，所以不推荐盲目修改语言运行时对逻辑处理器的默认设置。如果真的认为修改逻辑处理器的数量可以改进性能，也可以对语言运行时的参数进行细微调整。



![并发与并行的区别](http://c.biancheng.net/uploads/allimg/190704/4-1ZF41J6093P.gif)
图：并发与并行的区别


Go语言在 GOMAXPROCS 数量与任务数量相等时，可以做到并行执行，但一般情况下都是并发执行。

### 7. goroutine和coroutine的区别

[C#](http://c.biancheng.net/csharp/)、Lua、[Python](http://c.biancheng.net/python/) 语言都支持 coroutine 特性。coroutine 与 goroutine 在名字上类似，都可以将函数或者语句在独立的环境中运行，但是它们之间有两点不同：

- goroutine 可能发生并行执行；
- 但 coroutine 始终顺序执行。


goroutines 意味着并行（或者可以以并行的方式部署），coroutines 一般来说不是这样的，goroutines 通过通道来通信；coroutines 通过让出和恢复操作来通信，goroutines 比 coroutines 更强大，也很容易从 coroutines 的逻辑复用到 goroutines。

狭义地说，goroutine 可能发生在多线程环境下，goroutine 无法控制自己获取高优先度支持；coroutine 始终发生在单线程，coroutine 程序需要主动交出控制权，宿主才能获得控制权并将控制权交给其他 coroutine。

goroutine 间使用 channel 通信，coroutine 使用 yield 和 resume 操作。

goroutine 和 coroutine 的概念和运行机制都是脱胎于早期的操作系统。

coroutine 的运行机制属于协作式任务处理，早期的操作系统要求每一个应用必须遵守操作系统的任务处理规则，应用程序在不需要使用 CPU 时，会主动交出 CPU 使用权。如果开发者无意间或者故意让应用程序长时间占用 CPU，操作系统也无能为力，表现出来的效果就是计算机很容易失去响应或者死机。

goroutine 属于抢占式任务处理，已经和现有的多线程和多进程任务处理非常类似。应用程序对 CPU 的控制最终还需要由操作系统来管理，操作系统如果发现一个应用程序长时间大量地占用 CPU，那么用户有权终止这个任务。

### 8. 通道（chan）——goroutine之间通信的管道

如果说 goroutine 是 Go语言程序的并发体的话，那么 channels 就是它们之间的通信机制。一个 channels 是一个通信机制，它可以让一个 goroutine 通过它给另一个 goroutine 发送值信息。每个 channel 都有一个特殊的类型，也就是 channels 可发送数据的类型。一个可以发送 int 类型数据的 channel 一般写为 chan int。

Go语言提倡使用通信的方法代替共享内存，当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。声明通道时，需要指定将要被共享的数据的类型。可以通过通道共享内置类型、命名类型、结构类型和引用类型的值或者指针。

这里通信的方法就是使用通道（channel），如下图所示。



![img](http://c.biancheng.net/uploads/allimg/180817/1-1PQG035203K.jpg)
图：goroutine 与 channel 的通信


在地铁站、食堂、洗手间等公共场所人很多的情况下，大家养成了排队的习惯，目的也是避免拥挤、插队导致的低效的资源使用和交换过程。代码与数据也是如此，多个 goroutine 为了争抢数据，势必造成执行的低效率，使用队列的方式是最高效的，channel 就是一种队列一样的结构。

##### 通道的特性

Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。

通道像一个传送带或者队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。

#### 声明通道类型

通道本身需要一个类型进行修饰，就像切片类型需要标识元素类型。通道的元素类型就是在其内部传输的数据类型，声明如下：

```go
var 通道变量 chan 通道类型
```

- 通道类型：通道内的数据类型。
- 通道变量：保存通道的变量。


chan 类型的空值是 nil，声明后需要配合 make 后才能使用。

#### 创建通道

通道是引用类型，需要使用 make 进行创建，格式如下：

```go
通道实例 := make(chan 数据类型)
```

- 数据类型：通道内传输的元素类型。
- 通道实例：通过make创建的通道句柄。


请看下面的例子：

```go
ch1 := make(chan int)                 // 创建一个整型类型的通道
ch2 := make(chan interface{})         // 创建一个空接口类型的通道, 可以存放任意格式
type Equip struct{ /* 一些字段 */ }
ch2 := make(chan *Equip)             // 创建Equip指针类型的通道, 可以存放*Equip
```

#### 使用通道发送数据

通道创建后，就可以使用通道进行发送和接收操作。

##### 1) 通道发送数据的格式

通道的发送使用特殊的操作符`<-`，将数据通过通道发送的格式为：

```go
通道变量 <- 值
```

- 通道变量：通过make创建好的通道实例。
- 值：可以是变量、常量、表达式或者函数返回值等。值的类型必须与ch通道的元素类型一致。

##### 2) 通过通道发送数据的例子

使用 make 创建一个通道后，就可以使用`<-`向通道发送数据，代码如下：

```go
// 创建一个空接口通道
ch := make(chan interface{})
// 将0放入通道中
ch <- 0
// 将hello字符串放入通道中
ch <- "hello"
```

##### 3) 发送将持续阻塞直到数据被接收

把数据往通道中发送时，如果接收方一直都没有接收，那么发送操作将持续阻塞。Go 程序运行时能智能地发现一些永远无法发送成功的语句并做出提示，代码如下：

```go
package main
func main() {
    // 创建一个整型通道
    ch := make(chan int)
    // 尝试将0通过通道发送
    ch <- 0
}
```

运行代码，报错：

```go
fatal error: all goroutines are asleep - deadlock!
```

报错的意思是：运行时发现所有的 goroutine（包括main）都处于等待 goroutine。也就是说所有 goroutine 中的 channel 并没有形成发送和接收对应的代码。

#### 使用通道接收数据

通道接收同样使用`<-`操作符，通道接收有如下特性：
① 通道的收发操作在不同的两个 goroutine 间进行。

由于通道的数据在没有接收方处理时，数据发送方会持续阻塞，因此通道的接收必定在另外一个 goroutine 中进行。

② 接收将持续阻塞直到发送方发送数据。

如果接收方接收时，通道中没有发送方发送数据，接收方也会发生阻塞，直到发送方发送数据为止。

③ 每次接收一个元素。
通道一次只能接收一个数据元素。

通道的数据接收一共有以下 4 种写法。

##### 1) 阻塞接收数据

阻塞模式接收数据时，将接收变量作为`<-`操作符的左值，格式如下：

```go
data := <-ch
```

执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。

##### 2) 非阻塞接收数据

使用非阻塞方式从通道接收数据时，语句不会发生阻塞，格式如下：

```go
data, ok := <-ch
```

- data：表示接收到的数据。未接收到数据时，data 为通道类型的零值。
- ok：表示是否接收到数据。


非阻塞的通道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，可以参见后面的内容。

##### 3) 接收任意数据，忽略接收的数据

阻塞接收数据后，忽略从通道返回的数据，格式如下：

```go
<-ch
```

执行该语句时将会发生阻塞，直到接收到数据，但接收到的数据会被忽略。这个方式实际上只是通过通道在 goroutine 间阻塞收发实现并发同步。

使用通道做并发同步的写法，可以参考下面的例子：

```go
package main
import (
    "fmt"
)
func main() {
    // 构建一个通道
    ch := make(chan int)
    // 开启一个并发匿名函数
    go func() {
        fmt.Println("start goroutine")
        // 通过通道通知main的goroutine
        ch <- 0
        fmt.Println("exit goroutine")
    }()
    fmt.Println("wait goroutine")
    // 等待匿名goroutine
    <-ch
    fmt.Println("all done")
}
```

执行代码，输出如下：

```go
wait goroutine
start goroutine
exit goroutine
all done
```

代码说明如下：

- 第 10 行，构建一个同步用的通道。
- 第 13 行，开启一个匿名函数的并发。
- 第 18 行，匿名 goroutine 即将结束时，通过通道通知 main 的 goroutine，这一句会一直阻塞直到 main 的 goroutine 接收为止。
- 第 27 行，开启 goroutine 后，马上通过通道等待匿名 goroutine 结束。

##### 4) 循环接收

通道的数据接收可以借用 for range 语句进行多个元素的接收操作，格式如下：

```go
for data := range ch {
}
```

通道 ch 是可以进行遍历的，遍历的结果就是接收到的数据。数据类型就是通道的数据类型。通过 for 遍历获得的变量只有一个，即上面例子中的 data。

遍历通道数据的例子请参考下面的代码。

使用 for 从通道中接收数据：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    // 构建一个通道
    ch := make(chan int)
    // 开启一个并发匿名函数
    go func() {
        // 从3循环到0
        for i := 3; i >= 0; i-- {
            // 发送3到0之间的数值
            ch <- i
            // 每次发送完时等待
            time.Sleep(time.Second)
        }
    }()
    // 遍历接收通道数据
    for data := range ch {
        // 打印通道数据
        fmt.Println(data)
        // 当遇到数据0时, 退出接收循环
        if data == 0 {
                break
        }
    }
}
```

执行代码，输出如下：

```go
3
2
1
0
```

代码说明如下：

- 第 12 行，通过 make 生成一个整型元素的通道。
- 第 15 行，将匿名函数并发执行。
- 第 18 行，用循环生成 3 到 0 之间的数值。
- 第 21 行，将 3 到 0 之间的数值依次发送到通道 ch 中。
- 第 24 行，每次发送后暂停 1 秒。
- 第 30 行，使用 for 从通道中接收数据。
- 第 33 行，将接收到的数据打印出来。
- 第 36 行，当接收到数值 0 时，停止接收。如果继续发送，由于接收 goroutine 已经退出，没有 goroutine 发送到通道，因此运行时将会触发宕机报错。

### 9. 并发打印（借助通道实现）

前面的例子创建的都是无缓冲通道。使用无缓冲通道往里面装入数据时，装入方将被阻塞，直到另外通道在另外一个 goroutine 中被取出。同样，如果通道中没有放入任何数据，接收方试图从通道中获取数据时，同样也是阻塞。发送和接收的操作是同步完成的。

下面通过一个并发打印的例子，将 goroutine 和 channel 放在一起展示它们的用法。

```go
package main
import (
    "fmt"
)
func printer(c chan int) {
    // 开始无限循环等待数据
    for {
        // 从channel中获取一个数据
        data := <-c
        // 将0视为数据结束
        if data == 0 {
            break
        }
        // 打印数据
        fmt.Println(data)
    }
    // 通知main已经结束循环(我搞定了!)
    c <- 0
}
func main() {
    // 创建一个channel
    c := make(chan int)
    // 并发执行printer, 传入channel
    go printer(c)
    for i := 1; i <= 10; i++ {
        // 将数据通过channel投送给printer
        c <- i
    }
    // 通知并发的printer结束循环(没数据啦!)
    c <- 0
    // 等待printer结束(搞定喊我!)
    <-c
}
```

运行代码，输出如下：

```go
1
2
3
4
5
6
7
8
9
10
```

代码说明如下：

- 第 10 行，创建一个无限循环，只有当第 16 行获取到的数据为 0 时才会退出循环。
- 第 13 行，从函数参数传入的通道中获取一个整型数值。
- 第 21 行，打印整型数值。
- 第 25 行，在退出循环时，通过通道通知 main() 函数已经完成工作。
- 第 32 行，创建一个整型通道进行跨 goroutine 的通信。
- 第 35 行，创建一个 goroutine，并发执行 printer() 函数。
- 第 37 行，构建一个数值循环，将 1～10 的数通过通道传送给 printer 构造出的 goroutine。
- 第 44 行，给通道传入一个 0，表示将前面的数据处理完成后，退出循环。
- 第 47 行，在数据发送过去后，因为并发和调度的原因，任务会并发执行。这里需要等待 printer 的第 25 行返回数据后，才可以退出 main()。


本例的[设计模式](http://c.biancheng.net/design_pattern/)就是典型的生产者和消费者。生产者是第 37 行的循环，而消费者是 printer() 函数。整个例子使用了两个 goroutine，一个是 main()，一个是通过第 35 行 printer() 函数创建的 goroutine。两个 goroutine 通过第 32 行创建的通道进行通信。这个通道有下面两重功能。

- 数据传送：第 40 行中发送数据和第 13 行接收数据。
- 控制指令：类似于信号量的功能。同步 goroutine 的操作。功能简单描述为：
    - 第 44 行：“没数据啦！”
    - 第 25 行：“我搞定了！”
    - 第 47 行：“搞定喊我！”

### 10. 单向通道——通道中的单行道

Go语言的类型系统提供了单方向的 channel 类型，顾名思义，单向 channel 就是只能用于写入或者只能用于读取数据。当然 channel 本身必然是同时支持读写的，否则根本没法用。

假如一个 channel 真的只能读取数据，那么它肯定只会是空的，因为你没机会往里面写数据。同理，如果一个 channel 只允许写入数据，即使写进去了，也没有丝毫意义，因为没有办法读取到里面的数据。所谓的单向 channel 概念，其实只是对 channel 的一种使用限制。

#### 单向通道的声明格式

我们在将一个 channel 变量传递到一个函数时，可以通过将其指定为单向 channel 变量，从而限制该函数中可以对此 channel 的操作，比如只能往这个 channel 中写入数据，或者只能从这个 channel 读取数据。

单向 channel 变量的声明非常简单，只能写入数据的通道类型为`chan<-`，只能读取数据的通道类型为`<-chan`，格式如下：

```go
var 通道实例 chan<- 元素类型   // 只能写入数据的通道
var 通道实例 <-chan 元素类型   // 只能读取数据的通道
```

- 元素类型：通道包含的元素类型。
- 通道实例：声明的通道变量。

#### 单向通道的使用例子

示例代码如下：

```go
ch := make(chan int)
// 声明一个只能写入数据的通道类型, 并赋值为ch
var chSendOnly chan<- int = ch
//声明一个只能读取数据的通道类型, 并赋值为ch
var chRecvOnly <-chan int = ch
```

上面的例子中，chSendOnly 只能写入数据，如果尝试读取数据，将会出现如下报错：

```go
invalid operation: <-chSendOnly (receive from send-only type chan<- int)
```

同理，chRecvOnly 也是不能写入数据的。

当然，使用 make 创建通道时，也可以创建一个只写入或只读取的通道：

```go
ch := make(<-chan int)
var chReadOnly <-chan int = ch
<-chReadOnly
```

上面代码编译正常，运行也是正确的。但是，一个不能写入数据只能读取的通道是毫无意义的。

#### time包中的单向通道

time 包中的计时器会返回一个 timer 实例，代码如下：

```go
timer := time.NewTimer(time.Second)
```

timer的Timer类型定义如下：

```go
type Timer struct {
    C <-chan Time
    r runtimeTimer
}
```

第 2 行中 C 通道的类型就是一种只能读取的单向通道。如果此处不进行通道方向约束，一旦外部向通道写入数据，将会造成其他使用到计时器的地方逻辑产生混乱。

因此，单向通道有利于代码接口的严谨性。

#### 关闭 channel

关闭 channel 非常简单，直接使用Go语言内置的 close() 函数即可：

```go
close(ch)
```

在介绍了如何关闭 channel 之后，我们就多了一个问题：如何判断一个 channel 是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：

```go
x, ok := <-ch
```

这个用法与 map 中的按键获取 value 的过程比较类似，只需要看第二个 bool 返回值即可，如果返回值是 false 则表示 ch 已经被关闭。

### 11. 无缓冲的通道

Go语言中无缓冲的通道（unbuffered channel）是指在接收前没有能力保存任何值的通道。这种类型的通道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。

如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。

阻塞指的是由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。

同步指的是在两个或多个协程（线程）之间，保持数据内容一致性的机制。

下图展示两个 goroutine 如何利用无缓冲的通道来共享一个值。



![使用无缓冲的通道在 goroutine 之间同步](http://c.biancheng.net/uploads/allimg/190705/4-1ZF516244I59.gif)
图：使用无缓冲的通道在 goroutine 之间同步


在第 1 步，两个 goroutine 都到达通道，但哪个都没有开始执行发送或者接收。在第 2 步，左侧的 goroutine 将它的手伸进了通道，这模拟了向通道发送数据的行为。这时，这个 goroutine 会在通道中被锁住，直到交换完成。

在第 3 步，右侧的 goroutine 将它的手放入通道，这模拟了从通道里接收数据。这个 goroutine 一样也会在通道中被锁住，直到交换完成。在第 4 步和第 5 步，进行交换，并最终在第 6 步，两个 goroutine 都将它们的手从通道里拿出来，这模拟了被锁住的 goroutine 得到释放。两个 goroutine 现在都可以去做别的事情了。

为了讲得更清楚，让我们来看两个完整的例子。这两个例子都会使用无缓冲的通道在两个 goroutine 之间同步交换数据。

【示例 1】在网球比赛中，两位选手会把球在两个人之间来回传递。选手总是处在以下两种状态之一，要么在等待接球，要么将球打向对方。可以使用两个 goroutine 来模拟网球比赛，并使用无缓冲的通道来模拟球的来回，代码如下所示。

```go
// 这个示例程序展示如何用无缓冲的通道来模拟
// 2 个goroutine 间的网球比赛
package main
import (
    "fmt"
    "math/rand"
    "sync"
    "time"
)
// wg 用来等待程序结束
var wg sync.WaitGroup
func init() {
    rand.Seed(time.Now().UnixNano())
}
// main 是所有Go 程序的入口
func main() {
    // 创建一个无缓冲的通道
    court := make(chan int)
    // 计数加 2，表示要等待两个goroutine
    wg.Add(2)
    // 启动两个选手
    go player("Nadal", court)
    go player("Djokovic", court)
    // 发球
    court <- 1
    // 等待游戏结束
    wg.Wait()
}
// player 模拟一个选手在打网球
func player(name string, court chan int) {
    // 在函数退出时调用Done 来通知main 函数工作已经完成
    defer wg.Done()
    for {
        // 等待球被击打过来
        ball, ok := <-court
        if !ok {
            // 如果通道被关闭，我们就赢了
            fmt.Printf("Player %s Won\n", name)
            return
        }
        // 选随机数，然后用这个数来判断我们是否丢球
        n := rand.Intn(100)
        if n%13 == 0 {
            fmt.Printf("Player %s Missed\n", name)
            // 关闭通道，表示我们输了
            close(court)
            return
        }
        // 显示击球数，并将击球数加1
        fmt.Printf("Player %s Hit %d\n", name, ball)
        ball++
        // 将球打向对手
        court <- ball
    }
}
```

运行这个程序，输出结果如下所示。

```go
Player Nadal Hit 1
Player Djokovic Hit 2
Player Nadal Hit 3
Player Djokovic Missed
Player Nadal Won
```

代码说明如下：

- 第 22 行，创建了一个 int 类型的无缓冲的通道，让两个 goroutine 在击球时能够互相同步。
- 第 28 行和第 29 行，创建了参与比赛的两个 goroutine。在这个时候，两个 goroutine 都阻塞住等待击球。
- 第 32 行，将球发到通道里，程序开始执行这个比赛，直到某个 goroutine 输掉比赛。
- 第 43 行可以找到一个无限循环的 for 语句。在这个循环里，是玩游戏的过程。
- 第 45 行，goroutine 从通道接收数据，用来表示等待接球。这个接收动作会锁住 goroutine，直到有数据发送到通道里。通道的接收动作返回时。
- 第 46 行会检测 ok 标志是否为 false。如果这个值是 false，表示通道已经被关闭，游戏结束。
- 第 53 行到第 60 行，会产生一个随机数，用来决定 goroutine 是否击中了球。
- 第 58 行如果某个 goroutine 没有打中球，关闭通道。之后两个 goroutine 都会返回，通过 defer 声明的 Done 会被执行，程序终止。
- 第 64 行，如果击中了球 ball 的值会递增 1，并在第 67 行，将 ball 作为球重新放入通道，发送给另一位选手。在这个时刻，两个 goroutine 都会被锁住，直到交换完成。


【示例 2】用不同的模式，使用无缓冲的通道，在 goroutine 之间同步数据，来模拟接力比赛。在接力比赛里，4 个跑步者围绕赛道轮流跑。第二个、第三个和第四个跑步者要接到前一位跑步者的接力棒后才能起跑。比赛中最重要的部分是要传递接力棒，要求同步传递。在同步接力棒的时候，参与接力的两个跑步者必须在同一时刻准备好交接。代码如下所示。

```go
// 这个示例程序展示如何用无缓冲的通道来模拟
// 4 个goroutine 间的接力比赛
package main
import (
    "fmt"
    "sync"
    "time"
)
// wg 用来等待程序结束
var wg sync.WaitGroup
// main 是所有Go 程序的入口
func main() {
    // 创建一个无缓冲的通道
    baton := make(chan int)
    // 为最后一位跑步者将计数加1
    wg.Add(1)
    // 第一位跑步者持有接力棒
    go Runner(baton)
    // 开始比赛
    baton <- 1
    // 等待比赛结束
    wg.Wait()
}
// Runner 模拟接力比赛中的一位跑步者
func Runner(baton chan int) {
    var newRunner int
    // 等待接力棒
    runner := <-baton
    // 开始绕着跑道跑步
    fmt.Printf("Runner %d Running With Baton\n", runner)
    // 创建下一位跑步者
    if runner != 4 {
        newRunner = runner + 1
        fmt.Printf("Runner %d To The Line\n", newRunner)
        go Runner(baton)
    }
    // 围绕跑道跑
    time.Sleep(100 * time.Millisecond)
    // 比赛结束了吗？
    if runner == 4 {
        fmt.Printf("Runner %d Finished, Race Over\n", runner)
        wg.Done()
        return
    }
    // 将接力棒交给下一位跑步者
    fmt.Printf("Runner %d Exchange With Runner %d\n",
        runner,
        newRunner)
    baton <- newRunner
}
```

运行这个程序，输出结果如下所示。

```go
Runner 1 Running With Baton
Runner 1 To The Line
Runner 1 Exchange With Runner 2
Runner 2 Running With Baton
Runner 2 To The Line
Runner 2 Exchange With Runner 3
Runner 3 Running With Baton
Runner 3 To The Line
Runner 3 Exchange With Runner 4
Runner 4 Running With Baton
Runner 4 Finished, Race Over
```

代码说明如下：

- 第 17 行，创建了一个无缓冲的 int 类型的通道 baton，用来同步传递接力棒。
- 第 20 行，我们给 WaitGroup 加 1，这样 main 函数就会等最后一位跑步者跑步结束。
- 第 23 行创建了一个 goroutine，用来表示第一位跑步者来到跑道。
- 第 26 行，将接力棒交给这个跑步者，比赛开始。
- 第 29 行，main 函数阻塞在 WaitGroup，等候最后一位跑步者完成比赛。
- 第 37 行，goroutine 对 baton 通道执行接收操作，表示等候接力棒。
- 第 46 行，一旦接力棒传了进来，就会创建一位新跑步者，准备接力下一棒，直到 goroutine 是第四个跑步者。
- 第 50 行，跑步者围绕跑道跑 100 ms。
- 第 55 行，如果第四个跑步者完成了比赛，就调用 Done，将 WaitGroup 减 1，之后 goroutine 返回。
- 第 64 行，如果这个 goroutine 不是第四个跑步者，接力棒会交到下一个已经在等待的跑步者手上。在这个时候，goroutine 会被锁住，直到交接完成。


在这两个例子里，我们使用无缓冲的通道同步 goroutine，模拟了网球和接力赛。代码的流程与这两个活动在真实世界中的流程完全一样，这样的代码很容易读懂。

现在知道了无缓冲的通道是如何工作的，下一节我们将为大家介绍带缓冲的通道。

### 12. 带缓冲的通道

Go语言中有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。

这导致有缓冲的通道和无缓冲的通道之间的一个很大的不同：无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换；有缓冲的通道没有这种保证。

在无缓冲通道的基础上，为通道增加一个有限大小的存储空间形成带缓冲通道。带缓冲通道在发送时无需等待接收方接收即可完成发送过程，并且不会发生阻塞，只有当存储空间满时才会发生阻塞。同理，如果缓冲通道中有数据，接收时将不会发生阻塞，直到通道中没有数据可读时，通道将会再度阻塞。

无缓冲通道保证收发过程同步。无缓冲收发过程类似于快递员给你电话让你下楼取快递，整个递交快递的过程是同步发生的，你和快递员不见不散。但这样做快递员就必须等待所有人下楼完成操作后才能完成所有投递工作。如果快递员将快递放入快递柜中，并通知用户来取，快递员和用户就成了异步收发过程，效率可以有明显的提升。带缓冲的通道就是这样的一个“快递柜”。

#### 创建带缓冲通道

如何创建带缓冲的通道呢？参见如下代码：

通道实例 := make(chan 通道类型, 缓冲大小)

- 通道类型：和无缓冲通道用法一致，影响通道发送和接收的数据类型。
- 缓冲大小：决定通道最多可以保存的元素数量。
- 通道实例：被创建出的通道实例。


下面通过一个例子中来理解带缓冲通道的用法，参见下面的代码：

```go
package main
import "fmt"
func main() {
    // 创建一个3个元素缓冲大小的整型通道
    ch := make(chan int, 3)
    // 查看当前通道的大小
    fmt.Println(len(ch))
    // 发送3个整型元素到通道
    ch <- 1
    ch <- 2
    ch <- 3
    // 查看当前通道的大小
    fmt.Println(len(ch))
}
```

代码输出如下：

```go
0
3
```

代码说明如下：

- 第 8 行，创建一个带有 3 个元素缓冲大小的整型类型的通道。
- 第 11 行，查看当前通道的大小。带缓冲的通道在创建完成时，内部的元素是空的，因此使用 len() 获取到的返回值为 0。
- 第 14～16 行，发送 3 个整型元素到通道。因为使用了缓冲通道。即便没有 goroutine 接收，发送者也不会发生阻塞。
- 第 19 行，由于填充了 3 个通道，此时的通道长度变为 3。

#### 阻塞条件

带缓冲通道在很多特性上和无缓冲通道是类似的。无缓冲通道可以看作是长度永远为 0 的带缓冲通道。因此根据这个特性，带缓冲通道在下面列举的情况下依然会发生阻塞：

- 带缓冲通道被填满时，尝试再次发送数据时发生阻塞。
- 带缓冲通道为空时，尝试接收数据时发生阻塞。

##### 为什么Go语言对通道要限制长度而不提供无限长度的通道？

我们知道通道（channel）是在两个 goroutine 间通信的桥梁。使用 goroutine 的代码必然有一方提供数据，一方消费数据。当提供数据一方的数据供给速度大于消费方的数据处理速度时，如果通道不限制长度，那么内存将不断膨胀直到应用崩溃。因此，限制通道的长度有利于约束数据提供方的供给速度，供给数据量必须在消费方处理量+通道长度的范围内，才能正常地处理数据。

### 13. channel超时机制

Go语言没有提供直接的超时处理机制，所谓超时可以理解为当我们上网浏览一些网站时，如果一段时间之后不作操作，就需要重新登录。

那么我们应该如何实现这一功能呢，这时就可以使用 select 来设置超时。

虽然 select 机制不是专门为超时而设计的，却能很方便的解决超时问题，因为 select 的特点是只要其中有一个 case 已经完成，程序就会继续往下执行，而不会考虑其他 case 的情况。

超时机制本身虽然也会带来一些问题，比如在运行比较快的机器或者高速的网络上运行正常的程序，到了慢速的机器或者网络上运行就会出问题，从而出现结果不一致的现象，但从根本上来说，解决死锁问题的价值要远大于所带来的问题。

select 的用法与 switch 语言非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。

与 switch 语句相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致的结构如下：

```go
select {
  case <-chan1:
  // 如果chan1成功读到数据，则进行该case处理语句
  case chan2 <- 1:
  // 如果成功向chan2写入数据，则进行该case处理语句
  default:
  // 如果上面都没有成功，则进入default处理流程
}
```

在一个 select 语句中，Go语言会按顺序从头至尾评估每一个发送和接收的语句。

如果其中的任意一语句可以继续执行（即没有被阻塞），那么就从那些可以执行的语句中任意选择一条来使用。

如果没有任意一条语句可以执行（即所有的通道都被阻塞），那么有如下两种可能的情况：

- 如果给出了 default 语句，那么就会执行 default 语句，同时程序的执行会从 select 语句后的语句中恢复；
- 如果没有 default 语句，那么 select 语句将被阻塞，直到至少有一个通信可以进行下去。


示例代码如下所示：

```go
package main
import (
    "fmt"
    "time"
)
func main() {
    ch := make(chan int)
    quit := make(chan bool)
    //新开一个协程
    go func() {
        for {
            select {
            case num := <-ch:
                fmt.Println("num = ", num)
            case <-time.After(3 * time.Second):
                fmt.Println("超时")
                quit <- true
            }
        }
    }() //别忘了()
    for i := 0; i < 5; i++ {
        ch <- i
        time.Sleep(time.Second)
    }
    <-quit
    fmt.Println("程序结束")
}
```

运行结果如下：

```go
num = 0
num = 1
num = 2
num = 3
num = 4
超时
程序结束
```



### 14. 通道的多路复用

多路复用是通信和网络中的一个专业术语。多路复用通常表示在一个信道上传输多路信号或数据流的过程和技术。

#### 提示

报话机同一时刻只能有一边进行收或者发的单边通信，报话机需要遵守的通信流程如下：

- 说话方在完成时需要补上一句 “完毕”，随后放开通话按钮，从发送切换到接收状态，收听对方说话。

- 收听方在听到对方说 “完毕” 时，按下通话按钮，从接收切换到发送状态，开始说话。

电话可以在说话的同时听到对方说话，所以电话是一种多路复用的设备，一条通信线路上可以同时接收或者发送数据。同样的，网线、光纤也都是基于多路复用模式来设计的，网线、光纤不仅可支持同时收发数据，还支持多个人同时收发数据。

在使用通道时，想同时接收多个通道的数据是一件困难的事情。通道在接收数据时，如果没有数据可以接收将会发生阻塞。虽然可以使用如下模式进行遍历，但运行性能会非常差。

```go
  for{
      // 尝试接收ch1通道
      data, ok := <-ch1
      // 尝试接收ch2通道
      data, ok := <-ch2
      // 接收后续通道
      …
  }
```

Go 语言中提供了 select 关键字，可以同时响应多个通道的操作。select 的用法与 switch 语句非常类似，由 select 开始一个新的选择块，每个选择条件由 case 语句来描述。

与 switch 语句可以选择任何可使用相等比较的条件相比，select 有比较多的限制，其中最大的一条限制就是每个 case 语句里必须是一个 IO 操作，大致结构如下：

```go
select{
    case 操作 1:
        响应操作 1
    case 操作 2:
        响应操作 2
    …
    default:
        没有操作情况
}
```

- 操作 1、操作 2：包含通道收发语句，请参考下表。select 多路复用中可以接收的样式 | 操 作 | 语句示例 | | 接收任意数据 | case <- ch; | | 接收变量 | case d := <- ch; | | 发送数据 | case ch <- 100; |

- 响应操作 1、响应操作 2：当操作发生时，会执行对应 case 的响应操作。

- default：当没有任何操作时，默认执行 default 中的语句。

可以看出，select 不像 switch，后面并不带判断条件，而是直接去查看 case 语句。每个 case 语句都必须是一个面向 channel 的操作。

基于此功能，我们可以实现一个有趣的程序：

```go
  ch := make(chan int, 1)
  for {
      select {
          case ch <- 0:
          case ch <- 1:
      }
      i := <-ch
      fmt.Println("Value received:", i)
  }
```

能看明白这段代码的含义吗？其实很简单，这个程序实现了一个随机向 ch 中写入一个 0 或者 1 的过程。当然，这是个死循环。关于 select 的详细使用方法，请参考下节的示例。

### 15. 模拟远程过程调用

服务器开发中会使用 RPC（Remote Procedure Call，远程过程调用）简化进程间通信的过程。RPC 能有效地封装通信过程，让远程的数据收发通信过程看起来就像本地的函数调用一样。

本例中，使用通道代替 Socket 实现 RPC 的过程。客户端与服务器运行在同一个进程，服务器和客户端在两个 goroutine 中运行。

我们先给出完整代码，然后再详细分析每一个部分。

```go
  package main

  import (
      "errors"
      "fmt"
      "time"
  )

  // 模拟RPC客户端的请求和接收消息封装
  func RPCClient(ch chan string, req string) (string, error) {

      // 向服务器发送请求
      ch <- req

      // 等待服务器返回
      select {
      case ack := <-ch: // 接收到服务器返回数据
          return ack, nil
      case <-time.After(time.Second): // 超时
          return "", errors.New("Time out")
      }
  }

  // 模拟RPC服务器端接收客户端请求和回应
  func RPCServer(ch chan string) {
      for {
          // 接收客户端请求
          data := <-ch

          // 打印接收到的数据
          fmt.Println("server received:", data)

          // 反馈给客户端收到
          ch <- "roger"
      }
  }

  func main() {

      // 创建一个无缓冲字符串通道
      ch := make(chan string)

      // 并发执行服务器逻辑
      go RPCServer(ch)

      // 客户端请求数据和接收数据
      recv, err := RPCClient(ch, "hi")
      if err != nil {
          // 发生错误打印
          fmt.Println(err)
      } else {
          // 正常接收到数据
          fmt.Println("client received", recv)
      }

  }
```

#### 客户端请求和接收封装

下面的代码封装了向服务器请求数据，等待服务器返回数据，如果请求方超时，该函数还会处理超时逻辑。

模拟 RPC 的代码：

```go
  // 模拟RPC客户端的请求和接收消息封装
  func RPCClient(ch chan string, req string) (string, error) {

      // 向服务器发送请求
      ch <- req

      // 等待服务器返回
      select {
      case ack := <-ch:  // 接收到服务器返回数据
          return ack, nil
      case <-time.After(time.Second):  // 超时
          return "", errors.New("Time out")
      }
  }
```

代码说明如下：

- 第 5 行，模拟 socket 向服务器发送一个字符串信息。服务器接收后，结束阻塞执行下一行。

- 第 8 行，使用 select 开始做多路复用。注意，select 虽然在写法上和 switch 一样，都可以拥有 case 和 default。但是 select 关键字后面不接任何语句，而是将要复用的多个通道语句写在每一个 case 上，如第 9 行和第 11 行所示。

- 第 11 行，使用了 time 包提供的函数 After()，从字面意思看就是多少时间之后，其参数是 time 包的一个常量，time.Second 表示 1 秒。time.After 返回一个通道，这个通道在指定时间后，通过通道返回当前时间。

- 第 12 行，在超时时，返回超时错误。

RPCClient() 函数中，执行到 select 语句时，第 9 行和第 11 行的通道操作会同时开启。如果第 9 行的通道先返回，则执行第 10 行逻辑，表示正常接收到服务器数据；如果第 11 行的通道先返回，则执行第 12 行的逻辑，表示请求超时，返回错误。

#### 服务器接收和反馈数据

服务器接收到客户端的任意数据后，先打印再通过通道返回给客户端一个固定字符串，表示服务器已经收到请求。

```go
  // 模拟RPC服务器端接收客户端请求和回应
  func RPCServer(ch chan string) {
      for {
          // 接收客户端请求
          data := <-ch

          // 打印接收到的数据
          fmt.Println("server received:", data)

          //向客户端反馈已收到
          ch <- "roger"
      }
  }
```

代码说明如下：

- 第 3 行，构造出一个无限循环。服务器处理完客户端请求后，通过无限循环继续处理下一个客户端请求。

- 第 5 行，通过字符串通道接收一个客户端的请求。

- 第 8 行，将接收到的数据打印出来。

- 第 11 行，给客户端反馈一个字符串。

运行整个程序，客户端可以正确收到服务器返回的数据，客户端 RPCClient() 函数的代码按下面代码中加粗部分的分支执行。

```go
  // 等待服务器返回
  select {
  case ack := <-ch:  // 接收到服务器返回数据
      return ack, nil
  case <-time.After(time.Second):  // 超时
      return "", errors.New("Time out")
  }
```

程序输出如下：

```go
server received: hi client received roger
```

#### 模拟超时

上面的例子虽然有客户端超时处理，但是永远不会触发，因为服务器的处理速度很快，也没有真正的网络延时或者 “服务器宕机” 的情况。因此，为了展示 select 中超时的处理，在服务器逻辑中增加一条语句，故意让服务器延时处理一段时间，造成客户端请求超时，代码如下：

```go
  // 模拟RPC服务器端接收客户端请求和回应
  func RPCServer(ch chan string) {
      for {
          // 接收客户端请求
          data := <-ch

          // 打印接收到的数据
          fmt.Println("server received:", data)

          // 通过睡眠函数让程序执行阻塞2秒的任务
          time.Sleep(time.Second \* 2)

          // 反馈给客户端收到
          ch <- "roger"
      }
  }
```

第 11 行中，time.Sleep() 函数会让 goroutine 执行暂停 2 秒。使用这种方法模拟服务器延时，造成客户端超时。客户端处理超时 1 秒时通道就会返回：

```go
  // 等待服务器返回
  select {
  case ack := <-ch:  // 接收到服务器返回数据
      return ack, nil
  case <-time.After(time.Second):  // 超时
      return "", errors.New("Time out")
  }
```

上面代码中，加黑部分的代码就会被执行。

#### 主流程

主流程中会创建一个无缓冲的字符串格式通道。将通道传给服务器的 RPCServer() 函数，这个函数并发执行。使用 RPCClient() 函数通过 ch 对服务器发出 RPC 请求，同时接收服务器反馈数据或者等待超时。参考下面代码：

```go
  func main() {

      // 创建一个无缓冲字符串通道
      ch := make(chan string)

      // 并发执行服务器逻辑
      go RPCServer(ch)

      // 客户端请求数据和接收数据
      recv, err := RPCClient(ch, "hi")
      if err != nil {
              // 发生错误打印
          fmt.Println(err)
      } else {
              // 正常接收到数据
          fmt.Println("client received", recv)
      }

  }
```

代码说明如下：

- 第 4 行，创建无缓冲的字符串通道，这个通道用于模拟网络和 socke t 概念，既可以从通道接收数据，也可以发送。

- 第 7 行，并发执行服务器逻辑。服务器一般都是独立进程的，这里使用并发将服务器和客户端逻辑同时在一个进程内运行。

- 第 10 行，使用 RPCClient() 函数，发送 “hi” 给服务器，同步等待服务器返回。

- 第 13 行，如果通信过程发生错误，打印错误。

- 第 16 行，正常接收时，打印收到的数据。

### 16. 使用通道响应计时器的事件

Go 语言中的 time 包提供了计时器的封装。由于 Go 语言中的通道和 goroutine 的设计，定时任务可以在 goroutine 中通过同步的方式完成，也可以通过在 goroutine 中异步回调完成。这里将分两种用法进行例子展示。

#### 一段时间之后（time.After）

延迟回调：

```go
  package main

  import (
      "fmt"
      "time"
  )

  func main() {
      // 声明一个退出用的通道
      exit := make(chan int)

      // 打印开始
      fmt.Println("start")

      // 过1秒后, 调用匿名函数
      time.AfterFunc(time.Second, func() {

          // 1秒后, 打印结果
          fmt.Println("one second after")

          // 通知main()的goroutine已经结束
          exit <- 0
      })

      // 等待结束
      <-exit
  }
```

代码说明如下：

- 第 10 行，声明一个退出用的通道，往这个通道里写数据表示退出。

- 第 16 行，调用 time.AfterFunc() 函数，传入等待的时间和一个回调。回调使用一个匿名函数，在时间到达后，匿名函数会在另外一个 goroutine 中被调用。

- 第 22 行，任务完成后，往退出通道中写入数值表示需要退出。

- 第 26 行，运行到此处时持续阻塞，直到 1 秒后第 22 行被执行后结束阻塞。

time.AfterFunc() 函数是在 time.After 基础上增加了到时的回调，方便使用。

而 time.After() 函数又是在 time.NewTimer() 函数上进行的封装，下面的例子展示如何使用 timer.NewTimer() 和 time.NewTicker()。

#### 定点计时

计时器（Timer）的原理和倒计时闹钟类似，都是给定多少时间后触发。打点器（Ticker）的原理和钟表类似，钟表每到整点就会触发。这两种方法创建后会返回 time.Ticker 对象和 time.Timer 对象，里面通过一个 C 成员，类型是只能接收的时间通道（<-chan Time），使用这个通道就可以获得时间触发的通知。

下面代码创建一个打点器，每 500 毫秒触发一起；创建一个计时器，2 秒后触发，只触发一次。

计时器：

```go
  package main

  import (
      "fmt"
      "time"
  )

  func main() {

      // 创建一个打点器, 每500毫秒触发一次
      ticker := time.NewTicker(time.Millisecond * 500)

      // 创建一个计时器, 2秒后触发
      stopper := time.NewTimer(time.Second * 2)

      // 声明计数变量
      var i int

      // 不断地检查通道情况
      for {

          // 多路复用通道
          select {
          case <-stopper.C:  // 计时器到时了

              fmt.Println("stop")

              // 跳出循环
              goto StopHere

          case <-ticker.C:  // 打点器触发了
              // 记录触发了多少次
              i++
              fmt.Println("tick", i)
          }
      }

  // 退出的标签, 使用goto跳转
  StopHere:
      fmt.Println("done")

  }
```

代码说明如下：

- 第 11 行，创建一个打点器，500 毫秒触发一次，返回 *time.Ticker 类型变量。

- 第 14 行，创建一个计时器，2 秒后返回，返回 *time.Timer 类型变量。

- 第 17 行，声明一个变量，用于累计打点器触发次数。

- 第 20 行，每次触发后，select 会结束，需要使用循环再次从打点器返回的通道中获取触发通知。

- 第 23 行，同时等待多路计时器信号。

- 第 24 行，计时器信号到了。

- 第 29 行，通过 goto 跳出循环。

- 第 31 行，打点器信号到了，通过 i 自加记录触发次数并打印。

### 17. 关闭通道后继续使用通道

通道是一个引用对象，和 map 类似。map 在没有任何外部引用时，Go 语言程序在运行时（runtime）会自动对内存进行垃圾回收（Garbage Collection, GC）。类似的，通道也可以被垃圾回收，但是通道也可以被主动关闭。

#### 格式

使用 close() 来关闭一个通道：

```go
close(ch)
```

关闭的通道依然可以被访问，访问被关闭的通道将会发生一些问题。

#### 给被关闭通道发送数据将会触发 panic

被关闭的通道不会被置为 nil。如果尝试对已经关闭的通道进行发送，将会触发宕机，代码如下：

```go
  package main

  import "fmt"

  func main() {
      // 创建一个整型的通道
      ch := make(chan int)

      // 关闭通道
      close(ch)

      // 打印通道的指针, 容量和长度
      fmt.Printf("ptr:%p cap:%d len:%d\n", ch, cap(ch), len(ch))

      // 给关闭的通道发送数据
      ch <- 1
  }
```

代码运行后触发宕机：

```go
panic: send on closed channel
```

代码说明如下：

- 第 7 行，创建一个整型通道。

- 第 10 行，关闭通道，注意 ch 不会被 close 设置为 nil，依然可以被访问。

- 第 13 行，打印已经关闭通道的指针、容量和长度。

- 第 16 行，尝试给已经关闭的通道发送数据。

提示触发宕机的原因是给一个已经关闭的通道发送数据。

#### 从已关闭的通道接收数据时将不会发生阻塞

从已经关闭的通道接收数据或者正在接收数据时，将会接收到通道类型的零值，然后停止阻塞并返回。

操作关闭后的通道：

```go
  package main

  import "fmt"

  func main() {
      // 创建一个整型带两个缓冲的通道
      ch := make(chan int, 2)

      // 给通道放入两个数据
      ch <- 0
      ch <- 1

      // 关闭缓冲
      close(ch)

      // 遍历缓冲所有数据, 且多遍历1个
      for i := 0; i < cap(ch)+1; i++ {

          // 从通道中取出数据
          v, ok := <-ch

          // 打印取出数据的状态
          fmt.Println(v, ok)
      }
  }
```

代码运行结果如下：

```go
0 true 1 true 0 false
```

代码说明如下：

- 第 7 行，创建一个能保存两个元素的带缓冲的通道，类型为整型。

- 第 10 行和第 11 行，给这个带缓冲的通道放入两个数据。这时，通道装满了。

- 第 14 行，关闭通道。此时，带缓冲通道的数据不会被释放，通道也没有消失。

- 第 17 行，cap() 函数可以获取一个对象的容量，这里获取的是带缓冲通道的容量，也就是这个通道在 make 时的大小。虽然此时这个通道的元素个数和容量都是相同的，但是 cap 取出的并不是元素个数。这里多遍历一个元素，故意造成这个通道的超界访问。

- 第 20 行，从已关闭的通道中获取数据，取出的数据放在 v 变量中，类型为 int。ok 变量的结果表示数据是否获取成功。

- 第 23 行，将 v 和 ok 变量打印出来。

运行结果前两行正确输出带缓冲通道的数据，表明缓冲通道在关闭后依然可以访问内部的数据。

运行结果第三行的 “0 false” 表示通道在关闭状态下取出的值。0 表示这个通道的默认值，false 表示没有获取成功，因为此时通道已经空了。我们发现，在通道关闭后，即便通道没有数据，在获取时也不会发生阻塞，但此时取出数据会失败。

### 18.  多核并行化

Go语言具有支持高并发的特性，可以很方便地实现多线程运算，充分利用多核心 cpu 的性能。

众所周知服务器的处理器大都是单核频率较低而核心数较多，对于支持高并发的程序语言，可以充分利用服务器的多核优势，从而降低单核压力，减少性能浪费。

Go语言实现多核多线程并发运行是非常方便的，下面举个例子：

```go
package main
import (
    "fmt"
)
func main() {
    for i := 0; i < 5; i++ {
        go AsyncFunc(i)
    }
}
func AsyncFunc(index int) {
    sum := 0
    for i := 0; i < 10000; i++ {
        sum += 1
    }
    fmt.Printf("线程%d, sum为:%d\n", index, sum)
}
```

运行结果如下：

```go
线程0, sum为:10000
线程2, sum为:10000
线程3, sum为:10000
线程1, sum为:10000
线程4, sum为:10000
```

在执行一些昂贵的计算任务时，我们希望能够尽量利用现代服务器普遍具备的多核特性来尽量将任务并行化，从而达到降低总计算时间的目的。此时我们需要了解 CPU 核心的数量，并针对性地分解计算任务到多个 goroutine 中去并行运行。

下面我们来模拟一个完全可以并行的计算任务：计算 N 个整型数的总和。我们可以将所有整型数分成 M 份，M 即 CPU 的个数。让每个 CPU 开始计算分给它的那份计算任务，最后将每个 CPU 的计算结果再做一次累加，这样就可以得到所有 N 个整型数的总和：

```go
type Vector []float64
// 分配给每个CPU的计算任务
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i < n; i++ {
        v[i] += u.Op(v[i])
    }
    c <- 1 // 发信号告诉任务管理者我已经计算完成了
}
const NCPU = 16 // 假设总共有16核
func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU) // 用于接收每个CPU的任务完成信号
    for i := 0; i < NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // 等待所有CPU的任务完成
    for i := 0; i < NCPU; i++ {
        <-c // 获取到一个数据，表示一个CPU计算完成了
    }
    // 到这里表示所有计算已经结束
}
```

这两个函数看起来设计非常合理，其中 DoAll() 会根据 CPU 核心的数目对任务进行分割，然后开辟多个 goroutine 来并行执行这些计算任务。

是否可以将总的计算时间降到接近原来的 1/N 呢？答案是不一定。如果掐秒表，会发现总的执行时间没有明显缩短。再去观察 CPU 运行状态，你会发现尽管我们有 16 个 CPU 核心，但在计算过程中其实只有一个 CPU 核心处于繁忙状态，这是会让很多Go语言初学者迷惑的问题。

官方给出的答案是，这是当前版本的 Go 编译器还不能很智能地去发现和利用多核的优势。虽然我们确实创建了多个 goroutine，并且从运行状态看这些 goroutine 也都在并行运行，但实际上所有这些 goroutine 都运行在同一个 CPU 核心上，在一个 goroutine 得到时间片执行的时候，其他 goroutine 都会处于等待状态。从这一点可以看出，虽然 goroutine 简化了我们写并行代码的过程，但实际上整体运行效率并不真正高于单线程程序。

虽然Go语言还不能很好的利用多核心的优势，我们可以先通过设置环境变量 GOMAXPROCS 的值来控制使用多少个 CPU 核心。具体操作方法是通过直接设置环境变量 GOMAXPROCS 的值，或者在代码中启动 goroutine 之前先调用以下这个语句以设置使用 16 个 CPU 核心：

```go
runtime.GOMAXPROCS(16)
```

到底应该设置多少个 CPU 核心呢，其实 runtime 包中还提供了另外一个 NumCPU() 函数来获取核心数，示例代码如下：

```go
package main
import (
"fmt"
"runtime"
)
func main() {
cpuNum := runtime.NumCPU() //获得当前设备的cpu核心数
fmt.Println("cpu核心数:", cpuNum)
runtime.GOMAXPROCS(cpuNum) //设置需要用到的cpu数量
}
```

运行结果如下：

```go
cpu核心数: 4
```

### 19. telnet回音服务器

Telnet 协议是 TCP/IP 协议族中的一种。它允许用户（Telnet 客户端）通过一个协商过程与一个远程设备进行通信。本例将使用一部分 Telnet 协议与服务器进行通信。

服务器的网络库为了完整展示自己的代码实现了完整的收发过程，一般比较倾向于使用发送任意封包返回原数据的逻辑。这个过程类似于对着大山高喊，大山把你的声音原样返回的过程。也就是回音（Echo）。本节使用 Go 语言中的 Socket、goroutine 和通道编写一个简单的 Telnet 协议的回音服务器。

回音服务器的代码分为 4 个部分，分别是接受连接、会话处理、Telnet 命令处理和程序入口。

#### 接受连接

回音服务器能同时服务于多个连接。要接受连接就需要先创建侦听器，侦听器需要一个侦听地址和协议类型。就像你想卖东西，需要先确认卖什么东西，卖东西的类型就是协议类型，然后需要一个店面，店面位于街区的某个位置，这就是侦听器的地址。一个服务器可以开启多个侦听器，就像一个街区可以有多个店面。街区上的编号对应的就是地址中的端口号，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34006105.jpg)](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34006105.jpg)

图：IP 和端口号

- 主机 IP：一般为一个 IP 地址或者域名，127.0.0.1 表示本机地址。

- 端口号：16 位无符号整型值，一共有 65536 个有效端口号。

通过地址和协议名创建侦听器后，可以使用侦听器响应客户端连接。响应连接是一个不断循环的过程，就像到银行办理业务时，一般是排队处理，前一个人办理完后，轮到下一个人办理。

我们把每个客户端连接处理业务的过程叫做会话。在会话中处理的操作和接受连接的业务并不冲突可以同时进行。就像银行有 3 个窗口，喊号器会将用户分配到不同的柜台。这里的喊号器就是 Accept 操作，窗口的数量就是 CPU 的处理能力。因此，使用 goroutine 可以轻松实现会话处理和接受连接的并发执行。

如下图清晰地展现了这一过程。

[![img](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34252R7.jpg)](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34252R7.jpg)

图：Socket 处理过程

Go 语言中可以根据实际会话数量创建多个 goroutine，并自动的调度它们的处理。

telnet 服务器处理：

```go
  package main

  import (
      "fmt"
      "net"
  )

  // 服务逻辑, 传入地址和退出的通道
  func server(address string, exitChan chan int) {

      // 根据给定地址进行侦听
      l, err := net.Listen("tcp", address)

      // 如果侦听发生错误, 打印错误并退出
      if err != nil {
          fmt.Println(err.Error())
          exitChan <- 1
      }

      // 打印侦听地址, 表示侦听成功
      fmt.Println("listen: " + address)

      // 延迟关闭侦听器
      defer l.Close()

      // 侦听循环
      for {

          // 新连接没有到来时, Accept是阻塞的
          conn, err := l.Accept()

          // 发生任何的侦听错误, 打印错误并退出服务器
          if err != nil {
              fmt.Println(err.Error())
              continue
          }

          // 根据连接开启会话, 这个过程需要并行执行
          go handleSession(conn, exitChan)
      }
  }
```

代码说明如下：

- 第 9 行，接受连接的入口，address 为传入的地址，退出服务器使用 exitChan 的通道控制。往 exitChan 写入一个整型值时，进程将以整型值作为程序返回值来结束服务器。

- 第 12 行，使用 net 包的 Listen() 函数进行侦听。这个函数需要提供两个参数，第一个参数为协议类型，本例需要做的是 TCP 连接，因此填入 “tcp”；address 为地址，格式为 “主机: 端口号”。

- 第 15 行，如果侦听发生错误，通过第 17 行，往 exitChan 中写入非 0 值结束服务器，同时打印侦听错误。

- 第 24 行，使用 defer，将侦听器的结束延迟调用。

- 第 27 行，侦听开始后，开始进行连接接受，每次接受连接后需要继续接受新的连接，周而复始。

- 第 30 行，服务器接受了一个连接。在没有连接时，Accept() 函数调用后会一直阻塞。连接到来时，返回 conn 和错误变量，conn 的类型是 *tcp.Conn。

- 第 33 行，某些情况下，连接接受会发生错误，不影响服务器逻辑，这时重新进行新连接接受。

- 第 39 行，每个连接会生成一个会话。这个会话的处理与接受逻辑需要并行执行，彼此不干扰。

#### 会话处理

每个连接的会话就是一个接收数据的循环。当没有数据时，调用 reader.ReadString 会发生阻塞，等待数据的到来。一旦数据到来，就可以进行各种逻辑处理。

回音服务器的基本逻辑是 “收到什么返回什么”，reader.ReadString 可以一直读取 Socket 连接中的数据直到碰到期望的结尾符。这种期望的结尾符也叫定界符，一般用于将 TCP 封包中的逻辑数据拆分开。下例中使用的定界符是回车换行符（“\r\n”），HTTP 协议也是使用同样的定界符。使用 reader.ReadString() 函数可以将封包简单地拆分开。

如下图所示为 Telnet 数据处理过程。

[![img](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34S2143.jpg)](http://c.biancheng.net/uploads/allimg/180817/1-1PQG34S2143.jpg)

图：Telnet 数据处理过程

回音服务器需要将收到的有效数据通过 Socket 发送回去。

Telnet 会话处理：

```go
  package main

  import (
      "bufio"
      "fmt"
      "net"
      "strings"
  )

  // 连接的会话逻辑
  func handleSession(conn net.Conn, exitChan chan int) {

      fmt.Println("Session started:")

      // 创建一个网络连接数据的读取器
      reader := bufio.NewReader(conn)

      // 接收数据的循环
      for {

          // 读取字符串, 直到碰到回车返回
          str, err := reader.ReadString('\\n')

          // 数据读取正确
          if err == nil {

              // 去掉字符串尾部的回车
              str = strings.TrimSpace(str)

              // 处理Telnet指令
              if !processTelnetCommand(str, exitChan) {
                  conn.Close()
                  break
              }

              // Echo逻辑, 发什么数据, 原样返回
              conn.Write(\[\]byte(str + "\\r\\n"))

          } else {
              // 发生错误
              fmt.Println("Session closed")
              conn.Close()
              break
          }
      }

  }
```

代码说明如下：

- 第 11 行是会话入口，传入连接和退出用的通道。handle Session() 函数被并发执行。

- 第 16 行，使用 bufio 包的 NewReader() 方法，创建一个网络数据读取器，这个 Reader 将输入数据的读取过程进行封装，方便我们迅速获取到需要的数据。

- 第 19 行，会话处理开始时，从 Socket 连接，通过 reader 读取器读取封包，处理封包后需要继续读取从网络发送过来的下一个封包，因此需要一个会话处理循环。

- 第 22 行，使用 reader.ReadString() 方法进行封包读取。内部会自动处理粘包过程，直到下一个回车符到达后返回数据。这里认为封包来自 Telnet，每个指令以回车换行符（“\r\n”）结尾。

- 第 25 行，数据读取正常时，返回 err 为 nil。如果发生连接断开、接收错误等网络错误时，err 就不是 nil 了。

- 第 28 行，reader.ReadString 读取返回的字符串尾部带有回车符，使用 strings.TrimSpace() 函数将尾部带的回车和空白符去掉。

- 第 31 行，将 str 字符串传入 Telnet 指令处理函数 processTelnetCommand() 中，同时传入退出控制通道 exitChan。当这个函数返回 false 时，表示需要关闭当前连接。

- 第 32 行和第 33 行，关闭当前连接并退出会话接受循环。

- 第 37 行，将有效数据通过 conn 的 Write() 方法写入，同时在字符串尾部添加回车换行符（“\r\n”），数据将被 Socket 发送给连接方。

- 第 41～43 行，处理当 reader.ReadString() 函数返回错误时，打印错误信息并关闭连接，退出会话并接收循环。

#### Telnet 命令处理

Telnet 是一种协议。在操作系统中可以在命令行使用 Telnet 命令发起 TCP 连接。我们一般用 Telnet 来连接 TCP 服务器，键盘输入一行字符回车后，即被发送到服务器上。

在下例中，定义了以下两个特殊控制指令，用以实现一些功能：

- 输入 “@close” 退出当前连接会话。

- 输入 “@shutdown” 终止服务器运行。

Telnet 命令处理：

```go
  package main

  import (
      "fmt"
      "strings"
  )

  func processTelnetCommand(str string, exitChan chan int) bool {

      // @close指令表示终止本次会话
      if strings.HasPrefix(str, "@close") {

          fmt.Println("Session closed")

          // 告诉外部需要断开连接
          return false

          // @shutdown指令表示终止服务进程
      } else if strings.HasPrefix(str, "@shutdown") {

          fmt.Println("Server shutdown")

          // 往通道中写入0, 阻塞等待接收方处理
          exitChan <- 0

          // 告诉外部需要断开连接
          return false
      }

      // 打印输入的字符串
      fmt.Println(str)

      return true

  }
```

代码说明如下：

- 第 8 行，处理 Telnet 命令的函数入口，传入有效字符并退出通道。

- 第 11～16 行，当输入字符串中包含 “@close” 前缀时，在第 16 行返回 false，表示需要关闭当前会话。

- 第 19～27 行，当输入字符串中包含 “@shutdown” 前缀时，第 24 行将 0 写入 exitChan，表示结束服务器。

- 第 31 行，没有特殊的控制字符时，打印输入的字符串。

#### 程序入口

Telnet 回音处理主流程：

```go
  package main

  import (
      "os"
  )

  func main() {

      // 创建一个程序结束码的通道
      exitChan := make(chan int)

      // 将服务器并发运行
      go server("127.0.0.1:7001", exitChan)

      // 通道阻塞, 等待接收返回值
      code := <-exitChan

      // 标记程序返回值并退出
      os.Exit(code)
  }
```

代码说明如下：

- 第 10 行，创建一个整型的无缓冲通道作为退出信号。

- 第 13 行，接受连接的过程可以并发操作，使用 go 将 server() 函数开启 goroutine。

- 第 16 行，从 exitChan 中取出返回值。如果取不到数据就一直阻塞。

- 第 19 行，将程序返回值传入 os.Exit() 函数中并终止程序。

编译所有代码并运行，命令行提示如下：

listen: 127.0.0.1:7001

此时，Socket 侦听成功。在操作系统中的命令行中输入：

telnet 127.0.0.1 7001

尝试连接本地的 7001 端口。接下来进入测试服务器的流程。

#### 测试输入字符串

在 Telnet 连接后，输入字符串 hello，Telnet 命令行显示如下：

```shell
$ telnet 127.0.0.1 7001
Trying 127.0.0.1…
Connected to 127.0.0.1.
Escape character is ‘^]’.
hello
hello
```

服务器显示如下：

```shell
listen: 127.0.0.1:7001
Session started:
hello
```

客户端输入的字符串会在服务器中显示，同时客户端也会收到自己发给服务器的内容，这就是一次回音。

#### 测试关闭会话

当输入 @close 时，Telnet 命令行显示如下：

@close Connection closed by foreign host

服务器显示如下：

Session closed

此时，客户端 Telnet 与服务器断开连接。

#### 测试关闭服务器

当输入 @shutdown 时，Telnet 命令行显示如下：

@shutdown Connection closed by foreign host

服务器显示如下：

Server shutdown

此时服务器会自动关闭。

### 20. 检测代码在并发环境可能出现的问题

Go 语言程序可以使用通道进行多个 goroutine 间的数据交换，但这仅仅是数据同步中的一种方法。通道内部的实现依然使用了各种锁，因此优雅代码的代价是性能。在某些轻量级的场合，原子访问（atomic 包）、互斥锁（sync.Mutex）以及等待组（sync.WaitGroup）能最大程度满足需求。

本节只讲解原子访问，互斥锁和等待组将在接下来的两节中讲解。

当多线程并发运行的程序竞争访问和修改同一块资源时，会发生竞态问题。

下面的代码中有一个 ID 生成器，每次调用生成器将会生成一个不会重复的顺序序号，使用 10 个并发生成序号，观察 10 个并发后的结果。

竞态检测的具体代码：

```go
  package main

  import (
      "fmt"
      "sync/atomic"
  )

  var (
      // 序列号
      seq int64
  )

  // 序列号生成器
  func GenID() int64 {

  // 尝试原子的增加序列号
      atomic.AddInt64(&seq, 1)
      return seq
  }

  func main() {

      //生成10个并发序列号
      for i := 0; i < 10; i++ {
              go GenID()
      }

      fmt.Println(GenID())
  }
```

代码说明如下：

- 第 10 行，序列号生成器中的保存上次序列号的变量。

- 第 17 行，使用原子操作函数 atomic.AddInt64() 对 seq() 函数加 1 操作。不过这里故意没有使用 atomic.AddInt64() 的返回值作为 GenID() 函数的返回值，因此会造成一个竞态问题。

- 第 25 行，循环 10 次生成 10 个 goroutine 调用 GenID() 函数，同时忽略 GenID() 的返回值。

- 第 28 行，单独调用一次 GenID() 函数。

在运行程序时，为运行参数加入`-race`参数，开启运行时（runtime）对竞态问题的分析，命令如下：

```go
go run -race racedetect.go
```

代码运行发生宕机，输出信息如下：

```go
\==================
WARNING: DATA RACE
Write at 0x000000f52f40 by goroutine 7:
  sync/atomic.AddInt64()
      C:/Go/src/runtime/race_amd64.s:276 +0xb
  main.GenID()
      racedetect.go:17 +0x4a

Previous read at 0x000000f52f40 by goroutine 6:
  main.GenID()
      racedetect.go:18 +0x5a

Goroutine 7 (running) created at:
  main.main()
      racedetect.go:25 +0x5a

Goroutine 6 (finished) created at:
  main.main()
      racedetect.go:25 +0x5a
\==================
10
Found 1 data race(s)
exit status 66
```

根据报错信息，第 18 行有竞态问题，根据 atomic.AddInt64() 的参数声明，这个函数会将修改后的值以返回值方式传出。下面代码对加粗部分进行了修改：

```
1.  func GenID() int64 {
2.      // 尝试原子的增加序列号
3.      return atomic.AddInt64(&seq, 1)
4.  }
```

再次运行：

```go
go run -race main.go
```

代码输出如下：

```go
10
```

没有发生竞态问题，程序运行正常。

本例中只是对变量进行增减操作，虽然可以使用互斥锁（sync.Mutex）解决竞态问题，但是对性能消耗较大。在这种情况下，推荐使用原子操作（atomic）进行变量操作。

### 21. 互斥锁（sync.Mutex）和读写互斥锁（sync.RWMutex）

Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。

Mutex 是最简单的一种锁类型，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。

RWMutex 相对友好些，是经典的单写多读模型。在读锁占用的情况下，会阻止写，但不阻止读，也就是多个 goroutine 可同时获取读锁（调用 RLock() 方法；而写锁（调用 Lock() 方法）会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占。从 RWMutex 的实现看，RWMutex 类型其实组合了 Mutex：

```go
type RWMutex struct {
  w Mutex
  writerSem uint32
  readerSem uint32
  readerCount int32
  readerWait int32
}
```

对于这两种锁类型，任何一个 Lock() 或 RLock() 均需要保证对应有 Unlock() 或 RUnlock() 调用与之对应，否则可能导致等待该锁的所有 goroutine 处于饥饿状态，甚至可能导致死锁。锁的典型使用模式如下：

```go
package main
import (
    "fmt"
    "sync"
)
var (
    // 逻辑中使用的某个变量
    count int
    // 与变量对应的使用互斥锁
    countGuard sync.Mutex
)
func GetCount() int {
    // 锁定
    countGuard.Lock()
    // 在函数退出时解除锁定
    defer countGuard.Unlock()
    return count
}
func SetCount(c int) {
    countGuard.Lock()
    count = c
    countGuard.Unlock()
}
func main() {
    // 可以进行并发安全的设置
    SetCount(1)
    // 可以进行并发安全的获取
    fmt.Println(GetCount())
}
```

代码说明如下：

- 第 10 行是某个逻辑步骤中使用到的变量，无论是包级的变量还是结构体成员字段，都可以。

- 第 13 行，一般情况下，建议将互斥锁的粒度设置得越小越好，降低因为共享访问时等待的时间。这里笔者习惯性地将互斥锁的变量命名为以下格式：

  ```go
  变量名+Guard
  ```

  以表示这个互斥锁用于保护这个变量。

- 第 16 行是一个获取 count 值的函数封装，通过这个函数可以并发安全的访问变量 count。

- 第 19 行，尝试对 countGuard 互斥量进行加锁。一旦 countGuard 发生加锁，如果另外一个 goroutine 尝试继续加锁时将会发生阻塞，直到这个 countGuard 被解锁。

- 第 22 行使用 defer 将 countGuard 的解锁进行延迟调用，解锁操作将会发生在 GetCount() 函数返回时。

- 第 27 行在设置 count 值时，同样使用 countGuard 进行加锁、解锁操作，保证修改 count 值的过程是一个原子过程，不会发生并发访问冲突。


在读多写少的环境中，可以优先使用读写互斥锁（sync.RWMutex），它比互斥锁更加高效。sync 包中的 RWMutex 提供了读写互斥锁的封装。

我们将互斥锁例子中的一部分代码修改为读写互斥锁，参见下面代码：

```go
var (
    // 逻辑中使用的某个变量
    count int
    // 与变量对应的使用互斥锁
    countGuard sync.RWMutex
)
func GetCount() int {
    // 锁定
    countGuard.RLock()
    // 在函数退出时解除锁定
    defer countGuard.RUnlock()
    return count
}
```

代码说明如下：

- 第 6 行，在声明 countGuard 时，从 sync.Mutex 互斥锁改为 sync.RWMutex 读写互斥锁。
- 第 12 行，获取 count 的过程是一个读取 count 数据的过程，适用于读写互斥锁。在这一行，把 countGuard.Lock() 换做 countGuard.RLock()，将读写互斥锁标记为读状态。如果此时另外一个 goroutine 并发访问了 countGuard，同时也调用了 countGuard.RLock() 时，并不会发生阻塞。
- 第 15 行，与读模式加锁对应的，使用读模式解锁。

### 22. 等待组（sync.WaitGroup）

Go语言中除了可以使用通道（channel）和互斥锁进行两个并发程序间的同步外，还可以使用等待组进行多个任务的同步，等待组可以保证在并发环境中完成指定数量的任务

在 sync.WaitGroup（等待组）类型中，每个 sync.WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。

等待组有下面几个方法可用，如下表所示。

| 方法名                          | 功能                                    |
| ------------------------------- | --------------------------------------- |
| (wg * WaitGroup) Add(delta int) | 等待组的计数器 +1                       |
| (wg * WaitGroup) Done()         | 等待组的计数器 -1                       |
| (wg * WaitGroup) Wait()         | 当等待组计数器不等于 0 时阻塞直到变 0。 |


对于一个可寻址的 sync.WaitGroup 值 wg：

- 我们可以使用方法调用 wg.Add(delta) 来改变值 wg 维护的计数。
- 方法调用 wg.Done() 和 wg.Add(-1) 是完全等价的。
- 如果一个 wg.Add(delta) 或者 wg.Done() 调用将 wg 维护的计数更改成一个负数，一个恐慌将产生。
- 当一个协程调用了 wg.Wait() 时，
    - 如果此时 wg 维护的计数为零，则此 wg.Wait() 此操作为一个空操作（noop）；
    - 否则（计数为一个正整数），此协程将进入阻塞状态。当以后其它某个协程将此计数更改至 0 时（一般通过调用 wg.Done()），此协程将重新进入运行状态（即 wg.Wait() 将返回）。


等待组内部拥有一个计数器，计数器的值可以通过方法调用实现计数器的增加和减少。当我们添加了 N 个并发任务进行工作时，就将等待组的计数器值增加 N。每个任务完成时，这个值减 1。同时，在另外一个 goroutine 中等待这个等待组的计数器值为 0 时，表示所有任务已经完成。

下面的代码演示了这一过程：

```go
package main
import (
    "fmt"
    "net/http"
    "sync"
)
func main() {
    // 声明一个等待组
    var wg sync.WaitGroup
    // 准备一系列的网站地址
    var urls = []string{
        "http://www.github.com/",
        "https://www.qiniu.com/",
        "https://www.golangtc.com/",
    }
    // 遍历这些地址
    for _, url := range urls {
        // 每一个任务开始时, 将等待组增加1
        wg.Add(1)
        // 开启一个并发
        go func(url string) {
            // 使用defer, 表示函数完成时将等待组值减1
            defer wg.Done()
            // 使用http访问提供的地址
            _, err := http.Get(url)
            // 访问完成后, 打印地址和可能发生的错误
            fmt.Println(url, err)
            // 通过参数传递url地址
        }(url)
    }
    // 等待所有的任务完成
    wg.Wait()
    fmt.Println("over")
}
```

代码说明如下：

- 第 12 行，声明一个等待组，对一组等待任务只需要一个等待组，而不需要每一个任务都使用一个等待组。
- 第 15 行，准备一系列可访问的网站地址的字符串切片。
- 第 22 行，遍历这些字符串切片。
- 第 25 行，将等待组的计数器加1，也就是每一个任务加 1。
- 第 28 行，将一个匿名函数开启并发。
- 第 31 行，在匿名函数结束时会执行这一句以表示任务完成。wg.Done() 方法等效于执行 wg.Add(-1)。
- 第 34 行，使用 http 包提供的 Get() 函数对 url 进行访问，Get() 函数会一直阻塞直到网站响应或者超时。
- 第 37 行，在网站响应和超时后，打印这个网站的地址和可能发生的错误。
- 第 40 行，这里将 url 通过 goroutine 的参数进行传递，是为了避免 url 变量通过闭包放入匿名函数后又被修改的问题。
- 第 44 行，等待所有的网站都响应或者超时后，任务完成，Wait 就会停止阻塞。

### 23. 死锁、活锁和饥饿概述

本节我们来介绍一下死锁、活锁和饥饿这三个概念。

#### 死锁

死锁是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁发生的条件有如下几种：

##### 1) 互斥条件

线程对资源的访问是排他性的，如果一个线程对占用了某资源，那么其他线程必须处于等待状态，直到该资源被释放。

##### 2) 请求和保持条件

线程 T1 至少已经保持了一个资源 R1 占用，但又提出使用另一个资源 R2 请求，而此时，资源 R2 被其他线程 T2 占用，于是该线程 T1 也必须等待，但又对自己保持的资源 R1 不释放。

##### 3) 不剥夺条件

线程已获得的资源，在未使用完之前，不能被其他线程剥夺，只能在使用完以后由自己释放。

##### 4) 环路等待条件

在死锁发生时，必然存在一个“进程 - 资源环形链”，即：{p0,p1,p2,...pn}，进程 p0（或线程）等待 p1 占用的资源，p1 等待 p2 占用的资源，pn 等待 p0 占用的资源。

最直观的理解是，p0 等待 p1 占用的资源，而 p1 而在等待 p0 占用的资源，于是两个进程就相互等待。

死锁解决办法：

- 如果并发查询多个表，约定访问顺序；
- 在同一个事务中，尽可能做到一次锁定获取所需要的资源；
- 对于容易产生死锁的业务场景，尝试升级锁颗粒度，使用表级锁；
- 采用分布式事务锁或者使用乐观锁。


死锁程序是所有并发进程彼此等待的程序，在这种情况下，如果没有外界的干预，这个程序将永远无法恢复。

为了便于大家理解死锁是什么，我们先来看一个例子（忽略代码中任何不知道的类型，函数，方法或是包，只理解什么是死锁即可），代码如下所示：

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
    "time"
)
type value struct {
    memAccess sync.Mutex
    value     int
}
func main() {
    runtime.GOMAXPROCS(3)
    var wg sync.WaitGroup
    sum := func(v1, v2 *value) {
        defer wg.Done()
        v1.memAccess.Lock()
        time.Sleep(2 * time.Second)
        v2.memAccess.Lock()
        fmt.Printf("sum = %d\n", v1.value+v2.value)
        v2.memAccess.Unlock()
        v1.memAccess.Unlock()
    }
    product := func(v1, v2 *value) {
        defer wg.Done()
        v2.memAccess.Lock()
        time.Sleep(2 * time.Second)
        v1.memAccess.Lock()
        fmt.Printf("product = %d\n", v1.value*v2.value)
        v1.memAccess.Unlock()
        v2.memAccess.Unlock()
    }
    var v1, v2 value
    v1.value = 1
    v2.value = 1
    wg.Add(2)
    go sum(&v1, &v2)
    go product(&v1, &v2)
    wg.Wait()
}
```

运行上面的代码，可能会看到：

```go
fatal error: all goroutines are asleep - deadlock!
```

为什么呢？如果仔细观察，就可以在此代码中看到时机问题，以下是运行时的图形表示。



![一个因时间问题导致死锁的演示](http://c.biancheng.net/uploads/allimg/191223/4-19122313533W41.gif)
图 ：一个因时间问题导致死锁的演示

#### 活锁

活锁是另一种形式的活跃性问题，该问题尽管不会阻塞线程，但也不能继续执行，因为线程将不断重复同样的操作，而且总会失败。

例如线程 1 可以使用资源，但它很礼貌，让其他线程先使用资源，线程 2 也可以使用资源，但它同样很绅士，也让其他线程先使用资源。就这样你让我，我让你，最后两个线程都无法使用资源。

活锁通常发生在处理事务消息中，如果不能成功处理某个消息，那么消息处理机制将回滚事务，并将它重新放到队列的开头。这样，错误的事务被一直回滚重复执行，这种形式的活锁通常是由过度的错误恢复代码造成的，因为它错误地将不可修复的错误认为是可修复的错误。

当多个相互协作的线程都对彼此进行相应而修改自己的状态，并使得任何一个线程都无法继续执行时，就导致了活锁。这就像两个过于礼貌的人在路上相遇，他们彼此让路，然后在另一条路上相遇，然后他们就一直这样避让下去。

要解决这种活锁问题，需要在重试机制中引入随机性。例如在网络上发送数据包，如果检测到冲突，都要停止并在一段时间后重发，如果都在 1 秒后重发，还是会冲突，所以引入随机性可以解决该类问题。

下面通过示例来演示一下活锁：

```go
package main
import (
    "bytes"
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
    "time"
)
func main() {
    runtime.GOMAXPROCS(3)
    cv := sync.NewCond(&sync.Mutex{})
    go func() {
        for range time.Tick(1 * time.Second) { // 通过tick控制两个人的步调
            cv.Broadcast()
        }
    }()
    takeStep := func() {
        cv.L.Lock()
        cv.Wait()
        cv.L.Unlock()
    }
    tryDir := func(dirName string, dir *int32, out *bytes.Buffer) bool {
        fmt.Fprintf(out, " %+v", dirName)
        atomic.AddInt32(dir, 1)
        takeStep()                      //走上一步
        if atomic.LoadInt32(dir) == 1 { //走成功就返回
            fmt.Fprint(out, ". Success!")
            return true
        }
        takeStep() // 没走成功，再走回来
        atomic.AddInt32(dir, -1)
        return false
    }
    var left, right int32
    tryLeft := func(out *bytes.Buffer) bool {
        return tryDir("向左走", &left, out)
    }
    tryRight := func(out *bytes.Buffer) bool {
        return tryDir("向右走", &right, out)
    }
    walk := func(walking *sync.WaitGroup, name string) {
        var out bytes.Buffer
        defer walking.Done()
        defer func() { fmt.Println(out.String()) }()
        fmt.Fprintf(&out, "%v is trying to scoot:", name)
        for i := 0; i < 5; i++ {
            if tryLeft(&out) || tryRight(&out) {
                return
            }
        }
        fmt.Fprintf(&out, "\n%v is tried!", name)
    }
    var trail sync.WaitGroup
    trail.Add(2)
    go walk(&trail, "男人") // 男人在路上走
    go walk(&trail, "女人") // 女人在路上走
    trail.Wait()
}
```

输出结果如下：

```go
go run main.go
女人 is trying to scoot: 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走
女人 is tried!
男人 is trying to scoot: 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走 向左走 向右走
男人 is tried!
```

这个例子演示了使用活锁的一个十分常见的原因，两个或两个以上的并发进程试图在没有协调的情况下防止死锁。这就好比，如果走廊里的人都同意，只有一个人会移动，那就不会有活锁；一个人会站着不动，另一个人会移到另一边，他们就会继续移动。

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”，而处于死锁的实体表现为等待，活锁有可能自行解开，死锁则不能。

#### 饥饿

饥饿是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况。

与死锁不同的是，饥饿锁在一段时间内，优先级低的线程最终还是会执行的，比如高优先级的线程执行完之后释放了资源。

活锁与饥饿是无关的，因为在活锁中，所有并发进程都是相同的，并且没有完成工作。更广泛地说，饥饿通常意味着有一个或多个贪婪的并发进程，它们不公平地阻止一个或多个并发进程，以尽可能有效地完成工作，或者阻止全部并发进程。

下面的示例程序中包含了一个贪婪的 goroutine 和一个平和的 goroutine：

```go
package main
import (
    "fmt"
    "runtime"
    "sync"
    "time"
)
func main() {
    runtime.GOMAXPROCS(3)
    var wg sync.WaitGroup
    const runtime = 1 * time.Second
    var sharedLock sync.Mutex
    greedyWorker := func() {
        defer wg.Done()
        var count int
        for begin := time.Now(); time.Since(begin) <= runtime; {
            sharedLock.Lock()
            time.Sleep(3 * time.Nanosecond)
            sharedLock.Unlock()
            count++
        }
        fmt.Printf("Greedy worker was able to execute %v work loops\n", count)
    }
    politeWorker := func() {
        defer wg.Done()
        var count int
        for begin := time.Now(); time.Since(begin) <= runtime; {
            sharedLock.Lock()
            time.Sleep(1 * time.Nanosecond)
            sharedLock.Unlock()
            sharedLock.Lock()
            time.Sleep(1 * time.Nanosecond)
            sharedLock.Unlock()
            sharedLock.Lock()
            time.Sleep(1 * time.Nanosecond)
            sharedLock.Unlock()
            count++
        }
        fmt.Printf("Polite worker was able to execute %v work loops\n", count)
    }
    wg.Add(2)
    go greedyWorker()
    go politeWorker()
    wg.Wait()
}
```

输出如下：

```go
Greedy worker was able to execute 276 work loops
Polite worker was able to execute 92 work loops
```

贪婪的 worker 会贪婪地抢占共享锁，以完成整个工作循环，而平和的 worker 则试图只在需要时锁定。两种 worker 都做同样多的模拟工作（sleeping 时间为 3ns），可以看到，在同样的时间里，贪婪的 worker 工作量几乎是平和的 worker 工作量的两倍！

假设两种 worker 都有同样大小的临界区，而不是认为贪婪的 worker 的算法更有效（或调用 Lock 和 Unlock 的时候，它们也不是缓慢的），我们得出这样的结论，贪婪的 worker 不必要地扩大其持有共享锁上的临界区，井阻止（通过饥饿）平和的 worker 的 goroutine 高效工作。

#### 总结

不适用锁肯定会出问题。如果用了，虽然解了前面的问题，但是又出现了更多的新问题。

- 死锁：是因为错误的使用了锁，导致异常；
- 活锁：是饥饿的一种特殊情况，逻辑上感觉对，程序也一直在正常的跑，但就是效率低，逻辑上进行不下去；
- 饥饿：与锁使用的粒度有关，通过计数取样，可以判断进程的工作效率。


只要有共享资源的访问，必定要使其逻辑上进行顺序化和原子化，确保访问一致，这绕不开锁这个概念。



### 24. 封装qsort快速排序函数

快速排序（Quick Sort）是由 “东尼 · 霍尔” 所设计的一种排序算法。在平均状况下，排序 n 个项目要`Ο(n log n) `次比较，在最坏状况下则需要`Ο(n2) `次比较，但这种状况并不常见。

事实上，快速排序通常明显比其他`Ο(n log n) `算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。

qsort 快速排序函数是 C 语言中的一个高阶函数，支持用于自定义排序比较函数，可以对任意类型的数组进行排序。

本节我们为大家简单的介绍一下 C 语言中的 qsort 函数，并使用 Go 语言实现类似功能的 qsort 函数。

#### 认识 qsort 函数

qsort 快速排序函数有`<stdlib.h> `标准库提供，函数的声明如下：

void qsort(   void* base, size_t num, size_t size,   int (*cmp)(const void*, const void*) );

参数说明如下：

- base：参数是要排序数组的首个元素的地址；

- num：是数组中元素的个数；

- size：是数组中每个元素的大小；

- cmp：用于对数组中任意两个元素进行排序。

cmp 排序函数的两个指针参数分别是要比较的两个元素的地址，如果第一个参数对应的元素大于第二个参数对应的元素则返回结果大于 0，如果两个元素相等则返回 0，如果第一个元素小于第二个元素则返回结果小于 0。

下面的代码展示了使用 C 语言的 qsort 函数对一个 int 类型的数组进行排序：

```
1.  #include <stdio.h>
2.  #include <stdlib.h>
3.  #define DIM(x) (sizeof(x)/sizeof((x)\[0\]))
4.  static int cmp(const void\* a, const void\* b) {
5.      const int\* pa \= (int\*)a;
6.      const int\* pb \= (int\*)b;
7.      return \*pa \- \*pb;
8.  }
9.  int main() {
10.      int values\[\] \= { 42, 8, 109, 97, 23, 25 };
11.      int i;
12.      qsort(values, DIM(values), sizeof(values\[0\]), cmp);
13.      for(i \= 0; i < DIM(values); i++) {
14.          printf ("%d ",values\[i\]);
15.      }
16.      return 0;
17.  }
```

代码说明如下：

- DIM(values) 宏用于计算数组元素的个数；

- sizeof(values[0]) 用于计算数组元素的大小；

- cmp 是用于排序时比较两个元素大小的回调函数。

#### 使用 Go 语言实现快速排序函数

##### 1) 快速排序稳定性

快速排序是不稳定的算法，它不满足稳定算法的定义。

算法稳定性可以这样理解，假设在数列中存在`a[i]=a[j]`，若在排序之前，a[i] 在 a[j] 前面，并且在排序之后，a[i] 仍然在 a[j] 前面，则这个排序算法才算是稳定的。

##### 2) 快速排序时间复杂度

快速排序的时间复杂度在最坏情况下是`O(N²)`，平均的时间复杂度是`O(N*lgN)`。

这句话很好理解：假设被排序的数列中有 N 个数，遍历一次的时间复杂度是`O(N)`，需要遍历多少次呢？至少`lg(N+1) `次，最多 N 次。

##### 为什么最少是 lg(N+1) 次？

快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是`lg(N+1)`。因此，快速排序的遍历次数最少是`lg(N+1) `次。

##### 为什么最多是 N 次？

将快速排序看作一棵[二叉树](http://c.biancheng.net/view/5570.html)，它的深度最大是 N，因此，快读排序的遍历次数最多是 N 次。

示例代码如下：

```go
  package main

  import (
      "fmt"
  )

  func main() {
      Arr := []int{23, 65, 13, 27, 42, 15, 38, 21, 4, 10}
      qsort(Arr, 0, len(Arr)-1)
      fmt.Println(Arr)
  }

  /*
  快速排序：分治法+递归实现
  随意取一个值A，将比A大的放在A的右边，比A小的放在A的左边；然后在左边的值AA中再取一个值B，将AA中比B小的值放在B的左边，将比B大的值放在B的右边。以此类推
  */
  func qsort(arr []int, first, last int) {
      flag := first
      left := first
      right := last

      if first >= last {
          return
      }
      // 将大于arr[flag]的都放在右边，小于的，都放在左边
      for first < last {
          // 如果flag从左边开始，那么是必须先从有右边开始比较，也就是先在右边找比flag小的
          for first < last {
              if arr[last] >= arr[flag] {
                  last--
                  continue
              }
              // 交换数据
              arr[last], arr[flag] = arr[flag], arr[last]
              flag = last
              break
          }
          for first < last {
              if arr[first] <= arr[flag] {
                  first++
                  continue
              }
              arr[first], arr[flag] = arr[flag], arr[first]
              flag = first
              break
          }
      }

      qsort(arr, left, flag-1)
      qsort(arr, flag+1, right)
  }
```

运行结果如下：

```go
[4 10 13 15 21 23 27 38 42 65]
```

##### 分治法策略

快速排序使用分治法策略，分治法就是把一个复杂的问题分解成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题，直到最后子问题可以简单的直接求解 （各个击破），原问题的解即子问题的解的合并。

因此分治法的执行步骤为：

- 第一步（分）：将原来复杂的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题，分解到可以直接求解为止；

- 第二步（治）：此时可以直接求解；

- 第三步（合）：将小规模的问题的解合并为一个更大规模的问题的解，自底向上逐步求出原来问题的解，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/191224/4-19122411314Q26.gif)](http://c.biancheng.net/uploads/allimg/191224/4-19122411314Q26.gif)

图：有序子序列两两归并形成新的有序序列

### 25. CSP：通信顺序进程简述

Go实现了两种并发形式，第一种是大家普遍认知的多线程共享内存，其实就是 [Java](http://c.biancheng.net/java/) 或 [C++](http://c.biancheng.net/cplus/) 等语言中的多线程开发；另外一种是Go语言特有的，也是Go语言推荐的 CSP（communicating sequential processes）并发模型。

CSP 并发模型是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享 channel（管道）进行通信的并发模型。

Go语言就是借用 CSP 并发模型的一些概念为之实现并发的，但是Go语言并没有完全实现了 CSP 并发模型的所有理论，仅仅是实现了 process 和 channel 这两个概念。

process 就是Go语言中的 goroutine，每个 goroutine 之间是通过 channel 通讯来实现数据共享。

这里我们要明确的是“并发不是并行”。并发更关注的是程序的设计层面，并发的程序完全是可以顺序执行的，只有在真正的多核 CPU 上才可能真正地同时运行；并行更关注的是程序的运行层面，并行一般是简单的大量重复，例如 GPU 中对图像处理都会有大量的并行运算。

为了更好地编写并发程序，从设计之初Go语言就注重如何在编程语言层级上设计一个简洁安全高效的抽象模型，让开发人员专注于分解问题和组合方案，而且不用被线程管理和信号互斥这些烦琐的操作分散精力。

在并发编程中，对共享资源的正确访问需要精确地控制，在目前的绝大多数语言中，都是通过加锁等线程同步方案来解决这一困难问题，而Go语言却另辟蹊径，它将共享的值通过通道传递（实际上多个独立执行的线程很少主动共享资源）。

并发编程的核心概念是同步通信，但是同步的方式却有多种。先以大家熟悉的互斥量 sync.Mutex 来实现同步通信，示例代码如下所示：

```go
package main
import (
    "fmt"
    "sync"
)
func main() {
    var mu sync.Mutex
    go func() {
        fmt.Println("C语言中文网")
        mu.Lock()
    }()
    mu.Unlock()
}
```

由于 mu.Lock() 和 mu.Unlock() 并不在同一个 Goroutine 中，所以也就不满足顺序一致性内存模型。同时它们也没有其他的同步事件可以参考，也就是说这两件事是可以并发的。

因为可能是并发的事件，所以 main() 函数中的 mu.Unlock() 很有可能先发生，而这个时刻 mu 互斥对象还处于未加锁的状态，因而会导致运行时异常。

下面是修复后的代码：

```go
package main
import (
    "fmt"
    "sync"
)
func main() {
    var mu sync.Mutex
    mu.Lock()
    go func() {
        fmt.Println("C语言中文网")
        mu.Unlock()
    }()
    mu.Lock()
}
```

修复的方式是在 main() 函数所在线程中执行两次 mu.Lock()，当第二次加锁时会因为锁已经被占用（不是递归锁）而阻塞，main() 函数的阻塞状态驱动后台线程继续向前执行。

当后台线程执行到 mu.Unlock() 时解锁，此时打印工作已经完成了，解锁会导致 main() 函数中的第二个 mu.Lock() 阻塞状态取消，此时后台线程和主线程再没有其他的同步事件参考，它们退出的事件将是并发的，在 main() 函数退出导致程序退出时，后台线程可能已经退出了，也可能没有退出。虽然无法确定两个线程退出的时间，但是打印工作是可以正确完成的。

使用 sync.Mutex 互斥锁同步是比较低级的做法，我们现在改用无缓存通道来实现同步：

```go
package main
import (
    "fmt"
)
func main() {
    done := make(chan int)
    go func() {
        fmt.Println("C语言中文网")
        <-done
    }()
    done <- 1
}
```

根据Go语言内存模型规范，对于从无缓存通道进行的接收，发生在对该通道进行的发送完成之前。因此，后台线程`<-done `接收操作完成之后，main 线程的`done <- 1 `发送操作才可能完成（从而退出 main、退出程序），而此时打印工作已经完成了。

上面的代码虽然可以正确同步，但是对通道的缓存大小太敏感，如果通道有缓存，就无法保证 main() 函数退出之前后台线程能正常打印了，更好的做法是将通道的发送和接收方向调换一下，这样可以避免同步事件受通道缓存大小的影响：

```go
package main
import (
    "fmt"
)
func main() {
    done := make(chan int, 1) // 带缓存通道
    go func() {
        fmt.Println("C语言中文网")
        done <- 1
    }()
    <-done
}
```

对于带缓存的通道，对通道的第 K 个接收完成操作发生在第 K+C 个发送操作完成之前，其中 C 是通道的缓存大小。虽然通道是带缓存的，但是 main 线程接收完成是在后台线程发送开始但还未完成的时刻，此时打印工作也是已经完成的。

基于带缓存通道，我们可以很容易将打印线程扩展到 N 个，下面的示例是开启 10 个后台线程分别打印：

```go
package main
import (
    "fmt"
)
func main() {
    done := make(chan int, 10) // 带10个缓存
    // 开N个后台打印线程
    for i := 0; i < cap(done); i++ {
        go func() {
            fmt.Println("C语言中文网")
            done <- 1
        }()
    }
    // 等待N个后台线程完成
    for i := 0; i < cap(done); i++ {
        <-done
    }
}
```

对于这种要等待 N 个线程完成后再进行下一步的同步操作有一个简单的做法，就是使用 sync.WaitGroup 来等待一组事件：

```go
package main
import (
    "fmt"
    "sync"
)
func main() {
    var wg sync.WaitGroup
    // 开N个后台打印线程
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            fmt.Println("C语言中文网")
            wg.Done()
        }()
    }
    // 等待N个后台线程完成
    wg.Wait()
}
```

其中 wg.Add(1) 用于增加等待事件的个数，必须确保在后台线程启动之前执行（如果放到后台线程之中执行则不能保证被正常执行到）。当后台线程完成打印工作之后，调用 wg.Done() 表示完成一个事件，main() 函数的 wg.Wait() 是等待全部的事件完成。

### 26. 聊天服务器

本节将带领大家结合咱们前面所学的知识开发一个聊天的示例程序，它可以在几个用户之间相互广播文本消息。

#### 服务端程序

服务端程序中包含 4 个 goroutine，分别是一个主 goroutine 和广播（broadcaster）goroutine，每一个连接里面又包含一个连接处理（handleConn）goroutine 和一个客户写入（clientwriter）goroutine。

广播器（broadcaster）是用于如何使用 select 的一个规范说明，因为它需要对三种不同的消息进行响应。

主 goroutine 的工作是监听端口，接受连接客户端的网络连接，对每一个连接，它将创建一个新的 handleConn goroutine。

完整的示例代码如下所示：

```go
package main
import (
    "bufio"
    "fmt"
    "log"
    "net"
)
func main() {
    listener, err := net.Listen("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    go broadcaster()
    for {
        conn, err := listener.Accept()
        if err != nil {
            log.Print(err)
            continue
        }
        go handleConn(conn)
    }
}
type client chan<- string // 对外发送消息的通道
var (
    entering = make(chan client)
    leaving  = make(chan client)
    messages = make(chan string) // 所有连接的客户端
)
func broadcaster() {
    clients := make(map[client]bool)
    for {
        select {
        case msg := <-messages:
            // 把所有接收到的消息广播给所有客户端
            // 发送消息通道
            for cli := range clients {
                cli <- msg
            }
        case cli := <-entering:
            clients[cli] = true
        case cli := <-leaving:
            delete(clients, cli)
            close(cli)
        }
    }
}
func handleConn(conn net.Conn) {
    ch := make(chan string) // 对外发送客户消息的通道
    go clientWriter(conn, ch)
    who := conn.RemoteAddr().String()
    ch <- "欢迎 " + who
    messages <- who + " 上线"
    entering <- ch
    input := bufio.NewScanner(conn)
    for input.Scan() {
        messages <- who + ": " + input.Text()
    }
    // 注意：忽略 input.Err() 中可能的错误
    leaving <- ch
    messages <- who + " 下线"
    conn.Close()
}
func clientWriter(conn net.Conn, ch <-chan string) {
    for msg := range ch {
        fmt.Fprintln(conn, msg) // 注意：忽略网络层面的错误
    }
}
```

代码中 main 函数里面写的代码非常简单，其实服务器要做的事情总结一下无非就是获得 listener 对象，然后不停的获取链接上来的 conn 对象，最后把这些对象丢给处理链接函数去进行处理。

在使用 handleConn 方法处理 conn 对象的时候，对不同的链接都启一个 goroutine 去并发处理每个 conn 这样则无需等待。

由于要给所有在线的用户发送消息，而不同用户的 conn 对象都在不同的 goroutine 里面，但是Go语言中有 channel 来处理各不同 goroutine 之间的消息传递，所以在这里我们选择使用 channel 在各不同的 goroutine 中传递广播消息。

下面来介绍一下 broadcaster 广播器，它使用局部变量 clients 来记录当前连接的客户集合，每个客户唯一被记录的信息是其对外发送消息通道的 ID，下面是细节：

```go
type client chan<- string // 对外发送消息的通道
var (
    entering = make(chan client)
    leaving  = make(chan client)
    messages = make(chan string) // 所有连接的客户端
)
func broadcaster() {
    clients := make(map[client]bool)
    for {
        select {
        case msg := <-messages:
            // 把所有接收到的消息广播给所有客户端
            // 发送消息通道
            for cli := range clients {
                cli <- msg
            }
        case cli := <-entering:
            clients[cli] = true
        case cli := <-leaving:
            delete(clients, cli)
            close(cli)
        }
    }
}
```

在 main 函数里面使用 goroutine 开启了一个 broadcaster 函数来负责广播所有用户发送的消息。

这里使用一个字典来保存用户 clients，字典的 key 是各连接申明的单向并发队列。

使用一个 select 开启一个多路复用：

- 每当有广播消息从 messages 发送进来，都会循环 cliens 对里面的每个 channel 发消息。
- 每当有消息从 entering 里面发送过来，就生成一个新的 key - value，相当于给 clients 里面增加一个新的 client。
- 每当有消息从 leaving 里面发送过来，就删掉这个 key - value 对，并关闭对应的 channel。


下面再来看一下每个客户自己的 goroutine。

handleConn 函数创建一个对外发送消息的新通道，然后通过 entering 通道通知广播者新客户到来，接着它读取客户发来的每一行文本，通过全局接收消息通道将每一行发送给广播者，发送时在每条消息前面加上发送者 ID 作为前缀。一旦从客户端读取完毕消息，handleConn 通过 leaving 通道通知客户离开，然后关闭连接。

```go
func handleConn(conn net.Conn) {
    ch := make(chan string) // 对外发送客户消息的通道
    go clientWriter(conn, ch)
    who := conn.RemoteAddr().String()
    ch <- "欢迎 " + who
    messages <- who + " 上线"
    entering <- ch
    input := bufio.NewScanner(conn)
    for input.Scan() {
        messages <- who + ": " + input.Text()
    }
    // 注意：忽略 input.Err() 中可能的错误
    leaving <- ch
    messages <- who + " 下线"
    conn.Close()
}
func clientWriter(conn net.Conn, ch <-chan string) {
    for msg := range ch {
        fmt.Fprintln(conn, msg) // 注意：忽略网络层面的错误
    }
}
```

handleConn 函数会为每个过来处理的 conn 都创建一个新的 channel，开启一个新的 goroutine 去把发送给这个 channel 的消息写进 conn。

handleConn 函数的执行过程可以简单总结为如下几个步骤：

- 获取连接过来的 ip 地址和端口号；
- 把欢迎信息写进 channel 返回给客户端；
- 生成一条广播消息写进 messages 里；
- 把这个 channel 加入到客户端集合，也就是 entering <- ch；
- 监听客户端往 conn 里写的数据，每扫描到一条就将这条消息发送到广播 channel 中；
- 如果关闭了客户端，那么把队列离开写入 leaving 交给广播函数去删除这个客户端并关闭这个客户端；
- 广播通知其他客户端该客户端已关闭；
- 最后关闭这个客户端的连接 Conn.Close()。

#### 客户端程序

前面对服务端做了简单的介绍，下面介绍客户端，这里将其命名为“netcat.go”，完整代码如下所示：

```go
// netcat 是一个简单的TCP服务器读/写客户端
package main
import (
    "io"
    "log"
    "net"
    "os"
)
func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // 注意：忽略错误
        log.Println("done")
        done <- struct{}{} // 向主Goroutine发出信号
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // 等待后台goroutine完成
}
func mustCopy(dst io.Writer, src io.Reader) {
    if _, err := io.Copy(dst, src); err != nil {
        log.Fatal(err)
    }
}
```

当有 n 个客户 session 在连接的时候，程序并发运行着`2n+2 `个相互通信的 goroutine，它不需要隐式的加锁操作。clients map 限制在广播器这一个 goroutine 中被访问，所以不会并发访问它。唯一被多个 goroutine 共享的变量是通道以及 net.Conn 的实例，它们又都是并发安全的。

使用`go build `命令编译服务端和客户端，并运行生成的可执行文件。

下图中展示了在同一台计算机上运行的一个服务端和三个客户端：



![聊天程序](http://c.biancheng.net/uploads/allimg/191225/4-191225155211395.gif)



### 27. 高效的使用go语言并发特性

Go 语言原生支持并发是被众人津津乐道的特性。goroutine 早期是 Inferno 操作系统的一个试验性特性，而现在这个特性与操作系统一起，将开发变得越来越简单。

很多刚开始使用 Go 语言开发的人都很喜欢使用并发特性，而没有考虑并发是否真正能解决他们的问题。

#### 了解 goroutine 的生命期时再创建 goroutine

在 Go 语言中，开发者习惯将并发内容与 goroutine 一一对应地创建 goroutine。开发者很少会考虑 goroutine 在什么时候能退出和控制 goroutine 生命期，这就会造成 goroutine 失控的情况。下面来看一段代码。

失控的 goroutine：

```go
1.  package main

3.  import (
4.      "fmt"
5.      "runtime"
6.  )

8.  // 一段耗时的计算函数
9.  func consumer(ch chan int) {

11.      // 无限获取数据的循环
12.      for {

14.          // 从通道获取数据
15.          data := <-ch

17.          // 打印数据
18.          fmt.Println(data)
19.      }

21.  }

23.  func main() {

25.      // 创建一个传递数据用的通道
26.      ch := make(chan int)

28.      for {

30.          // 空变量, 什么也不做
31.          var dummy string

33.          // 获取输入, 模拟进程持续运行
34.          fmt.Scan(&dummy)

36.          // 启动并发执行consumer()函数
37.          go consumer(ch)

39.          // 输出现在的goroutine数量
40.          fmt.Println("goroutines:", runtime.NumGoroutine())
41.      }

43.  }
```

代码说明如下：

- 第 9 行，consumer() 函数模拟平时业务中放到 goroutine 中执行的耗时操作。该函数从其他 goroutine 中获取和接收数据或者指令，处理后返回结果。

- 第 12 行，需要通过无限循环不停地获取数据。

- 第 15 行，每次从通道中获取数据。

- 第 18 行，模拟处理完数据后的返回数据。

- 第 26 行，创建一个整型通道。

- 第 34 行，使用 fmt.Scan() 函数接收数据时，需要提供变量地址。如果输入匹配的变量类型，将会成功赋值给变量。

- 第 37 行，启动并发执行 consumer() 函数，并传入 ch 通道。

- 第 40 行，每启动一个 goroutine，使用 runtime.NumGoroutine 检查进程创建的 goroutine 数量总数。

运行程序，每输入一个字符串 + 回车，将会创建一个 goroutine，结果如下：

a goroutines: 2 b goroutines: 3 c goroutines: 4

注意，结果中 a、b、c 为通过键盘输入的字符，其他为打印字符。

这个程序实际在模拟一个进程根据需要创建 goroutine 的情况。运行后，问题已经被暴露出来：随着输入的字符串越来越多，goroutine 将会无限制地被创建，但并不会结束。这种情况如果发生在生产环境中，将会造成内存大量分配，最终使进程崩溃。现实的情况也许比这段代码更加隐蔽：也许你设置了一个退出的条件，但是条件永远不会被满足或者触发。

为了避免这种情况，在这个例子中，需要为 consumer() 函数添加合理的退出条件，修改代码后如下：

```go
  package main

  import (
      "fmt"
      "runtime"
  )

  // 一段耗时的计算函数
  func consumer(ch chan int) {

      // 无限获取数据的循环
      for {

          // 从通道获取数据
          data := <-ch

          if data == 0 {
              break
          }

          // 打印数据
          fmt.Println(data)
      }

      fmt.Println("goroutine exit")
  }

  func main() {

      // 传递数据用的通道
      ch := make(chan int)

      for {

          // 空变量, 什么也不做
          var dummy string

          // 获取输入, 模拟进程持续运行
          fmt.Scan(&dummy)

          if dummy == "quit" {

              for i := 0; i < runtime.NumGoroutine()-1; i++ {
                  ch <- 0
              }

              continue
          }

          // 启动并发执行consumer()函数
          go consumer(ch)

          // 输出现在的goroutine数量
          fmt.Println("goroutines:", runtime.NumGoroutine())
      }
  }
```

代码中加粗部分是新添加的代码，具体说明如下：

- 第 17 行，为无限循环设置退出条件，这里设置 0 为退出。

- 第 41 行，当命令行输入 quit 时，进入退出处理的流程。

- 第 43 行，runtime.NumGoroutine 返回一个进程的所有 goroutine 数，main() 的 goroutine 也被算在里面。因此需要扣除 main() 的 goroutine 数。剩下的 goroutine 为实际创建的 goroutine 数，对这些 goroutine 进行遍历。

- 第 44 行，并发开启的 goroutine 都在竞争获取通道中的数据，因此只要知道有多少个 goroutine 需要退出，就给通道里发多少个 0。

修改程序并运行，结果如下：

```go
a goroutines: 2 b goroutines: 3 quit goroutine exit goroutine exit c goroutines: 2
```

#### 避免在不必要的地方使用通道

通道（channel）和 map、切片一样，也是由 Go 源码编写而成。为了保证两个 goroutine 并发访问的安全性，通道也需要做一些锁操作，因此通道其实并不比锁高效。

下面的例子展示套接字的接收和并发管理。对于 TCP 来说，一般是接收过程创建 goroutine 并发处理。当套接字结束时，就要正常退出这些 goroutine。

本例完整代码请参考`./src/chapter12/exitnotify/exitnotify.go`。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

下面是对各个部分的详细分析。

##### 1) 套接字接收部分

套接字在连接后，就需要不停地接收数据，代码如下：

```go
  // 套接字接收过程
  func socketRecv(conn net.Conn, exitChan chan string) {

  // 创建一个接收的缓冲
      buff := make(\[\]byte, 1024)

      // 不停地接收数据
      for {

          // 从套接字中读取数据
          \_, err := conn.Read(buff)

          // 需要结束接收, 退出循环
          if err != nil {
              break
          }

      }

      // 函数已经结束, 发送通知
      exitChan <- "recv exit"
  }
```

代码说明如下：

- 第 2 行传入的 net.Conn 是套接字的接口，exitChan 为退出发送同步通道。

- 第 5 行为套接字的接收数据创建一个缓冲。

- 第 8 行构建一个接收的循环，不停地接收数据。

- 第 11 行，从套接字中取出数据。这个例子中，不关注具体接收到的数据，只是关注错误，这里将接收到的字节数做匿名处理。

- 第 14 行，当套接字调用了 Close 方法时，会触发错误，这时需要结束接收循环。

- 第 21 行，结束函数时，与函数绑定的 goroutine 会同时结束，此时需要通知 main() 的 goroutine。

##### 2) 连接、关闭、同步 goroutine 主流程部分

下面代码中尝试使用套接字的 TCP 协议连接一个网址，连接上后，进行数据接收，等待一段时间后主动关闭套接字，等待套接字所在的 goroutine 自然结束，代码如下：

```go
  func main() {

      // 连接一个地址
      conn, err := net.Dial("tcp", "www.163.com:80")

      // 发生错误时打印错误退出
      if err != nil {
          fmt.Println(err)
          return
      }

      // 创建退出通道
      exit := make(chan string)

      // 并发执行套接字接收
      go socketRecv(conn, exit)

      // 在接收时, 等待1秒
      time.Sleep(time.Second)

      // 主动关闭套接字
      conn.Close()

      // 等待goroutine退出完毕
      fmt.Println(<-exit)
  }
```

代码说明如下：

- 第 4 行，使用 net.Dial 发起 TCP 协议的连接，调用函数就会发送阻塞直到连接超时或者连接完成。

- 第 7 行，如果连接发生错误，将会打印错误并退出。

- 第 13 行，创建一个通道用于退出信号同步，这个通道会在接收用的 goroutine 中使用。

- 第 16 行，并发执行接收函数，传入套接字和用于退出通知的通道。

- 第 19 行，接收需要一个过程，使用 time.Sleep() 等待一段时间。

- 第 22 行，主动关闭套接字，此时会触发套接字接收错误。

- 第 25 行，从 exit 通道接收退出数据，也就是等待接收 goroutine 结束。

在这个例子中，goroutine 退出使用通道来通知，这种做法可以解决问题，但是实际上通道中的数据并没有完全使用。

##### 3) 优化：使用等待组替代通道简化同步

通道的内部实现代码在 Go 语言开发包的 src/runtime/chan.go 中，经过分析后大概了解到通道也是用常见的互斥量等进行同步。因此通道虽然是一个语言级特性，但也不是被神化的特性，通道的运行和使用都要比传统互斥量、等待组（sync.WaitGroup）有一定的消耗。

所以在这个例子中，更建议使用等待组来实现同步，调整后的代码如下：

```go
  package main

  import (
      "fmt"
      "net"
      "sync"
      "time"
  )

  // 套接字接收过程
  func socketRecv(conn net.Conn, wg *sync.WaitGroup) {

      // 创建一个接收的缓冲
      buff := make([]byte, 1024)

      // 不停地接收数据
      for {

          // 从套接字中读取数据
          _, err := conn.Read(buff)

          // 需要结束接收, 退出循环
          if err != nil {
              break
          }

      }

      // 函数已经结束, 发送通知
      wg.Done()
  }

  func main() {

      // 连接一个地址
      conn, err := net.Dial("tcp", "www.163.com:80")

      // 发生错误时打印错误退出
      if err != nil {
          fmt.Println(err)
          return
      }

      // 退出通道
      var wg sync.WaitGroup

      // 添加一个任务
      wg.Add(1)

      // 并发执行接收套接字
      go socketRecv(conn, &wg)

      // 在接收时, 等待1秒
      time.Sleep(time.Second)

      // 主动关闭套接字
      conn.Close()

      // 等待goroutine退出完毕
      wg.Wait()
      fmt.Println("recv done")
  }
```

调整后的代码说明如下：

- 第 45 行，声明退出同步用的等待组。

- 第 48 行，为等待组的计数器加 1，表示需要完成一个任务。

- 第 51 行，将等待组的指针传入接收函数。

- 第 60 行，等待等待组的完成，完成后打印提示。

- 第 30 行，接收完成后，使用 wg.Done() 方法将等待组计数器减一。

### 28. 使用select切换协程

从不同的并发执行的协程中获取值可以通过关键字 select 来完成，它和 switch 控制语句非常相似也被称作通信开关；它的行为像是 “你准备好了吗” 的轮询机制；select 监听进入通道的数据，也可以是用通道发送值的时候。

```go
select {
case u:= <- ch1:
    …
case v:= <- ch2:
    …
    …
default: // no value ready to be received
    …
}
```

default 语句是可选的；fallthrough 行为，和普通的 switch 相似，是不允许的。在任何一个 case 中执行 break 或者 return，select 就结束了。

select 做的就是：选择处理列出的多个通信情况中的一个。

- 如果都阻塞了，会等待直到其中一个可以处理

- 如果多个可以处理，随机选择一个

- 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）。

在 select 中使用发送操作并且有 default 可以确保发送不被阻塞！如果没有 case，select 就会一直阻塞。

select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。

在下面的示例程序中有 2 个通道 ch1 和 ch2 ，三个协程 pump1() 、pump2() 和 suck() 。这是一个典型的生产者消费者模式。在无限循环中，ch1 和 ch2 通过 pump1() 和 pump2() 填充整数；suck() 也是在无限循环中轮询输入的，通过 select 语句获取 ch1 和 ch2 的整数并输出。选择哪一个 case 取决于哪一个通道收到了信息。程序在 main 执行 1 秒后结束。

```go
  package main
  import (
      "fmt"
      "time"
  )
  func main() {
      ch1 := make(chan int)
      ch2 := make(chan int)
      go pump1(ch1)
      go pump2(ch2)
      go suck(ch1, ch2)
      time.Sleep(1e9)
  }
  func pump1(ch chan int) {
      for i := 0; ; i++ {
          ch <- i * 2
      }
  }
  func pump2(ch chan int) {
      for i := 0; ; i++ {
          ch <- i + 5
      }
  }
  func suck(ch1, ch2 chan int) {
      for {
          select {
          case v := <-ch1:
              fmt.Printf("Received on channel 1: %d\n", v)
          case v := <-ch2:
              fmt.Printf("Received on channel 2: %d\n", v)
          }
      }
  }
```

输出：

```go
Received on channel 2: 5
Received on channel 2: 6
Received on channel 1: 0
Received on channel 2: 7
Received on channel 2: 8
Received on channel 2: 9
Received on channel 2: 10
Received on channel 1: 2
Received on channel 2: 11
…
Received on channel 2: 47404
Received on channel 1: 94346
Received on channel 1: 94348
```

一秒内的输出非常惊人，如果我们给它计数，得到了 90000 个左右的数字。

### 29. 加密通信

一般的 HTTPS 是基于 SSL（Secure Sockets Layer）协议。SSL 是网景公司开发的位于 TCP 与 HTTP 之间的透明安全协议，通过 SSL，可以把 HTTP 包数据以非对称加密的形式往返于浏览器和站点之间，从而避免被第三方非法获取。

目前，伴随着电子商务的兴起，HTTPS 获得了广泛的应用。由 IETF（Internet Engineering Task Force）实现的 TLS（Transport Layer Security）是建立于 SSL v3.0 之上的兼容协议，它们主要的区别在于所支持的加密算法。

#### 加密通信流程

当用户在浏览器中输入一个以 https 开头的网址时，便开启了浏览器与被访问站点之间的加密通信。下面我们以百度 https://www.baidu.com/ 为例，为大家展现一下 SSL/TLS 的工作方式。

1. 在浏览器中输入 HTTPS 协议的网址，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/200118/4-20011Q3591HI.gif)](http://c.biancheng.net/uploads/allimg/200118/4-20011Q3591HI.gif)

1. 服务器向浏览器返回证书，浏览器检查该证书的合法性，如下图所示。

[![img](https://tva1.sinaimg.cn/large/008i3skNly1guu9sfc8ceg60m808u3yr02.gif)

1. 验证合法性，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/200118/4-20011Q40001507.gif)](http://c.biancheng.net/uploads/allimg/200118/4-20011Q40001507.gif)

1. 浏览器使用证书中的公钥加密一个随机对称密钥，并将加密后的密钥和使用密钥加密后的请求 URL 一起发送到服务器。

1. 服务器用私钥解密随机对称密钥，并用获取的密钥解密加密的请求 URL。

1. 服务器把用户请求的网页用密钥加密，并返回给用户。

1. 用户浏览器用密钥解密服务器发来的网页数据，并将其显示出来。

上述过程都是依赖于 SSL/TLS 层实现的。在实际开发中，SSL/TLS 的实现和工作原理比较复杂，但基本流程与上面的过程一致。

SSL 协议由两层组成，上层协议包括 SSL 握手协议、更改密码规格协议、警报协议，下层协议包括 SSL 记录协议。

SSL 握手协议建立在 SSL 记录协议之上，在实际的数据传输开始前，用于在客户与服务器之间进行 “握手”。“握手” 是一个协商过程。这个协议使得客户和服务器能够互相鉴别身份，协商加密算法。在任何数据传输之前，必须先进行“握手”。

在 “握手” 完成之后，才能进行 SSL 记录协议，它的主要功能是为高层协议提供数据封装、压缩、添加 MAC、加密等支持。

#### 支持 HTTPS 的 Web 服务器

Go 语言目前实现了 TLS 协议的部分功能，已经可以提供最基础的安全层服务。下面我们来看一下如何实现支持 TLS 的 Web 服务器。下面的代码示范了如何使用 http.ListenAndServerTLS 实现一个支持 HTTPS 的 Web 服务器。

```go
  package main

  import (
      "fmt"
      "net/http"
  )

  const RESPONSE\_TEMPLATE = "C语言中文网"

  func rootHandler(w http.ResponseWriter, req *http.Request) {
      w.Header().Set("Content-Type", "text/plain")
      w.Header().Set("Content-Length", fmt.Sprint(len(RESPONSE_TEMPLATE)))
      w.Write([]byte(RESPONSE\_TEMPLATE))
  }
  func main() {
      http.HandleFunc("/", rootHandler)
      http.ListenAndServeTLS(":8080", "cert.pem", "key.pem", nil)
  }
```

运行上面的程序需要用到 cert.pem 和 key.pem 这两个文件，可以使用 crypto/tls 包的 generate_cert.go 文件来生成，运行成功后我们可以在浏览器中通过 [https://localhost:8080](https://localhost:8080/) 查看访问效果，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/200118/4-20011Q40A2443.gif)](http://c.biancheng.net/uploads/allimg/200118/4-20011Q40A2443.gif)

可以看到，我们使用了 http.ListenAndServerTLS() 这个方法，这表明它是执行在 TLS 层上的 HTTP 协议。如果我们并不需要支持 HTTPS，只需要把该方法替换为 http.ListenAndServeTLS(fmt.Sprintf(“:%d”, SERVER_PORT), nil) 即可。

#### 支持 HTTPS 的文件服务器

利用 Go 语言标准库中提供的完备封装，我们也可以很容易实现一个支持 HTTPS 的文件服务器，代码如下所示。

```go
  package main

  import (
      "net/http"
  )

  func main() {
      h := http.FileServer(http.Dir("."))
      http.ListenAndServeTLS(":8001", "cert.pem", "key.pem", h)
  }
```

运行效果如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/200118/4-20011Q42I5302.gif)](http://c.biancheng.net/uploads/allimg/200118/4-20011Q42I5302.gif)

#### 基于 SSL/TLS 的 ECHO 程序

在本章最后，我们用一个完整的安全版 ECHO 程序来演示如何让 Socket 通信也支持 HTTPS。当然，ECHO 程序支持 HTTPS 似乎没有什么必要，但这个程序可以比较容易地改造成有实际价值的程序，比如安全的聊天工具等。

下面我们首先实现这个超级 ECHO 程序的服务器端，代码如下所示。

```go
  package main
  import (
      "crypto/rand"
      "crypto/tls"
      "io"
      "log"
      "net"
      "time"
  )
  func main() {
      cert, err := tls.LoadX509KeyPair("rui.crt", "rui.key")
      if err != nil {
          log.Fatalf("server: loadkeys: %s", err)
      }
      config := tls.Config{Certificates:[]tls.Certificate{cert}}
      config.Time = time.Now
      config.Rand = rand.Reader
      service := "127.0.0.1:8000"
      listener, err := tls.Listen("tcp", service, &config)
      if err != nil {
          log.Fatalf("server: listen: %s", err)
      }
      log.Print("server: listening")
      for {
          conn, err := listener.Accept()
          if err != nil {
              log.Printf("server: accept: %s", err)
              break
          }
          log.Printf("server: accepted from %s", conn.RemoteAddr())
          go handleClient(conn)
      }
  }
  func handleClient(conn net.Conn) {
      defer conn.Close()
      buf := make([]byte, 512)
      for {
          log.Print("server: conn: waiting")
          n, err := conn.Read(buf)
          if err != nil {
              if err != io.EOF {
                  log.Printf("server: conn: read: %s", err)
              }
              break
          }
          log.Printf("server: conn: echo %q\n", string(buf[:n]))
          n, err = conn.Write(buf[:n])
          log.Printf("server: conn: wrote %d bytes", n)
          if err != nil {
              log.Printf("server: write: %s", err)
              break
          }
      }
      log.Println("server: conn: closed")
  }
```

现在服务器端已经实现了。我们再实现超级 ECHO 的客户端，代码如下所示。

```go
  package main
  import (
      "crypto/tls"
      "io"
      "log"
  )
  func main() {
      conn, err := tls.Dial("tcp", "127.0.0.1:8000", nil)
      if err != nil {
          log.Fatalf("client: dial: %s", err)
      }
      defer conn.Close()
      log.Println("client: connected to: ", conn.RemoteAddr())
      state := conn.ConnectionState()
      log.Println("client: handshake: ", state.HandshakeComplete)
      log.Println("client: mutual: ", state.NegotiatedProtocolIsMutual)
      message := "Hello\n"
      n, err := io.WriteString(conn, message)
      if err != nil {
          log.Fatalf("client: write: %s", err)
      }
      log.Printf("client: wrote %q (%d bytes)", message, n)
      reply := make([]byte, 256)
      n, err = conn.Read(reply)
      log.Printf("client: read %q (%d bytes)", string(reply[:n]), n)
      log.Print("client: exiting")
  }
```

接下来我们分别编译和运行服务器端和客户端程序，可以看到类似以下的运行效果。

服务器端的输出结果为：

```go
2012/04/06 13:48:24 server: listening
2012/04/06 13:50:41 server: accepted from 127.0.0.1:15056
2012/04/06 13:50:41 server: conn: waiting
2012/04/06 13:50:41 server: conn: echo “Hello\n”
2012/04/06 13:50:41 server: conn: wrote 6 bytes
2012/04/06 13:50:41 server: conn: waiting
2012/04/06 13:50:41 server: conn: closed
```

客户端的输出结果为：

```go
2012/04/06 13:50:41 client: connected to: 127.0.0.1:8000
2012/04/06 13:50:41 client: handshake: true
2012/04/06 13:50:41 client: mutual: true
2012/04/06 13:50:41 client: wrote “Hello\n” (6 bytes)
2012/04/06 13:50:41 client: read “Hello\n” (6 bytes)
2012/04/06 13:50:41 client: exiting
```

需要注意的是，SSL/TLS 协议只能运行于 TCP 之上，不能在 UDP 上工作，且 SSL/TLS 位于 TCP 与应用层协议之间，因此所有基于 TCP 的应用层协议都可以透明地使用 SSL/TLS 为自己提供安全保障。所谓透明地使用是指既不需要了解细节，也不需要专门处理该层的包，比如封装、解封等。

## 第十章 反射

### 1. 反射（reflection）简述

反射（reflection）是在 [Java](http://c.biancheng.net/java/) 出现后迅速流行起来的一种概念，通过反射可以获取丰富的类型信息，并可以利用这些类型信息做非常灵活的工作。

大多数现代的高级语言都以各种形式支持反射功能，反射是把双刃剑，功能强大但代码可读性并不理想，若非必要并不推荐使用反射。

下面我们就来将介绍一下反射在Go语言中的具体体现以及反射的基本使用方法。

#### 反射的基本概念

Go语言提供了一种机制在运行时更新和检查变量的值、调用变量的方法和变量支持的内在操作，但是在编译时并不知道这些变量的具体类型，这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。

反射是指在程序运行期对程序本身进行访问和修改的能力，程序在编译时变量被转换为内存地址，变量名不会被编译器写入到可执行部分，在运行程序时程序无法获取自身的信息。

支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。

C/[C++](http://c.biancheng.net/cplus/)语言没有支持反射功能，只能通过 typeid 提供非常弱化的程序运行时类型信息；Java、[C#](http://c.biancheng.net/csharp/) 等语言都支持完整的反射功能；Lua、[JavaScript](http://c.biancheng.net/js/) 类动态语言，由于其本身的语法特性就可以让代码在运行期访问程序自身的值和类型信息，因此不需要反射系统。

Go语言程序的反射系统无法获取到一个可执行文件空间中或者是一个包中的所有类型信息，需要配合使用标准库中对应的词法、语法解析器和抽象语法树（AST）对源码进行扫描后获得这些信息。

Go语言提供了 reflect 包来访问程序的反射信息。

#### reflect 包

Go语言中的反射是由 reflect 包提供支持的，它定义了两个重要的类型 Type 和 Value 任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。

#### 反射的类型对象（reflect.Type）

在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var a int
    typeOfA := reflect.TypeOf(a)
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

运行结果如下：

```go
int int
```

代码说明如下：

- 第 9 行，定义一个 int 类型的变量。
- 第 10 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。
- 第 11 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。

#### 反射的类型（Type）与种类（Kind）

在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。

##### 1) 反射种类（Kind）的定义

Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。

种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：

```go
type Kind uint
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
```

Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。

##### 2) 从类型对象中获取类型名称和种类

Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。

下面的代码中会对常量和结构体进行类型信息获取。

```go
package main
import (
    "fmt"
    "reflect"
)
// 定义一个Enum类型
type Enum int
const (
    Zero Enum = 0
)
func main() {
    // 声明一个空结构体
    type cat struct {
    }
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(cat{})
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())
    // 获取Zero常量的反射类型对象
    typeOfA := reflect.TypeOf(Zero)
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

运行结果如下：

```go
cat struct
Enum int
```

代码说明如下：

- 第 17 行，声明结构体类型 cat。
- 第 20 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。
- 第 22 行，输出 cat 的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。
- 第 24 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。
- 第 26 行，输出 Zero 对应的类型对象的类型名和种类。

#### 指针与指针指向的元素

Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个`*`操作，代码如下：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明一个空结构体
    type cat struct {
    }
    // 创建cat的实例
    ins := &cat{}
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(ins)
    // 显示反射类型对象的名称和种类
    fmt.Printf("name:'%v' kind:'%v'\n", typeOfCat.Name(), typeOfCat.Kind())
    // 取类型的元素
    typeOfCat = typeOfCat.Elem()
    // 显示反射类型对象的名称和种类
    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())
}
```

运行结果如下：

```go
name:'' kind:'ptr'
element name: 'cat', element kind: 'struct'
```

代码说明如下：

- 第 13 行，创建了 cat 结构体的实例，ins 是一个 *cat 类型的指针变量。
- 第 15 行，对指针变量获取反射类型信息。
- 第 17 行，输出指针变量的类型名称和种类。Go语言的反射中对所有指针变量的种类都是 Ptr，但需要注意的是，指针变量的类型名称是空，不是 *cat。
- 第 19 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。
- 第 21 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。

#### 使用反射获取结构体的成员类型

任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。

与成员获取相关的 reflect.Type 的方法如下表所示。

| 方法                                                        | 说明                                                         |
| ----------------------------------------------------------- | ------------------------------------------------------------ |
| Field(i int) StructField                                    | 根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机 |
| NumField() int                                              | 返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机 |
| FieldByName(name string) (StructField, bool)                | 根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机 |
| FieldByIndex(index []int) StructField                       | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机 |
| FieldByNameFunc(match func(string) bool) (StructField,bool) | 根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机 |

##### 1) 结构体字段类型

reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（StructTag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。

StructField 的结构如下：

```go
type StructField struct {
    Name string          // 字段名
    PkgPath string       // 字段路径
    Type      Type       // 字段反射类型对象
    Tag       StructTag  // 字段的结构体标签
    Offset    uintptr    // 字段在结构体中的相对偏移
    Index     []int      // Type.FieldByIndex中的返回的索引值
    Anonymous bool       // 是否为匿名字段
}
```

字段说明如下：

- Name：为字段名称。
- PkgPath：字段在结构体中的路径。
- Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。
- Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。
- Index：FieldByIndex 中的索引顺序。
- Anonymous：表示该字段是否为匿名字段。

##### 2) 获取成员反射信息

下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。

反射访问结构体成员类型及信息：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明一个空结构体
    type cat struct {
        Name string
        // 带有结构体tag的字段
        Type int `json:"type" id:"100"`
    }
    // 创建cat的实例
    ins := cat{Name: "mimi", Type: 1}
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(ins)
    // 遍历结构体所有成员
    for i := 0; i < typeOfCat.NumField(); i++ {
        // 获取每个成员的结构体字段类型
        fieldType := typeOfCat.Field(i)
        // 输出成员名和tag
        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)
    }
    // 通过字段名, 找到字段类型信息
    if catType, ok := typeOfCat.FieldByName("Type"); ok {
        // 从tag中取出需要的tag
        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))
    }
}
```

代码输出如下：

```go
name: Name tag: ''
name: Type tag: 'json:"type" id:"100"'
type 100
```

代码说明如下：

- 第 10 行，声明了带有两个成员的 cat 结构体。
- 第 13 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以 ` 开始和结尾的字符串。这个字符串在Go语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。
- 第 16 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。
- 第 18 行，获取实例的反射类型对象。
- 第 20 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。
- 第 22 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。
- 第 24 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是 StructField 结构体。
- 第 27 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，catType 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。
- 第 29 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。

#### 结构体标签（Struct Tag）

通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。

JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。

##### 1) 结构体标签的格式

Tag 在结构体字段后方书写的格式如下：

```go
`key1:"value1" key2:"value2"`
```

结构体标签由一个或多个键值对组成；键与值使用冒号分隔，值用双引号括起来；键值对之间使用一个空格分隔。

##### 2) 从结构体标签中获取值

StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：

- `func (tag StructTag) Get(key string) string`：根据 Tag 中的键获取对应的值，例如``key1:"value1" key2:"value2"``的 Tag 中，可以传入“key1”获得“value1”。
- `func (tag StructTag) Lookup(key string) (value string, ok bool)`：根据 Tag 中的键，查询值是否存在。

##### 3) 结构体标签格式错误导致的问题

编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，示例代码如下：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    type cat struct {
        Name string
        Type int `json: "type" id:"100"`
    }
    typeOfCat := reflect.TypeOf(cat{})
    if catType, ok := typeOfCat.FieldByName("Type"); ok {
        fmt.Println(catType.Tag.Get("json"))
    }
}
```

运行上面的代码会输出一个空字符串，并不会输出期望的 type。

代码第 11 行中，在 json: 和 "type" 之间增加了一个空格，这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。这个错误在开发中非常容易被疏忽，造成难以察觉的错误。所以将第 12 行代码修改为下面的样子，则可以正常打印。

```go
type cat struct {
    Name string
    Type int `json:"type" id:"100"`
}
```

运行结果如下：

```go
type
```

### 2.  反射规则浅析

反射是众多编程语言中的一个非常实用的功能，它是一种能够自描述、自控制的应用，Go语言也对反射提供了友好的支持。

Go语言中使用反射可以在编译时不知道类型的情况下更新变量，在运行时查看值、调用方法以及直接对他们的布局进行操作。

由于反射是建立在类型系统（type system）上的，所以我们先来复习一下Go语言中的类型。

#### Go语言中的类型

Go语言是一门静态类型的语言，每个变量都有一个静态类型，类型在编译的时候确定下来。

```go
type MyInt int

var i int
var j MyInt
```

变量 i 的类型是 int，变量 j 的类型是 MyInt，虽然它们有着相同的基本类型，但静态类型却不一样，在没有类型转换的情况下，它们之间无法互相赋值。

接口是一个重要的类型，它意味着一个确定的方法集合，一个接口变量可以存储任何实现了接口的方法的具体值（除了接口本身），例如 io.Reader 和 io.Writer：

```go
// Reader is the interface that wraps the basic Read method.
type Reader interface {
  Read(p []byte) (n int, err error)
}

// Writer is the interface that wraps the basic Write method.
type Writer interface {
  Write(p []byte) (n int, err error)
}
```

如果一个类型声明实现了 Reader（或 Writer）方法，那么它便实现了 io.Reader（或 io.Writer），这意味着一个 io.Reader 的变量可以持有任何一个实现了 Read 方法的的类型的值。

```go
var r io.Reader
r = os.Stdin
r = bufio.NewReader(r)
r = new(bytes.Buffer)
// and so on
```

必须要弄清楚的一点是，不管变量 r 中的具体值是什么，r 的类型永远是 io.Reader，由于Go语言是静态类型的，r 的静态类型就是 io.Reader。

在接口类型中有一个极为重要的例子——空接口：

```go
interface{}
```

它表示了一个空的方法集，一切值都可以满足它，因为它们都有零值或方法。

有人说Go语言的接口是动态类型，这是错误的，它们都是静态类型，虽然在运行时中，接口变量存储的值也许会变，但接口变量的类型是不会变的。我们必须精确地了解这些，因为反射与接口是密切相关的。

关于接口我们就介绍到这里，下面我们看看Go语言的反射三定律。

#### 反射第一定律：反射可以将“接口类型变量”转换为“反射类型对象”

```go
注：这里反射类型指 reflect.Type 和 reflect.Value。
```

从使用方法上来讲，反射提供了一种机制，允许程序在运行时检查接口变量内部存储的 (value, type) 对。

在最开始，我们先了解下 reflect 包的两种类型 Type 和 Value，这两种类型使访问接口内的数据成为可能，它们对应两个简单的方法，分别是 reflect.TypeOf 和 reflect.ValueOf，分别用来读取接口变量的 reflect.Type 和 reflect.Value 部分。

当然，从 reflect.Value 也很容易获取到 reflect.Type，目前我们先将它们分开。

首先，我们下看 reflect.TypeOf：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    fmt.Println("type:", reflect.TypeOf(x))
}
```

运行结果如下：

```go
type: float64
```

大家可能会疑惑，为什么没看到接口？这段代码看起来只是把一个 float64 类型的变量 x 传递给 reflect.TypeOf 并没有传递接口。其实在 reflect.TypeOf 的函数签名里包含一个空接口：

```go
// TypeOf returns the reflection Type of the value in the interface{}.
func TypeOf(i interface{}) Type
```

我们调用 reflect.TypeOf(x) 时，x 被存储在一个空接口变量中被传递过去，然后 reflect.TypeOf 对空接口变量进行拆解，恢复其类型信息。

函数 reflect.ValueOf 也会对底层的值进行恢复：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    fmt.Println("value:", reflect.ValueOf(x))
}
```

运行结果如下：

```go
value: 3.4
```

类型 reflect.Type 和 reflect.Value 都有很多方法，我们可以检查和使用它们，这里我们举几个例子。

类型 reflect.Value 有一个方法 Type()，它会返回一个 reflect.Type 类型的对象。

Type 和 Value 都有一个名为 Kind 的方法，它会返回一个常量，表示底层数据的类型，常见值有：Uint、Float64、Slice 等。

Value 类型也有一些类似于 Int、Float 的方法，用来提取底层的数据：

- Int 方法用来提取 int64
- Float 方法用来提取 float64，示例代码如下：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    fmt.Println("type:", v.Type())
    fmt.Println("kind is float64:", v.Kind() == reflect.Float64)
    fmt.Println("value:", v.Float())
}
```

运行结果如下：

```go
type: float64
kind is float64: true
value: 3.4
```

还有一些用来修改数据的方法，比如 SetInt、SetFloat。在介绍它们之前，我们要先理解“可修改性”（settability），这一特性会在下面进行详细说明。

反射库提供了很多值得列出来单独讨论的属性，下面就来介绍一下。

首先是介绍下 Value 的 getter 和 setter 方法，为了保证 API 的精简，这两个方法操作的是某一组类型范围最大的那个。比如，处理任何含符号整型数，都使用 int64，也就是说 Value 类型的 Int 方法返回值为 int64 类型，SetInt 方法接收的参数类型也是 int64 类型。实际使用时，可能需要转化为实际的类型：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x uint8 = 'x'
    v := reflect.ValueOf(x)
    fmt.Println("type:", v.Type())                            // uint8.
    fmt.Println("kind is uint8: ", v.Kind() == reflect.Uint8) // true.
    x = uint8(v.Uint())                                       // v.Uint returns a uint64.
}
```

运行结果如下：

```go
type: uint8
kind is uint8: true
```

其次，反射对象的 Kind 方法描述的是基础类型，而不是静态类型。如果一个反射对象包含了用户定义类型的值，如下所示：

```go
type MyInt int
var x MyInt = 7
v := reflect.ValueOf(x)
```

上面的代码中，虽然变量 v 的静态类型是 MyInt，而不是 int，但 Kind 方法仍然会返回 reflect.Int。换句话说 Kind 方法不会像 Type 方法一样区分 MyInt 和 int。

#### 反射第二定律：反射可以将“反射类型对象”转换为“接口类型变量”

和物理学中的反射类似，Go语言中的反射也能创造自己反面类型的对象。

根据一个 reflect.Value 类型的变量，我们可以使用 Interface 方法恢复其接口类型的值。事实上，这个方法会把 type 和 value 信息打包并填充到一个接口变量中，然后返回。

其函数声明如下：

```go
// Interface returns v's value as an interface{}.
func (v Value) Interface() interface{}
```

然后，我们可以通过断言，恢复底层的具体值：

```go
y := v.Interface().(float64) // y will have type float64.
fmt.Println(y)
```

上面这段代码会打印出一个 float64 类型的值，也就是反射类型变量 v 所代表的值。

事实上，我们可以更好地利用这一特性，标准库中的 fmt.Println 和 fmt.Printf 等函数都接收空接口变量作为参数，fmt 包内部会对接口变量进行拆包，因此 fmt 包的打印函数在打印 reflect.Value 类型变量的数据时，只需要把 Interface 方法的结果传给格式化打印程序：

```go
fmt.Println(v.Interface())
```

为什么不直接使用 fmt.Println(v)？因为 v 的类型是 reflect.Value，我们需要的是它的具体值，由于值的类型是 float64，我们也可以用浮点格式化打印它：

```go
fmt.Printf("value is %7.1e\n", v.Interface())
```

运行结果如下：

```go
3.4e+00
```

同样，这次也不需要对 v.Interface() 的结果进行类型断言，空接口值内部包含了具体值的类型信息，Printf 函数会恢复类型信息。

简单来说 Interface 方法和 ValueOf 函数作用恰好相反，唯一一点是，返回值的静态类型是 interface{}。

Go的反射机制可以将“接口类型的变量”转换为“反射类型的对象”，然后再将“反射类型对象”转换过去。

#### 反射第三定律：如果要修改“反射类型对象”其值必须是“可写的”

这条定律很微妙，也很容易让人迷惑，但是如果从第一条定律开始看，应该比较容易理解。

下面这段代码虽然不能正常工作，但是非常值得研究：

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
v.SetFloat(7.1) // Error: will panic
```

如果运行这段代码，它会抛出一个奇怪的异常：

```go
panic: reflect: reflect.flag.mustBeAssignable using unaddressable value
```

这里问题不在于值`7.1 `不能被寻址，而是因为变量 v 是“不可写的”，“可写性”是反射类型变量的一个属性，但不是所有的反射类型变量都拥有这个属性。

我们可以通过 CanSet 方法检查一个 reflect.Value 类型变量的“可写性”，对于上面的例子，可以这样写：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    v := reflect.ValueOf(x)
    fmt.Println("settability of v:", v.CanSet())
}
```

运行结果如下：

```go
settability of v: false
```

对于一个不具有“可写性”的 Value 类型变量，调用 Set 方法会报出错误。

首先我们要弄清楚什么是“可写性”，“可写性”有些类似于寻址能力，但是更严格，它是反射类型变量的一种属性，赋予该变量修改底层存储数据的能力。“可写性”最终是由一个反射对象是否存储了原始值而决定的。

示例代码如下：

```go
var x float64 = 3.4
v := reflect.ValueOf(x)
```

这里我们传递给 reflect.ValueOf 函数的是变量 x 的一个拷贝，而非 x 本身，想象一下如果下面这行代码能够成功执行：

```go
v.SetFloat(7.1)
```

如果这行代码能够成功执行，它不会更新 x，虽然看起来变量 v 是根据 x 创建的，相反它会更新 x 存在于反射对象 v 内部的一个拷贝，而变量 x 本身完全不受影响。这会造成迷惑，并且没有任何意义，所以是不合法的。“可写性”就是为了避免这个问题而设计的。

这看起来很诡异，事实上并非如此，而且类似的情况很常见。考虑下面这行代码：

```go
f(x)
```

代码中，我们把变量 x 的一个拷贝传递给函数，因此不期望它会改变 x 的值。如果期望函数 f 能够修改变量 x，我们必须传递 x 的地址（即指向 x 的指针）给函数 f，如下所示：

```go
f(&x)
```

反射的工作机制与此相同，如果想通过反射修改变量 x，就要把想要修改的变量的指针传递给反射库。

首先，像通常一样初始化变量 x，然后创建一个指向它的反射对象，命名为 p：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    p := reflect.ValueOf(&x) // Note: take the address of x.
    fmt.Println("type of p:", p.Type())
    fmt.Println("settability of p:", p.CanSet())
}
```

运行结果如下：

```go
type of p: *float64
settability of p: false
```

反射对象 p 是不可写的，但是我们也不像修改 p，事实上我们要修改的是 *p。为了得到 p 指向的数据，可以调用 Value 类型的 Elem 方法。Elem 方法能够对指针进行“解引用”，然后将结果存储到反射 Value 类型对象 v 中：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    p := reflect.ValueOf(&x) // Note: take the address of x.
    v := p.Elem()
    fmt.Println("settability of v:", v.CanSet())
}
```

运行结果如下：

```go
settability of v: true
```

由于变量 v 代表 x， 因此我们可以使用 v.SetFloat 修改 x 的值：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var x float64 = 3.4
    p := reflect.ValueOf(&x) // Note: take the address of x.
    v := p.Elem()
    v.SetFloat(7.1)
    fmt.Println(v.Interface())
    fmt.Println(x)
}
```

运行结果如下：

```go
7.1
7.1
```

反射不太容易理解，reflect.Type 和 reflect.Value 会混淆正在执行的程序，但是它做的事情正是编程语言做的事情。只需要记住：只要反射对象要修改它们表示的对象，就必须获取它们表示的对象的地址。

#### 结构体

我们一般使用反射修改结构体的字段，只要有结构体的指针，我们就可以修改它的字段。

下面是一个解析结构体变量 t 的例子，用结构体的地址创建反射变量，再修改它。然后我们对它的类型设置了 typeOfT，并用调用简单的方法迭代字段。

需要注意的是，我们从结构体的类型中提取了字段的名字，但每个字段本身是正常的 reflect.Value 对象。

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    type T struct {
        A int
        B string
    }
    t := T{23, "skidoo"}
    s := reflect.ValueOf(&t).Elem()
    typeOfT := s.Type()
    for i := 0; i < s.NumField(); i++ {
        f := s.Field(i)
        fmt.Printf("%d: %s %s = %v\n", i,
            typeOfT.Field(i).Name, f.Type(), f.Interface())
    }
}
```

运行结果如下：

```go
0: A int = 23
1: B string = skidoo
```

T 字段名之所以大写，是因为结构体中只有可导出的字段是“可设置”的。

因为 s 包含了一个可设置的反射对象，我们可以修改结构体字段：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    type T struct {
        A int
        B string
    }
    t := T{23, "skidoo"}
    s := reflect.ValueOf(&t).Elem()
    s.Field(0).SetInt(77)
    s.Field(1).SetString("Sunset Strip")
    fmt.Println("t is now", t)
}
```

运行结果如下：

```go
t is now {77 Sunset Strip}
```

如果我们修改了程序让 s 由 t（而不是 &t）创建，程序就会在调用 SetInt 和 SetString 的地方失败，因为 t 的字段是不可设置的。

#### 总结

反射规则可以总结为如下几条：

- 反射可以将“接口类型变量”转换为“反射类型对象”；
- 反射可以将“反射类型对象”转换为“接口类型变量”；
- 如果要修改“反射类型对象”，其值必须是“可写的”。

### 3. 反射（性能和灵活性的双刃剑）

现在的一些流行设计思想需要建立在反射基础上，如控制反转（Inversion Of Control，IOC）和依赖注入（Dependency Injection，DI）。Go 语言中非常有名的 Web 框架 martini（https://github.com/go-martini/martini）就是通过依赖注入技术进行中间件的实现，例如使用 martini 框架搭建的 http 的服务器如下：

```go
  package main

  import "github.com/go-martini/martini"

  func main() {
      m := martini.Classic()
      m.Get("/", func() string {
          return "Hello world!"
      })
      m.Run()
  }
```

第 7 行，响应路径`/`的代码使用一个闭包实现。如果希望获得 Go 语言中提供的请求和响应接口，可以直接修改为：

```go
  m.Get("/", func(res http.ResponseWriter, req *http.Request) string {
      // 响应处理代码……
  })
```

martini 的底层会自动通过识别 Get 获得的闭包参数情况，通过动态反射调用这个函数并传入需要的参数。martini 的设计广受好评，但同时也有人指出，其运行效率较低。其中最主要的因素是大量使用了反射。

虽然一般情况下，I/O 的延迟远远大于反射代码所造成的延迟。但是，更低的响应速度和更低的 CPU 占用依然是 Web 服务器追求的目标。因此，反射在带来灵活性的同时，也带上了性能低下的桎梏。

要用好反射这把双刃剑，就需要详细了解反射的性能。下面的一些基准测试从多方面对比了原生调用和反射调用的区别。

##### 1) 结构体成员赋值对比

反射经常被使用在结构体上，因此结构体的成员访问性能就成为了关注的重点。下面例子中使用一个被实例化的结构体，访问它的成员，然后使用 Go 语言的基准化测试可以迅速测试出结果。

反射性能测试的完整代码位于`./src/chapter12/reflecttest/reflect_test.go`，下面是对各个部分的详细说明。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

原生结构体的赋值过程：

```go
  // 声明一个结构体, 拥有一个字段
  type data struct {
      Hp int
  }

  func BenchmarkNativeAssign(b *testing.B) {

      // 实例化结构体
      v := data{Hp: 2}

      // 停止基准测试的计时器
      b.StopTimer()
      // 重置基准测试计时器数据
      b.ResetTimer()

      // 重新启动基准测试计时器
      b.StartTimer()

      // 根据基准测试数据进行循环测试
      for i := 0; i < b.N; i++ {

          // 结构体成员赋值测试
          v.Hp = 3
      }

  }
```

代码说明如下：

- 第 2 行，声明一个普通结构体，拥有一个成员变量。

- 第 6 行，使用基准化测试的入口。

- 第 9 行，实例化 data 结构体，并给 Hp 成员赋值。

- 第 12～17 行，由于测试的重点必须放在赋值上，因此需要极大程度地降低其他代码的干扰，于是在赋值完成后，将基准测试的计时器复位并重新开始。

- 第 20 行，将基准测试提供的测试数量用于循环中。

- 第 23 行，测试的核心代码：结构体赋值。

接下来的代码分析使用反射访问结构体成员并赋值的过程。

```go
  func BenchmarkReflectAssign(b *testing.B) {

      v := data{Hp: 2}

      // 取出结构体指针的反射值对象并取其元素
      vv := reflect.ValueOf(&v).Elem()

      // 根据名字取结构体成员
      f := vv.FieldByName("Hp")

      b.StopTimer()
      b.ResetTimer()
      b.StartTimer()

      for i := 0; i < b.N; i++ {

          // 反射测试设置成员值性能
          f.SetInt(3)
      }
  }
```

代码说明如下：

- 第 6 行，取 v 的地址并转为反射值对象。此时值对象里的类型为 *data，使用值的 Elem() 方法取元素，获得 data 的反射值对象。

- 第 9 行，使用 FieldByName() 根据名字取出成员的反射值对象。

- 第 11～13 行，重置基准测试计时器。

- 第 18 行，使用反射值对象的 SetInt() 方法，给 data 结构的`Hp`字段设置数值 3。

这段代码中使用了反射值对象的 SetInt() 方法，这个方法的源码如下：

```go
  func (v Value) SetInt(x int64) {
      v.mustBeAssignable()
      switch k := v.kind(); k {
      default:
          panic(&ValueError{"reflect.Value.SetInt", v.kind()})
      case Int:
          *(*int)(v.ptr) = int(x)
      case Int8:
          *(*int8)(v.ptr) = int8(x)
      case Int16:
          *(*int16)(v.ptr) = int16(x)
      case Int32:
          *(*int32)(v.ptr) = int32(x)
      case Int64:
          *(*int64)(v.ptr) = x
      }
  }
```

可以发现，整个设置过程都是指针转换及赋值，没有遍历及内存操作等相对耗时的算法。

##### 2) 结构体成员搜索并赋值对比

```go
  func BenchmarkReflectFindFieldAndAssign(b *testing.B) {

      v := data{Hp: 2}

      vv := reflect.ValueOf(&v).Elem()

      b.StopTimer()
      b.ResetTimer()
      b.StartTimer()

      for i := 0; i < b.N; i++ {

          // 测试结构体成员的查找和设置成员的性能
          vv.FieldByName("Hp").SetInt(3)
      }

  }
```

这段代码将反射值对象的 FieldByName() 方法与 SetInt() 方法放在循环里进行检测，主要对比测试 FieldByName() 方法对性能的影响。FieldByName() 方法源码如下：

```go
  func (v Value) FieldByName(name string) Value {
      v.mustBe(Struct)
      if f, ok := v.typ.FieldByName(name); ok {
          return v.FieldByIndex(f.Index)
      }
      return Value{}
  }
```

底层代码说明如下：

- 第 3 行，通过名字查询类型对象，这里有一次遍历过程。

- 第 4 行，找到类型对象后，使用 FieldByIndex() 继续在值中查找，这里又是一次遍历。

经过底层代码分析得出，随着结构体字段数量和相对位置的变化，FieldByName() 方法比较严重的低效率问题。

##### 3) 调用函数对比

反射的函数调用，也是使用反射中容易忽视的性能点，下面展示对普通函数的调用过程。

```go
  // 一个普通函数
  func foo(v int) {

  }

  func BenchmarkNativeCall(b *testing.B) {

      for i := 0; i < b.N; i++ {
          // 原生函数调用
          foo(0)
      }
  }

  func BenchmarkReflectCall(b *testing.B) {

      // 取函数的反射值对象
      v := reflect.ValueOf(foo)

      b.StopTimer()
      b.ResetTimer()
      b.StartTimer()

      for i := 0; i < b.N; i++ {
          // 反射调用函数
          v.Call([]reflect.Value{reflect.ValueOf(2)})
      }
  }
```

代码说明如下：

- 第 2 行，一个普通的只有一个参数的函数。

- 第 10 行，对原生函数调用的性能测试。

- 第 17 行，根据函数名取出反射值对象。

- 第 25 行，使用 reflect.ValueOf(2) 将 2 构造为反射值对象，因为反射函数调用的参数必须全是反射值对象，再使用 []reflect.Value 构造多个参数列表传给反射值对象的 Call() 方法进行调用。

反射函数调用的参数构造过程非常复杂，构建很多对象会造成很大的内存回收负担。Call() 方法内部就更为复杂，需要将参数列表的每个值从 reflect.Value 类型转换为内存。调用完毕后，还要将函数返回值重新转换为 reflect.Value 类型返回。因此，反射调用函数的性能堪忧。

##### 4) 基准测试结果对比

测试结果如下：

```go
$ go test -v -bench=.
goos: linux
goarch: amd64
BenchmarkNativeAssign-4                        2000000000               0.32 ns/op
BenchmarkReflectAssign-4                       300000000               4.42 ns/op
BenchmarkReflectFindFieldAndAssign-4           20000000               91.6 ns/op
BenchmarkNativeCall-4                          2000000000               0.33 ns/op
BenchmarkReflectCall-4                         10000000               163 ns/op
PASS
```

结果分析如下：

- 第 4 行，原生的结构体成员赋值，每一步操作耗时 0.32 纳秒，这是参考基准。

- 第 5 行，使用反射的结构体成员赋值，操作耗时 4.42 纳秒，比原生赋值多消耗 13 倍的性能。

- 第 6 行，反射查找结构体成员且反射赋值，操作耗时 91.6 纳秒，扣除反射结构体成员赋值的 4.42 纳秒还富余，性能大概是原生的 272 倍。这个测试结果与代码分析结果很接近。SetInt 的性能可以接受，但 FieldByName() 的性能就非常低。

- 第 7 行，原生函数调用，性能与原生访问结构体成员接近。

- 第 8 行，反射函数调用，性能差到 “爆棚”，花费了 163 纳秒，操作耗时比原生多消耗 494 倍。

经过基准测试结果的数值分析及对比，最终得出以下结论：

- 能使用原生代码时，尽量避免反射操作。
- 提前缓冲反射值对象，对性能有很大的帮助。
- 避免反射函数调用，实在需要调用时，先提前缓冲函数参数列表，并且尽量少地使用返回值。



### 4.  reflect.TypeOf()和reflect.Type（通过反射获取类型信息）

在 Go语言中通过调用 reflect.TypeOf 函数，我们可以从一个任何非接口类型的值创建一个 reflect.Type 值。reflect.Type 值表示着此非接口值的类型。通过此值，我们可以得到很多此非接口类型的信息。当然，我们也可以将一个接口值传递给一个 reflect.TypeOf 函数调用，但是此调用将返回一个表示着此接口值的动态类型的 reflect.Type 值。

实际上，reflect.TypeOf 函数的唯一参数的类型为 interface{}，reflect.TypeOf 函数将总是返回一个表示着此唯一接口参数值的动态类型的 reflect.Type 值。

那如何得到一个表示着某个接口类型的 reflect.Type 值呢？我们必须通过下面将要介绍的一些间接途径来达到这一目的。

类型 reflect.Type 为一个接口类型，它指定了若干方法（https://golang.google.cn/pkg/reflect/#Type）。 通过这些方法，我们能够观察到一个 reflect.Type 值所表示的 Go类型的各种信息。这些方法中的有的适用于所有种类（https://golang.google.cn/pkg/reflect/#Kind）的类型，有的只适用于一种或几种类型。通过不合适的 reflect.Type 属主值调用某个方法将在运行时产生一个恐慌。

使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。下面通过例子来理解获取类型对象的过程：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var a int
    typeOfA := reflect.TypeOf(a)
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

代码输出如下：

```go
int  int
```

代码说明如下：

- 第 10 行，定义一个 int 类型的变量。
- 第 12 行，通过 reflect.TypeOf() 取得变量 a 的类型对象 typeOfA，类型为 reflect.Type()。
- 第 14 行中，通过 typeOfA 类型对象的成员函数，可以分别获取到 typeOfA 变量的类型名为 int，种类（Kind）为 int。

#### 理解反射的类型（Type）与种类（Kind）

在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。例如，需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。

##### 1) 反射种类（Kind）的定义

Go 程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。

种类（Kind）指的是对象归属的品种，在 reflect 包中有如下定义：

```go
type Kind uint
const (
    Invalid Kind = iota  // 非法类型
    Bool                 // 布尔型
    Int                  // 有符号整型
    Int8                 // 有符号8位整型
    Int16                // 有符号16位整型
    Int32                // 有符号32位整型
    Int64                // 有符号64位整型
    Uint                 // 无符号整型
    Uint8                // 无符号8位整型
    Uint16               // 无符号16位整型
    Uint32               // 无符号32位整型
    Uint64               // 无符号64位整型
    Uintptr              // 指针
    Float32              // 单精度浮点数
    Float64              // 双精度浮点数
    Complex64            // 64位复数类型
    Complex128           // 128位复数类型
    Array                // 数组
    Chan                 // 通道
    Func                 // 函数
    Interface            // 接口
    Map                  // 映射
    Ptr                  // 指针
    Slice                // 切片
    String               // 字符串
    Struct               // 结构体
    UnsafePointer        // 底层指针
)
```

Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。

type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。

##### 2) 从类型对象中获取类型名称和种类的例子

Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串。

类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。

下面的代码中会对常量和结构体进行类型信息获取。

```go
package main
import (
    "fmt"
    "reflect"
)
// 定义一个Enum类型
type Enum int
const (
    Zero Enum = 0
)
func main() {
    // 声明一个空结构体
    type cat struct {
    }
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(cat{})
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfCat.Name(), typeOfCat.Kind())
    // 获取Zero常量的反射类型对象
    typeOfA := reflect.TypeOf(Zero)
    // 显示反射类型对象的名称和种类
    fmt.Println(typeOfA.Name(), typeOfA.Kind())
}
```

代码输出如下：

```go
cat struct
Enum int
```

代码说明如下：

- 第 18 行，声明结构体类型 cat。
- 第 22 行，将 cat 实例化，并且使用 reflect.TypeOf() 获取被实例化后的 cat 的反射类型对象。
- 第 25 行，输出cat的类型名称和种类，类型名称就是 cat，而 cat 属于一种结构体种类，因此种类为 struct。
- 第 28 行，Zero 是一个 Enum 类型的常量。这个 Enum 类型在第 9 行声明，第 12 行声明了常量。如没有常量也不能创建实例，通过 reflect.TypeOf() 直接获取反射类型对象。
- 第 31 行，输出 Zero 对应的类型对象的类型名和种类。

### 5. reflect.Elem()——通过反射获取指针指向的元素类型

Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型。这个获取过程被称为取元素，等效于对指针类型变量做了一个`*`操作，代码如下：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明一个空结构体
    type cat struct {
    }
    // 创建cat的实例
    ins := &cat{}
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(ins)
    // 显示反射类型对象的名称和种类
    fmt.Printf("name:'%v' kind:'%v'\n",typeOfCat.Name(), typeOfCat.Kind())
    // 取类型的元素
    typeOfCat = typeOfCat.Elem()
    // 显示反射类型对象的名称和种类
    fmt.Printf("element name: '%v', element kind: '%v'\n", typeOfCat.Name(), typeOfCat.Kind())
}
```

代码输出如下：

```go
name: '' kind: 'ptr'
element name: 'cat', element kind: 'struct'
```

代码说明如下：

- 第 15 行，创建了cat结构体的实例，ins 是一个 *cat 类型的指针变量。
- 第 18 行，对指针变量获取反射类型信息。
- 第 21 行，输出指针变量的类型名称和种类。Go 语言的反射中对所有指针变量的种类都是 Ptr，但注意，指针变量的类型名称是空，不是 *cat。
- 第 24 行，取指针类型的元素类型，也就是 cat 类型。这个操作不可逆，不可以通过一个非指针类型获取它的指针类型。
- 第 27 行，输出指针变量指向元素的类型名称和种类，得到了 cat 的类型名称（cat）和种类（struct）。

### 6. 通过反射获取结构体的成员类型

任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是结构体，可以通过反射值对象（reflect.Type）的 NumField() 和 Field() 方法获得结构体成员的详细信息。与成员获取相关的 reflect.Type 的方法如下表所示。



| 方法                                                         | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| Field(i int) StructField                                     | 根据索引，返回索引对应的结构体字段的信息。当值不是结构体或索引超界时发生宕机 |
| NumField() int                                               | 返回结构体成员字段数量。当类型不是结构体或索引超界时发生宕机 |
| FieldByName(name string) (StructField, bool)                 | 根据给定字符串返回字符串对应的结构体字段的信息。没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机 |
| FieldByIndex(index []int) StructField                        | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息。没有找到时返回零值。当类型不是结构体或索引超界时 发生宕机 |
| FieldByNameFunc( match func(string) bool) (StructField,bool) | 根据匹配函数匹配需要的字段。当值不是结构体或索引超界时发生宕机 |

#### 结构体字段类型

reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（Struct Tag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。StructField 的结构如下：

```go
type StructField struct {
    Name string          // 字段名
    PkgPath string       // 字段路径
    Type      Type       // 字段反射类型对象
    Tag       StructTag  // 字段的结构体标签
    Offset    uintptr    // 字段在结构体中的相对偏移
    Index     []int      // Type.FieldByIndex中的返回的索引值
    Anonymous bool       // 是否为匿名字段
}
```

字段说明如下。

- Name：为字段名称。
- PkgPath：字段在结构体中的路径。
- Type：字段本身的反射类型对象，类型为 reflect.Type，可以进一步获取字段的类型信息。
- Tag：结构体标签，为结构体字段标签的额外信息，可以单独提取。
- Index：FieldByIndex 中的索引顺序。
- Anonymous：表示该字段是否为匿名字段。

#### 获取成员反射信息

下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。

反射访问结构体成员类型及信息：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明一个空结构体
    type cat struct {
        Name string
        // 带有结构体tag的字段
        Type int `json:"type" id:"100"`
    }
    // 创建cat的实例
    ins := cat{Name: "mimi", Type: 1}
    // 获取结构体实例的反射类型对象
    typeOfCat := reflect.TypeOf(ins)
    // 遍历结构体所有成员
    for i := 0; i < typeOfCat.NumField(); i++ {
        // 获取每个成员的结构体字段类型
        fieldType := typeOfCat.Field(i)
        // 输出成员名和tag
        fmt.Printf("name: %v  tag: '%v'\n", fieldType.Name, fieldType.Tag)
    }
    // 通过字段名, 找到字段类型信息
    if catType, ok := typeOfCat.FieldByName("Type"); ok {
        // 从tag中取出需要的tag
        fmt.Println(catType.Tag.Get("json"), catType.Tag.Get("id"))
    }
}
```

代码输出如下：

```go
name: Name tag: ''
name: Type tag: 'json:"type" id:"100"'
type 100
```

代码说明如下：

- 第 11 行，声明了带有两个成员的 cat 结构体。
- 第 15 行，Type 是 cat 的一个成员，这个成员类型后面带有一个以```开始和结尾的字符串。这个字符串在 Go 语言中被称为 Tag（标签）。一般用于给字段添加自定义信息，方便其他模块根据信息进行不同功能的处理。
- 第 19 行，创建 cat 实例，并对两个字段赋值。结构体标签属于类型信息，无须且不能赋值。
- 第 22 行，获取实例的反射类型对象。
- 第 25 行，使用 reflect.Type 类型的 NumField() 方法获得一个结构体类型共有多少个字段。如果类型不是结构体，将会触发宕机错误。
- 第 28 行，reflect.Type 中的 Field() 方法和 NumField 一般都是配对使用，用来实现结构体成员的遍历操作。
- 第 31 行，使用 reflect.Type 的 Field() 方法返回的结构不再是 reflect.Type 而是StructField 结构体。
- 第 35 行，使用 reflect.Type 的 FieldByName() 根据字段名查找结构体字段信息，cat Type 表示返回的结构体字段信息，类型为 StructField，ok 表示是否找到结构体字段的信息。
- 第 38 行中，使用 StructField 中 Tag 的 Get() 方法，根据 Tag 中的名字进行信息获取。

### 7. 结构体标签（Struct Tag）

通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（Struct Tag）。结构体标签是对结构体字段的额外信息标签。

JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。

##### 提示

结构体标签（Struct Tag）类似于 [C#](http://c.biancheng.net/csharp/) 中的特性（Attribute）。C# 允许在类、字段、方法等前面添加 Attribute，然后在反射系统中可以获取到这个属性系统。例如：

```go
[Conditional("DEBUG")]
public static void Message(string msg)
{
  Console.WriteLine(msg)；
}
```

#### 结构体标签的格式

Tag 在结构体字段后方书写的格式如下：

```go
key1:"value1" key2:"value2"
```

结构体标签由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。键值对之间使用一个空格分隔。

#### 从结构体标签中获取值

StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：

- func(tag StructTag)Get(key string)string
- 根据 Tag 中的键获取对应的值，例如 `key1:"value1"key2:"value2"` 的 Tag 中，可以传入“key1”获得“value1”。
- func(tag StructTag)Lookup(key string)(value string,ok bool)
- 根据 Tag 中的键，查询值是否存在。

#### 结构体标签格式错误导致的问题

编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，参见下面这个例子：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    type cat struct {
        Name string
        Type int `json: "type" id:"100"`
    }
    typeOfCat := reflect.TypeOf(cat{})
    if catType, ok := typeOfCat.FieldByName("Type"); ok {
        fmt.Println(catType.Tag.Get("json"))
    }
}
```

代码输出空字符串，并不会输出期望的 type。

第 12 行中，在`json:`和`"type"`之间增加了一个空格。这种写法没有遵守结构体标签的规则，因此无法通过 Tag.Get 获取到正确的 json 对应的值。

这个错误在开发中非常容易被疏忽，造成难以察觉的错误。

### 8. reflect.ValueOf()和reflect.Value（通过反射获取值信息）

当我们将一个接口值传递给一个 reflect.ValueOf 函数调用时，此调用返回的是代表着此接口值的动态值的一个 reflect.Value 值。我们必须通过间接的途径获得一个代表一个接口值的 reflect.Value 值。

reflect.Value 类型有很多方法（https://golang.google.cn/pkg/reflect/）。我们可以调用这些方法来观察和操纵一个 reflect.Value 属主值表示的 Go 值。这些方法中的有些适用于所有种类类型的值，有些只适用于一种或几种类型的值。

通过不合适的 reflect.Value 属主值调用某个方法将在运行时产生一个恐慌。请阅读 reflect 代码库中各个方法的文档来获取如何正确地使用这些方法。

一个 reflect.Value 值的 CanSet 方法将返回此 reflect.Value 值代表的 Go 值是否可以被修改（可以被赋值）。如果一个 Go 值可以被修改，则我们可以调用对应的 reflect.Value 值的 Set 方法来修改此 Go 值。注意：reflect.ValueOf 函数直接返回的 reflect.Value 值都是不可修改的。

反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用 reflect.Value 获取和设置变量的值。

#### 使用反射值对象包装任意值

Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：

```go
value := reflect.ValueOf(rawValue)
```

reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。

#### 从反射值对象获取被包装的值

Go语言中可以通过 reflect.Value 重新获得原始值。

##### 1) 从反射值对象（reflect.Value）中获取值的方法

可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。

| 方法名                   | 说  明                                                       |
| ------------------------ | ------------------------------------------------------------ |
| Interface() interface {} | 将值以 interface{} 类型返回，可以通过类型断言转换为指定类型  |
| Int() int64              | 将值以 int 类型返回，所有有符号整型均可以此方式返回          |
| Uint() uint64            | 将值以 uint 类型返回，所有无符号整型均可以此方式返回         |
| Float() float64          | 将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回 |
| Bool() bool              | 将值以 bool 类型返回                                         |
| Bytes() []bytes          | 将值以字节数组 []bytes 类型返回                              |
| String() string          | 将值以字符串类型返回                                         |

##### 2) 从反射值对象（reflect.Value）中获取值的例子

下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明整型变量a并赋初值
    var a int = 1024
    // 获取变量a的反射值对象
    valueOfA := reflect.ValueOf(a)
    // 获取interface{}类型的值, 通过类型断言转换
    var getA int = valueOfA.Interface().(int)
    // 获取64位的值, 强制类型转换为int类型
    var getA2 int = int(valueOfA.Int())
    fmt.Println(getA, getA2)
}
```

代码输出如下：

```go
1024 1024
```

代码说明如下：

- 第 11 行，声明一个变量，类型为 int，设置初值为 1024。
- 第 14 行，获取变量 a 的反射值对象，类型为 reflect.Value，这个过程和 reflect.TypeOf() 类似。
- 第 17 行，将 valueOfA 反射值对象以 interface{} 类型取出，通过类型断言转换为 int 类型并赋值给 getA。
- 第 20 行，将 valueOfA 反射值对象通过 Int 方法，以 int64 类型取出，通过强制类型转换，转换为原本的 int 类型。

### 9. 通过反射访问结构体成员的值

反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。

| 方  法                                         | 备  注                                                       |
| ---------------------------------------------- | ------------------------------------------------------------ |
| Field(i int) Value                             | 根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机 |
| NumField() int                                 | 返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机   |
| FieldByName(name string) Value                 | 根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机 |
| FieldByIndex(index []int) Value                | 多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体或索引超界时发生宕机 |
| FieldByNameFunc(match func(string) bool) Value | 根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机 |


下面代码构造一个结构体包含不同类型的成员。通过 reflect.Value 提供的成员访问函数，可以获得结构体值的各种数据。

反射访问结构体成员值：

```go
package main
import (
    "fmt"
    "reflect"
)
// 定义结构体
type dummy struct {
    a int
    b string
    // 嵌入字段
    float32
    bool
    next *dummy
}
func main() {
    // 值包装结构体
    d := reflect.ValueOf(dummy{
            next: &dummy{},
    })
    // 获取字段数量
    fmt.Println("NumField", d.NumField())
    // 获取索引为2的字段(float32字段)
    floatField := d.Field(2)
    // 输出字段类型
    fmt.Println("Field", floatField.Type())
    // 根据名字查找字段
    fmt.Println("FieldByName(\"b\").Type", d.FieldByName("b").Type())
    // 根据索引查找值中, next字段的int字段的值
    fmt.Println("FieldByIndex([]int{4, 0}).Type()", d.FieldByIndex([]int{4, 0}).Type())
}
```

代码说明如下：

- 第 9 行，定义结构体，结构体的每个字段的类型都不一样。
- 第 24 行，实例化结构体并包装为 reflect.Value 类型，成员中包含一个 *dummy 的实例。
- 第 29 行，获取结构体的字段数量。
- 第 32 和 35 行，获取索引为2的字段值（float32 字段），并且打印类型。
- 第 38 行，根据`b`字符串，查找到 b 字段的类型。
- 第 41 行，[]int{4,0} 中的 4 表示，在 dummy 结构中索引值为 4 的成员，也就是 next。next 的类型为 dummy，也是一个结构体，因此使用 []int{4,0} 中的 0 继续在 next 值的基础上索引，结构为 dummy 中索引值为 0 的 a 字段，类型为 int。


代码输出如下：

```go
NumField 5
Field float32
FieldByName("b").Type string
FieldByIndex([]int{4, 0}).Type() int
```

### 10. IsNil()和IsValid()——判断反射值的空和有效性

反射值对象（reflect.Value）提供一系列方法进行零值和空判定，如下表所示。

| 方 法          | 说 明                                                        |
| -------------- | ------------------------------------------------------------ |
| IsNil() bool   | 返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的`v== nil`操作 |
| IsValid() bool | 判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。 |


下面的例子将会对各种方式的空指针进行 IsNil() 和 IsValid() 的返回值判定检测。同时对结构体成员及方法查找 map 键值对的返回值进行 IsValid() 判定，参考下面的代码。

反射值对象的零值和有效性判断：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // *int的空指针
    var a *int
    fmt.Println("var a *int:", reflect.ValueOf(a).IsNil())
    // nil值
    fmt.Println("nil:", reflect.ValueOf(nil).IsValid())
    // *int类型的空指针
    fmt.Println("(*int)(nil):", reflect.ValueOf((*int)(nil)).Elem().IsValid())
    // 实例化一个结构体
    s := struct{}{}
    // 尝试从结构体中查找一个不存在的字段
    fmt.Println("不存在的结构体成员:", reflect.ValueOf(s).FieldByName("").IsValid())
    // 尝试从结构体中查找一个不存在的方法
    fmt.Println("不存在的结构体方法:", reflect.ValueOf(s).MethodByName("").IsValid())
    // 实例化一个map
    m := map[int]int{}
    // 尝试从map中查找一个不存在的键
    fmt.Println("不存在的键：", reflect.ValueOf(m).MapIndex(reflect.ValueOf(3)).IsValid())
}
```

代码输出如下：

```go
var a *int: true
nil: false
(*int)(nil): false
不存在的结构体成员: false
不存在的结构体方法: false
不存在的键： false
```

代码说明如下：

- 第 11 行，声明一个 *int 类型的指针，初始值为 nil。
- 第 12 行，将变量 a 包装为 reflect.Value 并且判断是否为空，此时变量 a 为空指针，因此返回 true。
- 第 15 行，对 nil 进行 IsValid() 判定（有效性判定），返回 false。
- 第 18 行，(*int)(nil) 的含义是将 nil 转换为 *int，也就是*int 类型的空指针。此行将 nil 转换为 *int 类型，并取指针指向元素。由于 nil 不指向任何元素，*int 类型的 nil 也不能指向任何元素，值不是有效的。因此这个反射值使用 Isvalid() 判断时返回 false。
- 第 21 行，实例化一个结构体。
- 第 24 行，通过 FieldByName 查找 s 结构体中一个空字符串的成员，如成员不存在，IsValid() 返回 false。
- 第 27 行，通过 MethodByName 查找 s 结构体中一个空字符串的方法，如方法不存在，IsValid() 返回 false。
- 第 30 行，实例化一个 map，这种写法与 make 方式创建的 map 等效。
- 第 33 行，MapIndex() 方法能根据给定的 reflect.Value 类型的值查找 map，并且返回查找到的结果。


IsNil() 常被用于判断指针是否为空；IsValid() 常被用于判定返回值是否有效。

### 11. 通过反射修改变量的值

Go语言中类似 x、x.f[1] 和 *p 形式的表达式都可以表示变量，但是其它如 x + 1 和 f(2) 则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。

对于 reflect.Values 也有类似的区别。有一些 reflect.Values 是可取地址的；其它一些则不可以。考虑以下的声明语句：

```go
x := 2 // value type variable?
a := reflect.ValueOf(2) // 2 int no
b := reflect.ValueOf(x) // 2 int no
c := reflect.ValueOf(&x) // &x *int no
d := c.Elem() // 2 int yes (x)
```

其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&x).Elem()，来获取任意变量x对应的可取地址的 Value。

我们可以通过调用 reflect.Value 的 CanAddr 方法来判断其是否可以被取地址：

```go
fmt.Println(a.CanAddr()) // "false"
fmt.Println(b.CanAddr()) // "false"
fmt.Println(c.CanAddr()) // "false"
fmt.Println(d.CanAddr()) // "true"
```

每当我们通过指针间接地获取的 reflect.Value 都是可取地址的，即使开始的是一个不可取地址的 Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice 的索引表达式 e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。

以此类推，reflect.ValueOf(e).Index(i) 对于的值也是可取地址的，即使原始的 reflect.ValueOf(e) 不支持也没有关系。

使用 reflect.Value 对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。

#### 判定及获取元素的相关方法

使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。

| 方法名         | 备  注                                                       |
| -------------- | ------------------------------------------------------------ |
| Elem() Value   | 取值指向的元素值，类似于语言层`*`操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 Value |
| Addr() Value   | 对可寻址的值返回其地址，类似于语言层`&`操作。当值不可寻址时发生宕机 |
| CanAddr() bool | 表示值是否可寻址                                             |
| CanSet() bool  | 返回值能否被修改。要求值可寻址且是导出的字段                 |

#### 值修改相关方法

使用 reflect.Value 修改值的相关方法如下表所示。

| Set(x Value)        | 将值设置为传入的反射值对象的值                               |
| ------------------- | ------------------------------------------------------------ |
| Setlnt(x int64)     | 使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机 |
| SetUint(x uint64)   | 使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机 |
| SetFloat(x float64) | 使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机 |
| SetBool(x bool)     | 使用 bool 设置值。当值的类型不是 bod 时会发生宕机            |
| SetBytes(x []byte)  | 设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机   |
| SetString(x string) | 设置字符串值。当值的类型不是 string 时会发生宕机             |


以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。

在已知值的类型时，应尽量使用值对应类型的反射设置值。

#### 值可修改条件之一：可被寻址

通过反射修改变量值的前提条件之一：这个值必须可以被寻址。简单地说就是这个变量必须能被修改。示例代码如下：

```go
package main
import (
    "reflect"
)
func main() {
    // 声明整型变量a并赋初值
    var a int = 1024
    // 获取变量a的反射值对象
    valueOfA := reflect.ValueOf(a)
    // 尝试将a修改为1(此处会发生崩溃)
    valueOfA.SetInt(1)
}
```

程序运行崩溃，打印错误：

```go
panic: reflect: reflect.Value.SetInt using unaddressable value
```

报错意思是：SetInt 正在使用一个不能被寻址的值。从 reflect.ValueOf 传入的是 a 的值，而不是 a 的地址，这个 reflect.Value 当然是不能被寻址的。将代码修改一下，重新运行：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    // 声明整型变量a并赋初值
    var a int = 1024
    // 获取变量a的反射值对象(a的地址)
    valueOfA := reflect.ValueOf(&a)
    // 取出a地址的元素(a的值)
    valueOfA = valueOfA.Elem()
    // 修改a的值为1
    valueOfA.SetInt(1)
    // 打印a的值
    fmt.Println(valueOfA.Int())
}
```

代码输出如下：

```go
1
```

下面是对代码的分析：

- 第 14 行中，将变量 a 取值后传给 reflect.ValueOf()。此时 reflect.ValueOf() 返回的 valueOfA 持有变量 a 的地址。
- 第 17 行中，使用 reflect.Value 类型的 Elem() 方法获取 a 地址的元素，也就是 a 的值。reflect.Value 的 Elem() 方法返回的值类型也是 reflect.Value。
- 第 20 行，此时 valueOfA 表示的是 a 的值且可以寻址。使用 SetInt() 方法设置值时不再发生崩溃。
- 第 23 行，正确打印修改的值。

##### 提示

当 reflect.Value 不可寻址时，使用 Addr() 方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的 Addr() 方法类似于语言层的`&`操作；Elem() 方法类似于语言层的`*`操作，但并不代表这些方法与语言层操作等效。

#### 值可修改条件之一：被导出

结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改，代码如下：

```go
package main
import (
    "reflect"
)
func main() {
    type dog struct {
            legCount int
    }
    // 获取dog实例的反射值对象
    valueOfDog := reflect.ValueOf(dog{})
    // 获取legCount字段的值
    vLegCount := valueOfDog.FieldByName("legCount")
    // 尝试设置legCount的值(这里会发生崩溃)
    vLegCount.SetInt(4)
}
```

程序发生崩溃，报错：

```go
panic: reflect: reflect.Value.SetInt using value obtained using unexported field
```

报错的意思是：SetInt() 使用的值来自于一个未导出的字段。

为了能修改这个值，需要将该字段导出。将 dog 中的 legCount 的成员首字母大写，导出 LegCount 让反射可以访问，修改后的代码如下：

```go
type dog struct {
    LegCount int
}
```

然后根据字段名获取字段的值时，将字符串的字段首字母大写，修改后的代码如下：

```go
vLegCount := valueOfDog.FieldByName("LegCount")
```

再次运行程序，发现仍然报错：

```go
panic: reflect: reflect.Value.SetInt using unaddressable value
```

这个错误表示第 13 行构造的 valueOfDog 这个结构体实例不能被寻址，因此其字段也不能被修改。修改代码，取结构体的指针，再通过 reflect.Value 的 Elem() 方法取到值的反射值对象。修改后的完整代码如下：

```go
package main
import (
    "reflect"
    "fmt"
)
func main() {
    type dog struct {
            LegCount int
    }
    // 获取dog实例地址的反射值对象
    valueOfDog := reflect.ValueOf(&dog{})
    // 取出dog实例地址的元素
    valueOfDog = valueOfDog.Elem()
    // 获取legCount字段的值
    vLegCount := valueOfDog.FieldByName("LegCount")
    // 尝试设置legCount的值(这里会发生崩溃)
    vLegCount.SetInt(4)
    fmt.Println(vLegCount.Int())
}
```

代码输出如下：

```go
4
```

代码说明如下：

- 第 11 行，将 LegCount 首字母大写导出该字段。
- 第 14 行，获取 dog 实例指针的反射值对象。
- 第 17 行，取 dog 实例的指针元素，也就是 dog 的实例。
- 第 20 行，取 dog 结构体中 LegCount 字段的成员值。
- 第 23 行，修改该成员值。
- 第 25 行，打印该成员值。


值的修改从表面意义上叫可寻址，换一种说法就是值必须“可被设置”。那么，想修改变量值，一般的步骤是：

1. 取这个变量的地址或者这个变量所在的结构体已经是指针类型。
2. 使用 reflect.ValueOf 进行值包装。
3. 通过 Value.Elem() 获得指针值指向的元素值对象（Value），因为值对象（Value）内部对象为指针时，使用 set 设置时会报出宕机错误。
4. 使用 Value.Set 设置值。

### 12. 通过类型信息创建实例

当已知 reflect.Type 时，可以动态地创建这个类型的实例，实例的类型为指针。例如 reflect.Type 的类型为 int 时，创建 int 的指针，即`*int`，代码如下：

```go
package main
import (
    "fmt"
    "reflect"
)
func main() {
    var a int
    // 取变量a的反射类型对象
    typeOfA := reflect.TypeOf(a)
    // 根据反射类型对象创建类型实例
    aIns := reflect.New(typeOfA)
    // 输出Value的类型和种类
    fmt.Println(aIns.Type(), aIns.Kind())
}
```

代码输出如下：

```go
*int ptr
```

代码说明如下：

- 第 13 行，获取变量 a 的反射类型对象。
- 第 16 行，使用 reflect.New() 函数传入变量 a 的反射类型对象，创建这个类型的实例值，值以 reflect.Value 类型返回。这步操作等效于：new(int)，因此返回的是 *int 类型的实例。
- 第 19 行，打印 aIns 的类型为 *int，种类为指针。

### 13. 通过反射调用函数

如果反射值对象（reflect.Value）中值的类型为函数时，可以通过 reflect.Value 调用该函数。使用反射调用函数时，需要将参数使用反射值对象的切片 []reflect.Value 构造后传入 Call() 方法中，调用完成时，函数的返回值通过 []reflect.Value 返回。

下面的代码声明一个加法函数，传入两个整型值，返回两个整型值的和。将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。

反射调用函数：

```go
package main
import (
    "fmt"
    "reflect"
)
// 普通函数
func add(a, b int) int {
    return a + b
}
func main() {
    // 将函数包装为反射值对象
    funcValue := reflect.ValueOf(add)
    // 构造函数参数, 传入两个整型值
    paramList := []reflect.Value{reflect.ValueOf(10), reflect.ValueOf(20)}
    // 反射调用函数
    retList := funcValue.Call(paramList)
    // 获取第一个返回值, 取整数值
    fmt.Println(retList[0].Int())
}
```

代码说明如下：

- 第 9～12 行，定义一个普通的加法函数。
- 第 17 行，将 add 函数包装为反射值对象。
- 第 20 行，将 10 和 20 两个整型值使用 reflect.ValueOf 包装为 reflect.Value，再将反射值对象的切片 []reflect.Value 作为函数的参数。
- 第 23 行，使用 funcValue 函数值对象的 Call() 方法，传入参数列表 paramList 调用 add() 函数。
- 第 26 行，调用成功后，通过 retList[0] 取返回值的第一个参数，使用 Int 取返回值的整数值。

#### 提示

反射调用函数的过程需要构造大量的 reflect.Value 和中间变量，对函数参数值进行逐一检查，还需要将调用参数复制到调用函数的参数内存中。调用完毕后，还需要将返回值转换为 reflect.Value，用户还需要从中取出调用值。因此，反射调用函数的性能问题尤为突出，不建议大量使用反射函数调用。

### 14. inject库：依赖注入

在介绍 inject 之前我们先来简单介绍一下“依赖注入”和“控制反转”这两个概念。

正常情况下，对函数或方法的调用是我们的主动直接行为，在调用某个函数之前我们需要清楚地知道被调函数的名称是什么，参数有哪些类型等等。

所谓的控制反转就是将这种主动行为变成间接的行为，我们不用直接调用函数或对象，而是借助框架代码进行间接的调用和初始化，这种行为称作“控制反转”，库和框架能很好的解释控制反转的概念。

依赖注入是实现控制反转的一种方法，如果说控制反转是一种设计思想，那么依赖注入就是这种思想的一种实现，通过注入参数或实例的方式实现控制反转。如果没有特殊说明，我们可以认为依赖注入和控制反转是一个东西。

控制反转的价值在于解耦，有了控制反转就不需要将代码写死，可以让控制反转的的框架代码读取配置，动态的构建对象，这一点在 [Java](http://c.biancheng.net/java/) 的 [Spring](http://c.biancheng.net/spring/) 框架中体现的尤为突出。

#### inject 实践

inject 是依赖注入的Go语言实现，它能在运行时注入参数，调用方法，是 Martini 框架（Go语言中著名的 Web 框架）的基础核心。

在介绍具体实现之前，先来想一个问题，如何通过一个字符串类型的函数名来调用函数？Go语言没有 Java 中的 Class.forName 方法可以通过类名直接构造对象，所以这种方法是行不通的，能想到的方法就是使用 map 实现一个字符串到函数的映射，示例代码如下：

```go
func fl() {
    println ("fl")
}
func f2 () {
    println ("f2")
}
funcs := make(map[string] func ())
funcs ["fl"] = fl
funcs ["f2"] = fl
funcs ["fl"]()
funcs ["f2"]()
```

但是这有个缺陷，就是 map 的 Value 类型被写成 func()，不同参数和返回值的类型的函数并不能通用。将 map 的 Value 定义为 interface{} 空接口类型即可以解决该问题，但需要借助类型断言或反射来实现，通过类型断言实现等于又绕回去了，反射是一种可行的办法。

inject 包借助反射实现函数的注入调用，下面通过一个示例来看一下。

```go
package main
import (
    "fmt"
    "github.com/codegangsta/inject"
)
type S1 interface{}
type S2 interface{}
func Format(name string, company S1, level S2, age int) {
    fmt.Printf("name ＝ %s, company=%s, level=%s, age ＝ %d!\n", name, company, level, age)
}
func main() {
    //控制实例的创建
    inj := inject.New()
    //实参注入
    inj.Map("tom")
    inj.MapTo("tencent", (*S1)(nil))
    inj.MapTo("T4", (*S2)(nil))
    inj.Map(23)
    //函数反转调用
    inj.Invoke(Format)
}
```

运行结果如下：

```go
name ＝ tom, company=tencent, level=T4, age ＝ 23!
```

可见 inject 提供了一种注入参数调用函数的通用功能，inject.New() 相当于创建了一个控制实例，由其来实现对函数的注入调用。inject 包不但提供了对函数的注入，还实现了对 struct 类型的注入，示例代码如下所示：

```go
package main
import (
    "fmt"
    "github.com/codegangsta/inject"
)
type S1 interface{}
type S2 interface{}
type Staff struct {
    Name    string `inject`
    Company S1     `inject`
    Level   S2     `inject`
    Age     int    `inject`
}
func main() {
    //创建被注入实例
    s := Staff{}
    //控制实例的创建
    inj := inject.New()
    //初始化注入值
    inj.Map("tom")
    inj.MapTo("tencent", (*S1)(nil))
    inj.MapTo("T4", (*S2)(nil))
    inj.Map(23)
    //实现对 struct 注入
    inj.Apply(&s)
    //打印结果
    fmt.Printf("s ＝ %v\n", s)
}
```

运行结果如下：

```go
s ＝ {tom tencent T4 23}
```

可以看到 inject 提供了一种对结构类型的通用注入方法。至此，我们仅仅从宏观层面了解 iniect 能做什么，下面从源码实现角度来分析 inject。

#### inject 原理分析

inject 包中只有 2 个文件，一个是 inject.go 文件和一个 inject_test.go 文件，这里我们只需要关注 inject.go 文件即可。

inject.go 短小精悍，包括注释和空行在内才 157 行代码，代码中定义了 4 个接口，包括一个父接口和三个子接口，如下所示：

```go
type Injector interface {
    Applicator
    Invoker
    TypeMapper
    SetParent(Injector)
}
type Applicator interface {
    Apply(interface{}) error
}
type Invoker interface {
    Invoke(interface{}) ([]reflect.Value, error)
}
type TypeMapper interface {
    Map(interface{}) TypeMapper
    MapTo(interface{}, interface{}) TypeMapper
    Get(reflect.Type) reflect.Value
}
```

Injector 接口是 Applicator、Invoker、TypeMapper 接口的父接口，所以实现了 Injector 接口的类型，也必然实现了 Applicator、Invoker 和 TypeMapper 接口：

- Applicator 接口只规定了 Apply 成员，它用于注入 struct。
- Invoker 接口只规定了 Invoke 成员，它用于执行被调用者。
- TypeMapper 接口规定了三个成员，Map 和 MapTo 都用于注入参数，但它们有不同的用法，Get 用于调用时获取被注入的参数。


另外 Injector 还规定了 SetParent 行为，它用于设置父 Injector，其实它相当于查找继承。也即通过 Get 方法在获取被注入参数时会一直追溯到 parent，这是个递归过程，直到查找到参数或为 nil 终止。

```go
type injector struct {
    values map[reflect.Type]reflect.Value
    parent Injector
}
func InterfaceOf(value interface{}) reflect.Type {
    t := reflect.TypeOf(value)
    for t.Kind() == reflect.Ptr {
        t = t.Elem()
    }
    if t.Kind() != reflect.Interface {
        panic("Called inject.InterfaceOf with a value that is not a pointer to an interface. (*MyInterface)(nil)")
    }
    return t
}
func New() Injector {
    return &injector{
        values: make(map[reflect.Type]reflect.Value),
    }
}
```

injector 是 inject 包中唯一定义的 struct，所有的操作都是基于 injector struct 来进行的，它有两个成员 values 和 parent。values 用于保存注入的参数，是一个用 reflect.Type 当键、reflect.Value 为值的 map，理解这点将有助于理解 Map 和 MapTo。

New 方法用于初始化 injector struct，并返回一个指向 injector struct 的指针，但是这个返回值被 Injector 接口包装了。

InterfaceOf 方法虽然只有几句实现代码，但它是 Injector 的核心。InterfaceOf 方法的参数必须是一个接口类型的指针，如果不是则引发 panic。InterfaceOf 方法的返回类型是 reflect.Type，大家应该还记得 injector 的成员 values 就是一个 reflect.Type 类型当键的 map。这个方法的作用其实只是获取参数的类型，而不关心它的值。

示例代码如下所示：

```go
package main
import (
    "fmt"
    "github.com/codegangsta/inject"
)
type SpecialString interface{}
func main() {
    fmt.Println(inject.InterfaceOf((*interface{})(nil)))
    fmt.Println(inject.InterfaceOf((*SpecialString)(nil)))
}
```

运行结果如下：

```go
interface {}
main.SpecialString
```

InterfaceOf 方法就是用来得到参数类型，而不关心它具体存储的是什么值。

```go
func (i *injector) Map(val interface{}) TypeMapper {
    i.values[reflect.TypeOf(val)] = reflect.ValueOf(val)
    return i
}
func (i *injector) MapTo(val interface{}, ifacePtr interface{}) TypeMapper {
    i.values[InterfaceOf(ifacePtr)] = reflect.ValueOf(val)
    return i
}
func (i *injector) Get(t reflect.Type) reflect.Value {
    val := i.values[t]
    if !val.IsValid() && i.parent != nil {
        val = i.parent.Get(t)
    }
    return val
}
func (i *injector) SetParent(parent Injector) {
    i.parent = parent
}
```

Map 和 MapTo 方法都用于注入参数，保存于 injector 的成员 values 中。这两个方法的功能完全相同，唯一的区别就是 Map 方法用参数值本身的类型当键，而 MapTo 方法有一个额外的参数可以指定特定的类型当键。但是 MapTo 方法的第二个参数 ifacePtr 必须是接口指针类型，因为最终 ifacePtr 会作为 InterfaceOf 方法的参数。

为什么需要有 MapTo 方法？因为注入的参数是存储在一个以类型为键的 map 中，可想而知，当一个函数中有一个以上的参数的类型是一样时，后执行 Map 进行注入的参数将会覆盖前一个通过 Map 注入的参数。

SetParent 方法用于给某个 Injector 指定父 Injector。Get 方法通过 reflect.Type 从 injector 的 values 成员中取出对应的值，它可能会检查是否设置了 parent，直到找到或返回无效的值，最后 Get 方法的返回值会经过 IsValid 方法的校验。

示例代码如下所示：

```go
package main
import (
    "fmt"
    "reflect"
    "github.com/codegangsta/inject"
)
type SpecialString interface{}
func main() {
    inj := inject.New()
    inj.Map("C语言中文网")
    inj.MapTo("Golang", (*SpecialString)(nil))
    inj.Map(20)
    fmt.Println("字符串是否有效？", inj.Get(reflect.TypeOf("Go语言入门教程")).IsValid())
    fmt.Println("特殊字符串是否有效？", inj.Get(inject.InterfaceOf((*SpecialString)(nil))).IsValid())
    fmt.Println("int 是否有效？", inj.Get(reflect.TypeOf(18)).IsValid())
    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())
    inj2 := inject.New()
    inj2.Map([]byte("test"))
    inj.SetParent(inj2)
    fmt.Println("[]byte 是否有效？", inj.Get(reflect.TypeOf([]byte("Golang"))).IsValid())
}
```

运行结果如下所示：

```go
字符串是否有效？ true
特殊字符串是否有效？ true
int 是否有效？ true
[]byte 是否有效？ false
[]byte 是否有效？ true
```

通过以上例子应该知道 SetParent 是什么样的行为，是不是很像面向对象中的查找链？

```go
func (inj *injector) Invoke(f interface{}) ([]reflect.Value, error) {
    t := reflect.TypeOf(f)
    var in = make([]reflect.Value, t.NumIn()) //Panic if t is not kind of Func
    for i := 0; i < t.NumIn(); i++ {
        argType := t.In(i)
        val := inj.Get(argType)
        if !val.IsValid() {
            return nil, fmt.Errorf("Value not found for type %v", argType)
        }
        in[i] = val
    }
    return reflect.ValueOf(f).Call(in), nil
}
```

Invoke 方法用于动态执行函数，当然执行前可以通过 Map 或 MapTo 来注入参数，因为通过 Invoke 执行的函数会取出已注入的参数，然后通过 reflect 包中的 Call 方法来调用。Invoke 接收的参数 f 是一个接口类型，但是 f 的底层类型必须为 func，否则会 panic。

```go
package main
import (
    "fmt"
    "github.com/codegangsta/inject"
)
type SpecialString interface{}
func Say(name string, gender SpecialString, age int) {
    fmt.Printf("My name is %s, gender is %s, age is %d!\n", name, gender, age)
}
func main() {
    inj := inject.New()
    inj.Map("张三")
    inj.MapTo("男", (*SpecialString)(nil))
    inj2 := inject.New()
    inj2.Map(25)
    inj.SetParent(inj2)
    inj.Invoke(Say)
}
```

运行结果如下：

```go
My name is 张三, gender is 男, age is 25!
```

上面的例子如果没有定义 SpecialString 接口作为 gender 参数的类型，而把 name 和 gender 都定义为 string 类型，那么 gender 会覆盖 name 的值。

```go
func (inj *injector) Apply(val interface{}) error {
    v := reflect.ValueOf(val)
    for v.Kind() == reflect.Ptr {
        v = v.Elem()
    }
    if v.Kind() != reflect.Struct {
        return nil
    }
    t := v.Type()
    for i := 0; i < v.NumField(); i++ {
        f := v.Field(i)
        structField := t.Field(i)
        if f.CanSet() && structField.Tag == "inject" {
            ft := f.Type()
            v := inj.Get(ft)
            if !v.IsValid() {
                return fmt.Errorf("Value not found for type %v", ft)
            }
            f.Set(v)
        }
    }
    return nil
}
```

Apply 方法是用于对 struct 的字段进行注入，参数为指向底层类型为结构体的指针。可注入的前提是：字段必须是导出的（也即字段名以大写字母开头），并且此字段的 tag 设置为``inject``。

示例代码如下所示：

```go
package main
import (
    "fmt"
    "github.com/codegangsta/inject"
)
type SpecialString interface{}
type TestStruct struct {
    Name   string `inject`
    Nick   []byte
    Gender SpecialString `inject`
    uid    int           `inject`
    Age    int           `inject`
}
func main() {
    s := TestStruct{}
    inj := inject.New()
    inj.Map("张三")
    inj.MapTo("男", (*SpecialString)(nil))
    inj2 := inject.New()
    inj2.Map(26)
    inj.SetParent(inj2)
    inj.Apply(&s)
    fmt.Println("s.Name =", s.Name)
    fmt.Println("s.Gender =", s.Gender)
    fmt.Println("s.Age =", s.Age)
}
```

运行结果如下：

```go
s.Name = 张三
s.Gender = 男
s.Age = 26
```



## 第十一章 文件处理

### 1. 自定义数据文件

对一个程序非常普遍的需求包括维护内部[数据结构](http://c.biancheng.net/data_structure/)，为数据交换提供导入导出功能，也支持使用外部工具来处理数据。

由于我们这里的关注重点是文件处理，因此我们纯粹只关心如何从程序内部数据结构中读取数据并将其写入标准和自定义格式的文件中，以及如何从标准和自定义格式文件中读取数据并写入程序的内部数据结构中。

本节中，我们会为所有的例子使用相同的数据，以便直接比较不同的文件格式。所有的代码都来自 invoicedate 程序（在 invoicedata 目录中的 invoicedata.go > gob.go、inv.go、jsn.go、txt.go 和 xml.go 等文件中）。大家可以从我的网盘（链接: https://pan.baidu.com/s/1j22QfIScihrauVCVFV6MWw 提取码: ajrk）下载相关的代码。

该程序接受两个文件名作为命令行参数，一个用于读，另一个用于写（它们必须是不同的文件）。程序从第一个文件中读取数据（以其后缀所表示的任何格式），并将数据写入第二个文件（也是以其后缀所表示的任何格式）。

由 invoicedata 程序创建的文件可跨平台使用，也就是说，无论是什么格式，Windows 上创建的文件都可在 Mac OS X 以及 Linux 上读取，反之亦然。Gzip 格式压缩的文件（如 invoices.gob.gz）可以无缝读写。

这些数据由一个 []invoice 组成，也就是说，是一个保存了指向 Invoice 值的指针的切片。每一个发票数据都保存在一个 invoice 类型的值中，同时每一个发票数据都以 []*Item 的形式保存着 0 个或者多个项。

```go
type Invoice struct {
    Id          int
    Customerld  int
    Raised      time.Time
    Due         time.Time
    Paid        bool
    Note        string
    Items       []*Item
}
type Item struct {
    Id       st ring
    Price    float64
    Quantity int
    Note     string
}
```

这两个结构体用于保存数据。下表给出了一些非正式的对比，展示了每种格式下读写相同的 50000 份随机发票数据所需的时间，以及以该格式所存储文件的大小。

计时按秒计，并向上舍入到最近的十分之一秒。我们应该把计时结果认为是无绝对单位的，因为不同硬件以及不 同负载情况下该值都不尽相同。大小一栏以千字节（KB）算，该值在所有机器上应该都是相同的。

对于该数据集，虽然未压缩文件的大小千差万别，但压缩文件的大小都惊人的相似。而代码的 函数不包括所有格式通用的代码（例如，那些用于压缩和解压缩以及定义结构体的代码）。

表：各种格式的速度以及大小对比

| 后缀    | 读取 | 写入 | 大小(KiB) | 读/写LOC       | 格式            |
| ------- | ---- | ---- | --------- | -------------- | --------------- |
| .gob    | 0.3  | 0.2  | 7948      | 21 + 11 =32    | Go二进制        |
| .gob.gz | 0.5  | 1.5  | 2589      |                |                 |
| jsn     | 4.5  | 2.2  | 16283     | 32+17 = 49     | JSON            |
| .jsn.gz | 4.5  | 3.4  | 2678      |                |                 |
| .xml    | 6.7  | 1.2  | 18917     | 45 + 30 = 75   | XML             |
| .xml.gz | 6.9  | 2.7  | 2730      |                |                 |
| ..txt   | 1.9  | 1.0  | 12375     | 86 + 53 = 139  | 纯文本（UTF-8） |
| .txt.gz | 2.2  | 2.2  | 2514      |                |                 |
| .inv    | 1.7  | 3.5  | 7250      | 128 + 87 = 215 | 自定义二进制    |
| .inv.gz | 1.6  | 2.6  | 2400      |                |                 |


这些读写时间和文件大小在我们的合理预期范围内，除了纯文本格式的读写异常快之外。这得益于 fmt 包优秀的打印和扫描函数，以及我们设计的易于解析的自定义文本格式。

对于 JSON 和 XML 格式，我们只简单地存储了日期部分而非存储默认的 time.Time 值（一个 ISO-8601 日期/时间字符串），通过牺牲一些速度和增加一些额外代码稍微减小了文件的大小。

例如，如果让JSON代码自己来处理time.Time值，它能够运行得更快，并且其代码行数与 Go语言二进制编码差不多。

对于二进制数据，Go语言的二进制格式是最便于使用的。它非常快且极端紧凑，所需的代码非常少，并且相对容易适应数据的变化。然而，如果我们使用的自定义类型不原生支持 gob 编码，我们必须让该类型满足 gob.Encoder 和 gob. Decoder 接口，这样会导致 gob 格式的 读写相当得慢，并且文件大小也会膨胀。

对于可读的数据，XML 可能是最好使用的格式，特别是作为一种数据交换格式时非常有用。与处理 JSON 格式相比，处理 XML 格式需要更多行代码。这是因为 Go [没有一个 xml.Marshaler 接口，也因为我们这里使用了并行的数据类型 （XMLInvoice 和 XMLItem）来帮助映射 XML 数据和发票数据（invoice 和 Item）。

使用 XML 作为外部存储格式的应用程序可能不需要并行的数据类型或者也不需要 invoicedata 程序这样的 转换，因此就有可能比 invoicedata 例子中所给出的更快，并且所需的代码也更少。

除了读写速度和文件大小以及代码行数之外，还有另一个问题值得考虑：格式的稳健性。例如，如果我们为 Invoice 结构体和 Item 结构体添加了一个字段，那么就必须再改变文件的格式。我们的代码适应读写新格式并继续支持读旧格式的难易程度如何？如果我们为文件格式定义版本，这样的变化就很容易被适应（会以本章一个练习的形式给岀），除了让 JSON 格式同时适应读写新旧格式稍微复杂一点之外。

除了 Invoice 和 Item 结构体之外，所有文件格式都共享以下常量：

```go
const （
    fileType        = "INVOICES"        //用于纯文本格式
    magicNumber     = 0xl25D            // 用于二进制格式
    fileVersion     = 100               //用于所有的格式
    dataFormat      = "2006-01-02"      //必须总是使用该日期
）
```

magicNumber 用于唯一标记发票文件。fileVersion 用于标记发票文件的版本，该标记便于之后修改程序来适应数据格式的改变。dataFormat 稍后介绍，它表 示我们希望数据如何按照可读的格式进行格式化。

同时，我们也创建了一对接口。

```go
type InvoiceMarshaler interface {
    Marshallnvoices（writer io.Writer, invoices []*Invoice） error
}
type InvoiceUnmarshaler interface {
    Unmarshallnvoices(reader io.Reader) ([]*Invoice, error)
}
```

这样做的目的是以统一的方式针对特定格式使用 reader 和 writer。例如，下列函数是 invoicedata 程序用来从一个打开的文件中读取发票数据的。

```go
func readinvoices(reader io.Reader, suffix string)([]*Invoice, error) {
    var unmarshaler InvoicesUnmarshaler
    switch suffix {
        case ".gobn:
            unmarshaler = GobMarshaler{}
        case H.inv":
            unmarshaler = InvMarshaler{}
        case ,f. jsn", H. jsonn:
            unmarshaler = JSONMarshaler{}
        case ".txt”：
            unmarshaler = TxtMarshaler{}
        case ".xml":
            unmarshaler = XMLMarshaler{}
    }
    if unmarshaler != nil {
        return unmarshaler.Unmarshallnvoices(reader)
    }
    return nil, fmt.Errorf("unrecognized input suffix: %s", suffix)
}
```

其中，reader 是任何能够满足 io.Reader 接口的值，例如，一个打开的文件 ( 其类型为 *os . File)> 一个 gzip 解码器 ( 其类型为 *gzip. Reader) 或者一个 string. Readero 字符串 suffix 是文件的后缀名 ( 从 .gz 文件中解压之后)。

在接下来的小节中我们将会看到 GobMarshaler 和 InvMarshaler 等自定义的类型，它们提供了 MarshmlTnvoices() 和 Unmarshallnvoices() 方法 (因此满足 InvoicesMarshaler 和 InvoicesUnmarshaler 接口)。

### 2. JSON文件的读写操作

JSON（[JavaScript](http://c.biancheng.net/js/) Object Notation）是一种轻量级的数据交换格式，易于阅读和编写，同时也易于机器解析和生成。它基于 [Java](http://c.biancheng.net/java/)Script Programming Language, Standard ECMA-262 3rd Edition - December 1999 的一个子集。

JSON 是一种使用 UTF-8 编码的纯文本格式，采用完全独立于语言的文本格式，由于写起来比 XML 格式方便，并且更为紧凑，同时所需的处理时间也更少，致使 JSON 格式越来越流行，特别是在通过网络连接传送数据方面。

开发人员可以使用 JSON 传输简单的字符串、数字、布尔值，也可以传输一个数组或者一个更复杂的复合结构。在 Web 开发领域中，JSON 被广泛应用于 Web 服务端程序和客户端之间的数据通信。

Go语言内建对 JSON 的支持，使用内置的 encoding/json 标准库，开发人员可以轻松使用Go程序生成和解析 JSON 格式的数据。

JSON 结构如下所示：

```json
{"key1":"value1","key2":value2,"key3":["value3","value4","value5"]}
```

#### 写 JSON 文件

使用Go语言创建一个 json 文件非常方便，示例代码如下：

```go
package main
import (
    "encoding/json"
    "fmt"
    "os"
)
type Website struct {
    Name   string `xml:"name,attr"`
    Url    string
    Course []string
}
func main() {
    info := []Website{{"Golang", "http://c.biancheng.net/golang/", []string{"http://c.biancheng.net/cplus/", "http://c.biancheng.net/linux_tutorial/"}}, {"Java", "http://c.biancheng.net/java/", []string{"http://c.biancheng.net/socket/", "http://c.biancheng.net/python/"}}}
    // 创建文件
    filePtr, err := os.Create("info.json")
    if err != nil {
        fmt.Println("文件创建失败", err.Error())
        return
    }
    defer filePtr.Close()
    // 创建Json编码器
    encoder := json.NewEncoder(filePtr)
    err = encoder.Encode(info)
    if err != nil {
        fmt.Println("编码错误", err.Error())
    } else {
        fmt.Println("编码成功")
    }
}
```

运行上面的代码会在当前目录下生成一个 info.json 文件，文件内容如下：

```json
[
  {
    "Name":"Golang",
    "Url":"http://c.biancheng.net/golang/",
    "Course":[
      "http://c.biancheng.net/golang/102/",
      "http://c.biancheng.net/golang/concurrent/"
    ]
  },
  {
    "Name":"Java",
    "Url":"http://c.biancheng.net/java/",
    "Course":[
      "http://c.biancheng.net/java/10/",
      "http://c.biancheng.net/python/"
    ]
  }
]
```

#### 读 JSON 文件

读 JSON 数据与写 JSON 数据一样简单，示例代码如下：

```go
package main
import (
    "encoding/json"
    "fmt"
    "os"
)
type Website struct {
    Name   string `xml:"name,attr"`
    Url    string
    Course []string
}
func main() {
    filePtr, err := os.Open("./info.json")
    if err != nil {
        fmt.Println("文件打开失败 [Err:%s]", err.Error())
        return
    }
    defer filePtr.Close()
    var info []Website
    // 创建json解码器
    decoder := json.NewDecoder(filePtr)
    err = decoder.Decode(&info)
    if err != nil {
        fmt.Println("解码失败", err.Error())
    } else {
        fmt.Println("解码成功")
        fmt.Println(info)
    }
}
```

运行结果如下：

```go
go run main.go
解码成功
[{Golang http://c.biancheng.net/golang/ [http://c.biancheng.net/golang/102/ http://c.biancheng.net/golang/concurrent/]} {Java http://c.biancheng.net/java/ [http://c.biancheng.net/java/10/ http://c.biancheng.net/python/]}]
```

顺便提一下，还有一种叫做 BSON (Binary JSON) 的格式与 JSON 非常类似，与 JSON 相比，BSON 着眼于提高存储和扫描效率。BSON 文档中的大型元素以长度字段为前缀以便于扫描。在某些情况下，由于长度前缀和显式数组索引的存在，BSON 使用的空间会多于 JSON。

### 3. XML文件的读写操作

XML（extensible Markup Language）格式被广泛用作一种数据交换格式，并且自成一种文件格式。与上一节介绍的 [JSON](http://c.biancheng.net/view/4545.html) 相比 XML 要复杂得多，而且手动写起来相对乏味得多。

在 JSON 还未像现在这么广泛使用时，XML 的使用相当广泛。XML 作为一种数据交换和信息传递的格式，使用还是很广泛的，现在很多开放平台接口，基本都会支持 XML 格式。

Go语言内置的 encoding/xml 包可以用在结构体和 XML 格式之间进行编解码，其方式跟 encoding/json 包类似。然而与 JSON 相比 XML 的编码和解码在功能上更苛刻得多，这是由于 encoding/xml 包要求结构体的字段包含格式合理的标签，而 JSON 格式却不需要。

#### 写 XML 文件

使用 encoidng/xml 包可以很方便的将 xml 数据存储到文件中，示例代码如下：

```go
package main
import (
    "encoding/xml"
    "fmt"
    "os"
)
type Website struct {
    Name   string `xml:"name,attr"`
    Url    string
    Course []string
}
func main() {
    //实例化对象
    info := Website{"C语言中文网", "http://c.biancheng.net/golang/", []string{"Go语言入门教程", "Golang入门教程"}}
    f, err := os.Create("./info.xml")
    if err != nil {
        fmt.Println("文件创建失败", err.Error())
        return
    }
    defer f.Close()
    //序列化到文件中
    encoder := xml.NewEncoder(f)
    err = encoder.Encode(info)
    if err != nil {
        fmt.Println("编码错误：", err.Error())
        return
    } else {
        fmt.Println("编码成功")
    }
}
```

运行上面的代码会在当前目录生成一个 info.xml 文件，文件的内容如下所示：

```xml
<Website name="C语言中文网">
  <Url>http://c.biancheng.net/golang/</Url>
  <Course>Go语言入门教程</Course>
  <Course>Golang入门教程</Course>
</Website>
```

#### 读 XML 文件

读 XML 文件比写 XML 文件稍微复杂，特别是在必须处理一些我们自定义字段的时候（例如日期）。但是，如果我们使用合理的打上 XML 标签的结构体，就不会复杂。示例代码如下：

```go
package main
import (
    "encoding/xml"
    "fmt"
    "os"
)
type Website struct {
    Name   string `xml:"name,attr"`
    Url    string
    Course []string
}
func main() {
    //打开xml文件
    file, err := os.Open("./info.xml")
    if err != nil {
        fmt.Printf("文件打开失败：%v", err)
        return
    }
    defer file.Close()
    info := Website{}
    //创建 xml 解码器
    decoder := xml.NewDecoder(file)
    err = decoder.Decode(&info)
    if err != nil {
        fmt.Printf("解码失败：%v", err)
        return
    } else {
        fmt.Println("解码成功")
        fmt.Println(info)
    }
}
```

运行结果如下：

```go
go run main.go
解码成功
{C语言中文网 http://c.biancheng.net/golang/ [Go语言入门教程 Golang入门教程]}
```

正如写 XML 时一样，我们无需关心对所读取的 XML 数据进行转义，xml.NewDecoder.Decode() 函数会自动处理这些。

xml 包还支持更为复杂的标签，包括嵌套。例如标签名为 'xml:"Books>Author"' 产生的是 <Books><Author>content</Author></Books> 这样的 XML 内容。同时除了 'xml:", attr"' 之外，该包还支持 'xml:",chardata"' 这样的标签表示将该字段当做字符数据来写，支持 'xml:",innerxml"' 这样的标签表示按照字面量来写该字段，以及 'xml:",comment"' 这样的标签表示将该字段当做 XML 注释。因此，通过使用标签化的结构体，我们可以充分利用好这些方便的编码解码函数，同时合理控制如何读写 XML 数据。

### 4. 使用Gob传输数据

为了让某个[数据结构](http://c.biancheng.net/data_structure/)能够在网络上传输或能够保存至文件，它必须被编码然后再解码。当然已经有许多可用的编码方式了，比如 [JSON](http://c.biancheng.net/view/4545.html)、[XML](http://c.biancheng.net/view/4551.html)、Google 的 protocol buffers 等等。而现在又多了一种，由Go语言 encoding/gob 包提供的方式。

Gob 是Go语言自己以二进制形式序列化和反序列化程序数据的格式，可以在 encoding 包中找到。这种格式的数据简称为 Gob（即 Go binary 的缩写）。类似于 [Python](http://c.biancheng.net/python/) 的“pickle”和 [Java](http://c.biancheng.net/java/) 的“Serialization”。

Gob 和 JSON 的 pack 之类的方法一样，由发送端使用 Encoder 对数据结构进行编码。在接收端收到消息之后，接收端使用 Decoder 将序列化的数据变化成本地变量。

Go语言可以通过 JSON 或 Gob 来序列化 struct 对象，虽然 JSON 的序列化更为通用，但利用 Gob 编码可以实现 JSON 所不能支持的 struct 的方法序列化，利用 Gob 包序列化 struct 保存到本地也十分简单。

Gob 不是可外部定义、语言无关的编码方式，它的首选的是二进制格式，而不是像 JSON 或 XML 那样的文本格式。Gob 并不是一种不同于 Go 的语言，而是在编码和解码过程中用到了 Go 的反射。

Gob 通常用于远程方法调用参数和结果的传输，以及应用程序和机器之间的数据传输。它和 JSON 或 XML 有什么不同呢？Gob 特定的用于纯 Go 的环境中，例如两个用Go语言写的服务之间的通信。这样的话服务可以被实现得更加高效和优化。

Gob 文件或流是完全自描述的，它里面包含的所有类型都有一个对应的描述，并且都是可以用Go语言解码，而不需要了解文件的内容。

只有可导出的字段会被编码，零值会被忽略。在解码结构体的时候，只有同时匹配名称和可兼容类型的字段才会被解码。当源数据类型增加新字段后，Gob 解码客户端仍然可以以这种方式正常工作。解码客户端会继续识别以前存在的字段，并且还提供了很大的灵活性，比如在发送者看来，整数被编码成没有固定长度的可变长度，而忽略具体的 Go 类型。

假如有下面这样一个结构体 T：

```go
type T struct { X, Y, Z int }
var t = T{X: 7, Y: 0, Z: 8}
```

而在接收时可以用一个结构体 U 类型的变量 u 来接收这个值：

```go
type U struct { X, Y *int8 }
var u U
```

在接收时，X 的值是 7，Y 的值是 0（Y 的值并没有从 t 中传递过来，因为它是零值）和 JSON 的使用方式一样，Gob 使用通用的 io.Writer 接口，通过 NewEncoder() 函数创建 Encoder 对象并调用 Encode()，相反的过程使用通用的 io.Reader 接口，通过 NewDecoder() 函数创建 Decoder 对象并调用 Decode 。

#### 创建 gob 文件

下面通过简单的示例程序来演示Go语言是如何创建 gob 文件的，代码如下所示：

```go
package main
import (
    "encoding/gob"
    "fmt"
    "os"
)
func main() {
    info := map[string]string{
        "name":    "C语言中文网",
        "website": "http://c.biancheng.net/golang/",
    }
    name := "demo.gob"
    File, _ := os.OpenFile(name, os.O_RDWR|os.O_CREATE, 0777)
    defer File.Close()
    enc := gob.NewEncoder(File)
    if err := enc.Encode(info); err != nil {
        fmt.Println(err)
    }
}
```

运行上面的代码会在当前目录下生成 demo.gob 文件，文件的内容如下所示：

```go
0eff 8104 0102 ff82 0001 0c01 0c00 0041
ff82 0002 046e 616d 6510 43e8 afad e8a8
80e4 b8ad e696 87e7 bd91 0777 6562 7369
7465 1e68 7474 703a 2f2f 632e 6269 616e
... ...
```

#### 读取 gob 文件

读取 gob 文件与创建 gob 文件同样简单，示例代码如下：

```go
package main
import (
    "encoding/gob"
    "fmt"
    "os"
)
func main() {
    var M map[string]string
    File, _ := os.Open("demo.gob")
    D := gob.NewDecoder(File)
    D.Decode(&M)
    fmt.Println(M)
}
```

运行结果如下：

```go
go run main.go
map[name:C语言中文网 website:http://c.biancheng.net/golang/]
```

### 5. 纯文本文件的读写操作

Go语言提供了很多文件操作的支持，在不同场景下，有对应的处理方式，本节我们来介绍一下文本文件的读写操作。

#### 写纯文本文件

由于Go语言的 fmt 包中打印函数强大而灵活，写纯文本数据非常简单直接，示例代码如下所示：

```go
package main
import (
    "bufio"
    "fmt"
    "os"
)
func main() {
    //创建一个新文件，写入内容
    filePath := "./output.txt"
    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        fmt.Printf("打开文件错误= %v \n", err)
        return
    }
    //及时关闭
    defer file.Close()
    //写入内容
    str := "http://c.biancheng.net/golang/\n" // \n\r表示换行  txt文件要看到换行效果要用 \r\n
    //写入时，使用带缓存的 *Writer
    writer := bufio.NewWriter(file)
    for i := 0; i < 3; i++ {
        writer.WriteString(str)
    }
    //因为 writer 是带缓存的，因此在调用 WriterString 方法时，内容是先写入缓存的
    //所以要调用 flush方法，将缓存的数据真正写入到文件中。
    writer.Flush()
}
```

运行上面代码会在当前目录下生成一个 output.txt 文件，文件内容如下：

```go
http://c.biancheng.net/golang/
http://c.biancheng.net/golang/
http://c.biancheng.net/golang/
```

#### 读纯文本文件

打开并读取一个纯文本格式的数据跟写入纯文本格式数据一样简单。要解析文本来重建原始数据可能稍微复杂，这需根据格式的复杂性而定。

示例代码如下所示：

```go
package main
import (
    "bufio"
    "fmt"
    "io"
    "os"
)
func main() {
    //打开文件
    file, err := os.Open("./output.txt")
    if err != nil {
        fmt.Println("文件打开失败 = ", err)
    }
    //及时关闭 file 句柄，否则会有内存泄漏
    defer file.Close()
    //创建一个 *Reader ， 是带缓冲的
    reader := bufio.NewReader(file)
    for {
        str, err := reader.ReadString('\n') //读到一个换行就结束
        if err == io.EOF {                  //io.EOF 表示文件的末尾
            break
        }
        fmt.Print(str)
    }
    fmt.Println("文件读取结束...")
}
```

运行结果如下：

```go
go run main.go
http://c.biancheng.net/golang/
http://c.biancheng.net/golang/
http://c.biancheng.net/golang/
文件读取结束...
```

### 6. 二进制文件的读写操作

Go语言的二进制（gob）格式是一个自描述的二进制序列。从其内部表示来看，Go语言的二进制格式由一个 0 块或者更多块的序列组成，其中的每一块都包含一个字节数，一个由 0 个或者多个 typeId-typeSpecification 对组成的序列，以及一个 typeId-value 对。

如果 typeId-value 对的 typeId 是预先定义好的（例如 bool、int 和 string 等），则这些 typeId-typeSpecification 对可以省略。否则就用类型对来描述一个自定义类型（如一个自定义的结构体）。类型对和值对之间的 typeId 没有区别。

正如我们将看到的，我们无需了解其内部结构就可以使用 gob 格式， 因为 encoding/gob 包会在幕后为我们打理好一切底层细节。

Go语言中的 encoding/gob 包也提供了与 encoding/json 包一样的编码解码功能，并且容易使用。通常而言如果对肉眼可读性不做要求，gob 格式是Go语言上用于文件存储和网络传输最为方便的格式。

#### 写Go语言二进制文件

下面通过一个简单的示例来演示一下Go语言是如何生成一个二进制文件的，代码如下所示：

```go
package main
import (
    "encoding/gob"
    "fmt"
    "os"
)
func main() {
    info := "http://c.biancheng.net/golang/"
    file, err := os.Create("./output.gob")
    if err != nil {
        fmt.Println("文件创建失败", err.Error())
        return
    }
    defer file.Close()
    encoder := gob.NewEncoder(file)
    err = encoder.Encode(info)
    if err != nil {
        fmt.Println("编码错误", err.Error())
        return
    } else {
        fmt.Println("编码成功")
    }
}
```

运行上面的代码会在当前目录下生成一个 output.gob 文件，文件内容如下所示：

```go
210c 001e 6874 7470 3a2f 2f63 2e62 6961
6e63 6865 6e67 2e6e 6574 2f67 6f6c 616e
672f 
```

#### 读Go语言二进制文件

读 gob 数据和写一样简单，示例代码如下：

```go
package main
import (
    "encoding/gob"
    "fmt"
    "os"
)
func main() {
    file, err := os.Open("./output.gob")
    if err != nil {
        fmt.Println("文件打开失败", err.Error())
        return
    }
    defer file.Close()
    decoder := gob.NewDecoder(file)
    info := ""
    err = decoder.Decode(&info)
    if err != nil {
        fmt.Println("解码失败", err.Error())
    } else {
        fmt.Println("解码成功")
        fmt.Println(info)
    }
}
```

运行结果如下：

```go
go run main.go
解码成功
http://c.biancheng.net/golang/
```

### 7. 自定义二进制文件的读写操作

虽然Go语言的 encoding/gob 包非常易用，而且使用时所需代码量也非常少，但是我们仍有可能需要创建自定义的二进制格式。自定义的二进制格式有可能做到最紧凑的数据表示，并且读写速度可以非常快。

不过，在实际使用中，我们发现以Go语言二进制格式的读写通常比自定义格式要快非常多，而且创建的文件也不会大很多。但如果我们必须通过满足 gob.GobEncoder 和 gob.GobDecoder 接口来处理一些不可被 gob 编码的数据，这些优势就有可能会失去。

在有些情况下我们可能需要与一些使用自定义二进制格式的软件交互，因此了解如何处理二进制文件就非常有用。

#### 写自定义二进制文件

Go语言的 encoding/binary 包中的 binary.Write() 函数使得以二进制格式写数据非常简单，函数原型如下：

```go
func Write(w io.Writer, order ByteOrder, data interface{}) error
```

Write 函数可以将参数 data 的 binary 编码格式写入参数 w 中，参数 data 必须是定长值、定长值的切片、定长值的指针。参数 order 指定写入数据的字节序，写入结构体时，名字中有`_`的字段会置为 0。

下面通过一个简单的示例程序来演示一下 Write 函数的使用，示例代码如下：

```go
package main
import (
    "bytes"
    "encoding/binary"
    "fmt"
    "os"
)
type Website struct {
    Url int32
}
func main() {
    file, err := os.Create("output.bin")
    for i := 1; i <= 10; i++ {
        info := Website{
            int32(i),
        }
        if err != nil {
            fmt.Println("文件创建失败 ", err.Error())
            return
        }
        defer file.Close()
        var bin_buf bytes.Buffer
        binary.Write(&bin_buf, binary.LittleEndian, info)
        b := bin_buf.Bytes()
        _, err = file.Write(b)
        if err != nil {
            fmt.Println("编码失败", err.Error())
            return
        }
    }
    fmt.Println("编码成功")
}
```

运行上面的程序会在当前目录下生成 output.bin 文件，文件内容如下：

```go
0100 0000 0200 0000 0300 0000 0400 0000
0500 0000 0600 0000 0700 0000 0800 0000
0900 0000 0a00 0000 
```

#### 读自定义二进制文件

读取自定义的二进制数据与写自定义二进制数据一样简单。我们无需解析这类数据，只需使用与写数据时相同的字节顺序将数据读进相同类型的值中。

示例代码如下：

```go
package main
import (
    "bytes"
    "encoding/binary"
    "fmt"
    "os"
)
type Website struct {
    Url int32
}
func main() {
    file, err := os.Open("output.bin")
    defer file.Close()
    if err != nil {
        fmt.Println("文件打开失败", err.Error())
        return
    }
    m := Website{}
    for i := 1; i <= 10; i++ {
        data := readNextBytes(file, 4)
        buffer := bytes.NewBuffer(data)
        err = binary.Read(buffer, binary.LittleEndian, &m)
        if err != nil {
            fmt.Println("二进制文件读取失败", err)
            return
        }
        fmt.Println("第", i, "个值为：", m)
    }
}
func readNextBytes(file *os.File, number int) []byte {
    bytes := make([]byte, number)
    _, err := file.Read(bytes)
    if err != nil {
        fmt.Println("解码失败", err)
    }
    return bytes
}
```

运行结果如下：

```go
go run main.go
第 1 个值为: {1}
第 2 个值为: {2}
第 3 个值为: {3}
第 4 个值为: {4}
第 5 个值为: {5}
第 6 个值为: {6}
第 7 个值为: {7}
第 8 个值为: {8}
第 9 个值为: {9}
第 10 个值为: {10}
```

至此，我们完成了对自定义二进制数据的读和写操作。只要小心选择表示长度的整数符号和大小，并将该长度值写在变长值（如切片）的内容之前，那么使用二进制数据进行工作并不难。

Go语言对二进制文件的支持还包括随机访问。这种情况下，我们必须使用 os.OpenFile() 函数来打开文件（而非 os.Open()），并给它传入合理的权限标志和模式（例如 os.O_RDWR 表示可读写）参数。

然后，就可以使用 os.File.Seek() 方法来在文件中定位并读写，或者使用 os.File.ReadAt() 和 os.File.WriteAt() 方法来从特定的字节偏移中读取或者写入数据。

Go语言还提供了其他常用的方法，包括 os.File.Stat() 方法，它返回的 os.FileInfo 包含了文件大小、权限以及日期时间等细节信息。

### 8. zip归档文件的读写操作

Go语言的标准库提供了对几种压缩格式的支持，其中包括 gzip，因此 Go 程序可以无缝地读写 .gz 扩展名的 gzip 压缩文件或非 .gz 扩展名的非压缩文件。此外标准库也提供了读和写 .zip 文件、tar 包文件（.tar 和 .tar.gz），以及读 .bz2 文件（即 .tar .bz2 文件）的功能。

本节我们将主要介绍 zip 归档文件的读写操作。

#### 创建 zip 归档文件

Go语言提供了 archive/zip 包来操作压缩文件，下面通过一个简单的的示例演示如何使用Go语言来创建一个 zip 文件，示例代码如下：

```go
package main
import (
    "archive/zip"
    "bytes"
    "fmt"
    "os"
)
func main() {
    // 创建一个缓冲区用来保存压缩文件内容
    buf := new(bytes.Buffer)
    // 创建一个压缩文档
    w := zip.NewWriter(buf)
    // 将文件加入压缩文档
    var files = []struct {
        Name, Body string
    }{
        {"Golang.txt", "http://c.biancheng.net/golang/"},
    }
    for _, file := range files {
        f, err := w.Create(file.Name)
        if err != nil {
            fmt.Println(err)
        }
        _, err = f.Write([]byte(file.Body))
        if err != nil {
            fmt.Println(err)
        }
    }
    // 关闭压缩文档
    err := w.Close()
    if err != nil {
        fmt.Println(err)
    }
    // 将压缩文档内容写入文件
    f, err := os.OpenFile("file.zip", os.O_CREATE|os.O_WRONLY, 0666)
    if err != nil {
        fmt.Println(err)
    }
    buf.WriteTo(f)
}
```

运行上面的文件会在当前目录下生成 file.zip 文件，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200110/4-200110150H0163.gif)
图：生成的压缩文件及文件的内容

#### 读取 zip 归档文件

读取一个 .zip 归档文件与创建一个归档文件一样简单，只是如果归档文件中包含带有路径的文件名，就必须重建目录结构。

示例代码如下所示：

```go
package main
import (
    "archive/zip"
    "fmt"
    "io"
    "os"
)
func main() {
    // 打开一个zip格式文件
    r, err := zip.OpenReader("file.zip")
    if err != nil {
        fmt.Printf(err.Error())
    }
    defer r.Close()
    // 迭代压缩文件中的文件，打印出文件中的内容
    for _, f := range r.File {
        fmt.Printf("文件名: %s\n", f.Name)
        rc, err := f.Open()
        if err != nil {
            fmt.Printf(err.Error())
        }
        _, err = io.CopyN(os.Stdout, rc, int64(f.UncompressedSize64))
        if err != nil {
            fmt.Printf(err.Error())
        }
        rc.Close()
    }
}
```

运行结果如下：

```go
go run main.go
文件名: Golang.txt
http://c.biancheng.net/golang/
```

### 9. tar归档文件的读写操作

#### 创建 tar 归档文件

tar 是一种打包格式，但不对文件进行压缩，所以打包后的文档一般远远大于 zip 和 tar.gz，因为不需要压缩的原因，所以打包的速度是非常快的，打包时 CPU 占用率也很低。

tar 的目的在于方便文件的管理，比如在我们的生活中，有很多小物品分散在房间的各个角落，为了方便整洁可以将这些零散的物品整理进一个箱子中，而 tar 的功能就类似这样。

创建 tar 归档文件与创建 .zip 归档文件非常类似，主要不同点在于我们将所有数据都写入相同的 writer 中，并且在写入文件的数据之前必须写入完整的头部，而非仅仅是一个文件名。

tar 打包实现原理如下：

- 创建一个文件 x.tar，然后向 x.tar 写入 tar 头部信息；
- 打开要被 tar 的文件，向 x.tar 写入头部信息，然后向 x.tar 写入文件信息；
- 当有多个文件需要被 tar 时，重复第二步直到所有文件都被写入到 x.tar 中；
- 关闭 x.tar，完成打包。


下面通过示例程序简单演示一下Go语言 tar 打包的实现：

```go
package main
import (
    "archive/tar"
    "fmt"
    "io"
    "os"
)
func main() {
    f, err := os.Create("./output.tar") //创建一个 tar 文件
    if err != nil {
        fmt.Println(err)
        return
    }
    defer f.Close()
    tw := tar.NewWriter(f)
    defer tw.Close()
    fileinfo, err := os.Stat("./main.exe") //获取文件相关信息
    if err != nil {
        fmt.Println(err)
    }
    hdr, err := tar.FileInfoHeader(fileinfo, "")
    if err != nil {
        fmt.Println(err)
    }
    err = tw.WriteHeader(hdr) //写入头文件信息
    if err != nil {
        fmt.Println(err)
    }
    f1, err := os.Open("./main.exe")
    if err != nil {
        fmt.Println(err)
        return
    }
    m, err := io.Copy(tw, f1) //将main.exe文件中的信息写入压缩包中
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println(m)
}
```

运行上面的代码会在当前目录下生成一个 output.tar 文件，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200113/4-200113105232619.gif)
图：生成的 output.tar 文件

#### 解压 tar 归档文件

解压 tar 归档文件比创建 tar 归档文档稍微简单些。首先需要将其打开，然后从这个 tar 头部中循环读取存储在这个归档文件内的文件头信息，从这个文件头里读取文件名，以这个文件名创建文件，然后向这个文件里写入数据即可。

示例代码如下所示：

```go
package main
import (
    "archive/tar"
    "fmt"
    "io"
    "os"
)
func main() {
    f, err := os.Open("output.tar")
    if err != nil {
        fmt.Println("文件打开失败", err)
        return
    }
    defer f.Close()
    r := tar.NewReader(f)
    for hdr, err := r.Next(); err != io.EOF; hdr, err = r.Next() {
        if err != nil {
            fmt.Println(err)
            return
        }
        fileinfo := hdr.FileInfo()
        fmt.Println(fileinfo.Name())
        f, err := os.Create("123" + fileinfo.Name())
        if err != nil {
            fmt.Println(err)
        }
        defer f.Close()
        _, err = io.Copy(f, r)
        if err != nil {
            fmt.Println(err)
        }
    }
}
```

运行上面的程序会将 tar 包的文件解压到当前目录中，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200113/4-2001131054501L.gif)
图：解压 tar 包


至此，我们完成了对压缩和归档文件及常规文件处理的介绍。Go语言使用 io.Reader、io.ReadCloser、io.Writer 和 io.WriteCloser 等接口处理文件的方式让开发者可以使用相同的编码模式来读写文件或者其他流（如网络流或者甚至是字符串），从而大大降低了难度。

### 10. 使用buffer读取文件

buffer 是缓冲器的意思，Go语言要实现缓冲读取需要使用到 bufio 包。bufio 包本身包装了 io.Reader 和 io.Writer 对象，同时创建了另外的 Reader 和 Writer 对象，因此对于文本 I/O 来说，bufio 包提供了一定的便利性。

buffer 缓冲器的实现原理就是，将文件读取进缓冲（内存）之中，再次读取的时候就可以避免文件系统的 I/O 从而提高速度。同理在进行写操作时，先把文件写入缓冲（内存），然后由缓冲写入文件系统。

#### 使用 bufio 包写入文件

bufio 和 io 包中有很多操作都是相似的，唯一不同的地方是 bufio 提供了一些缓冲的操作，如果对文件 I/O 操作比较频繁的，使用 bufio 包能够提高一定的性能。

在 bufio 包中，有一个 Writer 结构体，而其相关的方法支持一些写入操作，如下所示。

```go
//Writer 是一个空的结构体，一般需要使用 NewWriter 或者 NewWriterSize 来初始化一个结构体对象
type Writer struct {
        // contains filtered or unexported fields
}
//NewWriterSize 和 NewWriter 函数
//返回默认缓冲大小的 Writer 对象(默认是4096)
func NewWriter(w io.Writer) *Writer
//指定缓冲大小创建一个 Writer 对象
func NewWriterSize(w io.Writer, size int) *Writer
//Writer 对象相关的写入数据的方法
//把 p 中的内容写入 buffer，返回写入的字节数和错误信息。如果 nn < len(p)，返回错误信息中会包含为什么写入的数据比较短
func (b *Writer) Write(p []byte) (nn int, err error)
//将 buffer 中的数据写入 io.Writer
func (b *Writer) Flush() error
//以下三个方法可以直接写入到文件中
//写入单个字节
func (b *Writer) WriteByte(c byte) error
//写入单个 Unicode 指针返回写入字节数错误信息
func (b *Writer) WriteRune(r rune) (size int, err error)
//写入字符串并返回写入字节数和错误信息
func (b *Writer) WriteString(s string) (int, error)
```

示例代码如下所示：

```go
package main
import (
    "bufio"
    "fmt"
    "os"
)
func main() {
    name := "demo.txt"
    content := "http://c.biancheng.net/golang/"
    fileObj, err := os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_APPEND, 0644)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    defer fileObj.Close()
    writeObj := bufio.NewWriterSize(fileObj, 4096)
    //使用 Write 方法,需要使用 Writer 对象的 Flush 方法将 buffer 中的数据刷到磁盘
    buf := []byte(content)
    if _, err := writeObj.Write(buf); err == nil {
        if err := writeObj.Flush(); err != nil {
            panic(err)
        }
        fmt.Println("数据写入成功")
    }
}
```

运行上面的代码会在当前目录之下生成 demo.txt 文件，并将“http://c.biancheng.net/golang/”写入到该文件中。

#### 使用 bufio 包读取文件

使用 bufio 包读取文件也非常方便，我们先来看下 bufio 包的相关的 Reader 函数方法：

```go
//首先定义了一个用来缓冲 io.Reader 对象的结构体，同时该结构体拥有以下相关的方法
type Reader struct {
}
//NewReader 函数用来返回一个默认大小 buffer 的 Reader 对象（默认大小是 4096） 等同于 NewReaderSize(rd,4096)
func NewReader(rd io.Reader) *Reader
//该函数返回一个指定大小 buffer（size 最小为 16）的 Reader 对象，如果 io.Reader 参数已经是一个足够大的 Reader，它将返回该 Reader
func NewReaderSize(rd io.Reader, size int) *Reader
//该方法返回从当前 buffer 中能被读到的字节数
func (b *Reader) Buffered() int
//Discard 方法跳过后续的 n 个字节的数据，返回跳过的字节数。如果 0 <= n <= b.Buffered()，该方法将不会从 io.Reader 中成功读取数据
func (b *Reader) Discard(n int) (discarded int, err error)
//Peekf 方法返回缓存的一个切片，该切片只包含缓存中的前 n 个字节的数据
func (b *Reader) Peek(n int) ([]byte, error)
//把 Reader 缓存对象中的数据读入到 []byte 类型的 p 中，并返回读取的字节数。读取成功，err 将返回空值
func (b *Reader) Read(p []byte) (n int, err error)
//返回单个字节，如果没有数据返回 err
func (b *Reader) ReadByte() (byte, error)
//该方法在 b 中读取 delimz 之前的所有数据，返回的切片是已读出的数据的引用，切片中的数据在下一次的读取操作之前是有效的。如果未找到 delim，将返回查找结果并返回 nil 空值。因为缓存的数据可能被下一次的读写操作修改，因此一般使用 ReadBytes 或者 ReadString，他们返回的都是数据拷贝
func (b *Reader) ReadSlice(delim byte) (line []byte, err error)
//功能同 ReadSlice，返回数据的拷贝
func (b *Reader) ReadBytes(delim byte) ([]byte, error)
//功能同 ReadBytes，返回字符串
func (b *Reader) ReadString(delim byte) (string, error)
//该方法是一个低水平的读取方式，一般建议使用 ReadBytes('\n') 或 ReadString('\n')，或者使用一个 Scanner 来代替。ReadLine 通过调用 ReadSlice 方法实现，返回的也是缓存的切片，用于读取一行数据，不包括行尾标记（\n 或 \r\n）
func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)
//读取单个 UTF-8 字符并返回一个 rune 和字节大小
func (b *Reader) ReadRune() (r rune, size int, err error)
```

示例代码如下：

```go
package main
import (
    "bufio"
    "fmt"
    "os"
    "strconv"
)
func main() {
    fileObj, err := os.Open("demo.txt")
    if err != nil {
        fmt.Println("文件打开失败：", err)
        return
    }
    defer fileObj.Close()
    //一个文件对象本身是实现了io.Reader的 使用bufio.NewReader去初始化一个Reader对象，存在buffer中的，读取一次就会被清空
    reader := bufio.NewReader(fileObj)
    buf := make([]byte, 1024)
    //读取 Reader 对象中的内容到 []byte 类型的 buf 中
    info, err := reader.Read(buf)
    if err != nil {
        fmt.Println(err)
    }
    fmt.Println("读取的字节数:" + strconv.Itoa(info))
    //这里的buf是一个[]byte，因此如果需要只输出内容，仍然需要将文件内容的换行符替换掉
    fmt.Println("读取的文件内容:", string(buf))
}
```

运行结果如下：

```go
go run main.go
读取的字节数:30
读取的文件内容: http://c.biancheng.net/golang/
```



### 11. 并发目录遍历

在本节中，我们将构建一个程序，根据命令行指定的输入，报告一个或多个目录的磁盘使用情况，类似于 UNIX 的`du`命令。该程序大多数工作是由下面的 walkDir 函数完成，它使用 dirents 辅助函数来枚举目录中的条目，如下所示：

```go
  // wakjDir 递归地遍历以 dir 为根目录的整个文件树，并在 filesizes 上发送每个已找到文件的大小
  func walkDir(dir string, fileSizes chan<- int64) {
      for _, entry := range dirents(dir) {
          if entry.IsDir() {
              subdir := filepath.Join(dir, entry.Name())
              walkDir(subdir, fileSizes)
          } else {
              fileSizes <- entry.Size()
          }
      }
  }

  // dirents 返回 dir 目录中的条目
  func dirents(dir string) []os.FileInfo {
      entries, err := ioutil.ReadDir(dir)
      if err != nil {
          fmt.Fprintf(os.Stderr, "du1: %v\n", err)
          return nil
      }
      return entries
  }
```

ioutil.ReadDir 函数返回一个 os.FileInfo 类型的 slice，针对单个文件同样的信息可以通过调用 os.Stat 函数来返回。对每一个子目录，walkDir 递归调用它自己，对于每一个文件，walkDir 发送一条消息到 fileSizes 通道，消息的内容为文件所占用的字节数。

程序的完整代码如下所示，代码中 main 函数使用两个 goroutine，后台 goroutine 调用 walkDir 遍历命令行上指定的每一个目录，最后关闭 fileSizes 通道；主 goroutine 计算从通道中接收的文件的大小的和，最后输出总数。

```go
  package main

  import (
      "flag"
      "fmt"
      "io/ioutil"
      "os"
      "path/filepath"
  )

  func main() {
      // 确定初始目录
      flag.Parse()
      roots := flag.Args()
      if len(roots) == 0 {
          roots = []string{"."}
      }

      // 遍历文件树
      fileSizes := make(chan int64)
      go func() {
          for _, root := range roots {
              walkDir(root, fileSizes)
          }
          close(fileSizes)
      }()

      // 输出结果
      var nfiles, nbytes int64
      for size := range fileSizes {
          nfiles++
          nbytes += size
      }
      printDiskUsage(nfiles, nbytes)
  }

  func printDiskUsage(nfiles, nbytes int64) {
      fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)
  }

  // wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小
  func walkDir(dir string, fileSizes chan<- int64) {
      for _, entry := range dirents(dir) {
          if entry.IsDir() {
              subdir := filepath.Join(dir, entry.Name())
              walkDir(subdir, fileSizes)
          } else {
              fileSizes <- entry.Size()
          }
      }
  }

  // dirents 返回 dir 目录中的条目
  func dirents(dir string) []os.FileInfo {
      entries, err := ioutil.ReadDir(dir)
      if err != nil {
          fmt.Fprintf(os.Stderr, "du1: %v\n", err)
          return nil
      }
      return entries
  }
```

在输出结果前，程序等待较长时间：

go run main.go D:/code 18681 files 0.5 GB

如果程序可以通知它的进度，将会更友好，但是仅把 printDiskUsage 调用移动到循环内部会使它输出数千行结果，所以这里对上面的程序进行一些调整，在有`-v`标识的时候周期性的输出当前目录的总和，如果只想看到最终的结果省略`-v`即可。

```go
  package main

  import (
      "flag"
      "fmt"
      "io/ioutil"
      "os"
      "path/filepath"
      "time"
  )

  var verbose = flag.Bool("v", false, "显示详细进度")

  func main() {
      // ...启动后台 goroutine...
      // 确定初始目录
      flag.Parse()
      roots := flag.Args()
      if len(roots) == 0 {
          roots = []string{"."}
      }
      // 遍历文件树
      fileSizes := make(chan int64)
      go func() {
          for _, root := range roots {
              walkDir(root, fileSizes)
          }
          close(fileSizes)
      }()
      // 定期打印结果
      var tick <-chan time.Time
      if *verbose {
          tick = time.Tick(500 * time.Millisecond)
      }
      var nfiles, nbytes int64
  loop:
      for {
          select {
          case size, ok := <-fileSizes:
              if !ok {
                  break loop // fileSizes 关闭
              }
              nfiles++
              nbytes += size
          case <-tick:
              printDiskUsage(nfiles, nbytes)
          }
      }
      printDiskUsage(nfiles, nbytes) // 最终总数
  }

  func printDiskUsage(nfiles, nbytes int64) {
      fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)
  }

  // wakjDir 递归地遍历以 dir 为根目录的整个文件树,并在 filesizes 上发送每个已找到的文件的大小
  func walkDir(dir string, fileSizes chan<- int64) {
      for _, entry := range dirents(dir) {
          if entry.IsDir() {
              subdir := filepath.Join(dir, entry.Name())
              walkDir(subdir, fileSizes)
          } else {
              fileSizes <- entry.Size()
          }
      }
  }

  // dirents 返回 dir 目录中的条目
  func dirents(dir string) []os.FileInfo {
      entries, err := ioutil.ReadDir(dir)
      if err != nil {
          fmt.Fprintf(os.Stderr, "du1: %v\n", err)
          return nil
      }
      return entries
  }
```

因为这个程序没有使用 range 循环，所以第一个 select 情况必须显式判断 fileSizes 通道是否已经关闭，使用两个返回值的形式进行接收操作。如果通道已经关闭，程序退出循环。标签化的 break 语句将跳出 select 和 for 循环的逻辑。没有标签的 break 只能跳出 select 的逻辑，导致循环的下一次迭代。

运行结果如下所示：

go run main.go -v D:\ 296077 files 57.9 GB 302142 files 58.0 GB 306669 files 58.1 GB 314725 files 58.2 GB 320050 files 58.3 GB 341713 files 58.6 GB 346102 files 64.2 GB

此程序的弊端也很明显，它依然会耗费太长的时间。

所以，下面为每一个 walkDir 的调用创建一个新的 goroutine。它使用 sync.WaitGroup 来为当前存活的 walkDir 调用计数，一个 goroutine 在计数器减为 0 的时候关闭 fileSizes 通道。

```go
  package main

  import (
      "flag"
      "fmt"
      "io/ioutil"
      "os"
      "path/filepath"
      "sync"
      "time"
  )

  var verbose = flag.Bool("v", false, "显示详细进度")

  func main() {
      // ...确定根目录...
      flag.Parse()
      // 确定初始目录
      roots := flag.Args()
      if len(roots) == 0 {
          roots = []string{"."}
      }
      // 并行遍历每一个文件树
      fileSizes := make(chan int64)
      var n sync.WaitGroup
      for _, root := range roots {
          n.Add(1)
          go walkDir(root, &n, fileSizes)
      }
      go func() {
          n.Wait()
          close(fileSizes)
      }()
      // 定期打印结果
      var tick <-chan time.Time
      if *verbose {
          tick = time.Tick(500 * time.Millisecond)
      }
      var nfiles, nbytes int64
  loop:
      for {
          select {
          case size, ok := <-fileSizes:
              if !ok {
                  break loop // fileSizes 关闭
              }
              nfiles++
              nbytes += size
          case <-tick:
              printDiskUsage(nfiles, nbytes)
          }
      }
      printDiskUsage(nfiles, nbytes) // 最终总数
  }

  func printDiskUsage(nfiles, nbytes int64) {
      fmt.Printf("%d files  %.1f GB\n", nfiles, float64(nbytes)/1e9)
  }

  func walkDir(dir string, n *sync.WaitGroup, fileSizes chan<- int64) {
      defer n.Done()
      for _, entry := range dirents(dir) {
          if entry.IsDir() {
              n.Add(1)
              subdir := filepath.Join(dir, entry.Name())
              go walkDir(subdir, n, fileSizes)
          } else {
              fileSizes <- entry.Size()
          }
      }
  }

  // sema是一个用于限制目录并发数的计数信号量
  var sema = make(chan struct{}, 20)

  // dirents返回directory目录中的条目
  func dirents(dir string) []os.FileInfo {
      sema <- struct{}{}        // 获取令牌
      defer func() { <-sema }() // 释放令牌
      entries, err := ioutil.ReadDir(dir)
      if err != nil {
          fmt.Fprintf(os.Stderr, "du: %v\n", err)
          return nil
      }
      return entries
  }
```

尽管系统与系统之间有很多的不同，但是这个版本的速度比前一个版本快几倍。

### 12. 从ini配置文件中读取需要配置的值

INI 文件是 Initialization File 的缩写，即初始化文件，是 Windows 的系统配置文件所采用的存储格式，统管 Windows 的各项配置。INI 文件格式由节（section）和键（key）构成，一般用于操作系统、虚幻游戏引擎、GIT 版本管理中，这种配置文件的文件扩展名为`.ini`。

下面是从 GIT 版本管理的配置文件中截取的一部分内容，展示 INI 文件的样式。

[core] repositoryformatversion = 0

filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true hideDotFiles = dotGitOnly [remote “origin”] url = https://github.com/davyxu/cellnet fetch = +refs/heads/*:refs/remotes/origin/* [branch “master”] remote = origin merge = refs/heads/master

#### INI 文件的格式

INI 文件由多行文本组成，整个配置由`[ ]`拆分为多个 “段”（section）。每个段中又以`＝`分割为 “键” 和“值”。

INI 文件以`;`置于行首视为注释，注释后将不会被处理和识别，如下所示：

[sectionl] key1=value1 ;key2=value2 [section2]

#### 从 INI 文件中取值的函数

熟悉了 INI 文件的格式后，下面我们创建一个 example.ini 文件，并将从 GIT 版本管理配置文件中截取的一部分内容复制到该文件中。

准备好 example.ini 文件后，下面我们开始尝试读取该 INI 文件，并从文件中获取需要的数据，完整的示例代码如下所示：

```go
  package main

  import (
      "bufio"
      "fmt"
      "os"
      "strings"
  )

  // 根据文件名，段名，键名获取ini的值
  func getValue(filename, expectSection, expectKey string) string {
      // 打开文件
      file, err := os.Open(filename)
      // 文件找不到，返回空
      if err != nil {
          return ""
      }
      // 在函数结束时，关闭文件
      defer file.Close()
      // 使用读取器读取文件
      reader := bufio.NewReader(file)
      // 当前读取的段的名字
      var sectionName string
      for {
          // 读取文件的一行
          linestr, err := reader.ReadString('\n')
          if err != nil {
              break
          }
          // 切掉行的左右两边的空白字符
          linestr = strings.TrimSpace(linestr)
          // 忽略空行
          if linestr == "" {
              continue
          }
          // 忽略注释
          if linestr[0] == ';' {
              continue
          }
          // 行首和尾巴分别是方括号的，说明是段标记的起止符
          if linestr[0] == '[' && linestr[len(linestr)-1] == ']' {
              // 将段名取出
              sectionName = linestr[1 : len(linestr)-1]
              // 这个段是希望读取的
          } else if sectionName == expectSection {
              // 切开等号分割的键值对
              pair := strings.Split(linestr, "=")
              // 保证切开只有1个等号分割的简直情况
              if len(pair) == 2 {
                  // 去掉键的多余空白字符
                  key := strings.TrimSpace(pair[0])
                  // 是期望的键
                  if key == expectKey {
                      // 返回去掉空白字符的值
                      return strings.TrimSpace(pair[1])
                  }
              }
          }
      }
      return ""
  }

  func main() {
      fmt.Println(getValue("example.ini", "remote \"origin\"", "fetch"))
      fmt.Println(getValue("example.ini", "core", "hideDotFiles"))
  }
```

本例并不是将整个 INI 文件读取保存后再获取需要的字段数据并返回，这里使用 getValue() 函数，每次从指定文件中找到需要的段（Section）及键（Key）对应的值。

getValue() 函数的声明如下：

```go
func getValue(filename, expectSection, expectKey string) string
```

参数说明如下。

- filename：INI 文件的文件名。

- expectSection：期望读取的段。

- expectKey：期望读取段中的键。

getValue() 函数的实际使用例子参考代码如下：

```go
func main() {
    fmt.Println(getValue("example.ini", "remote \"origin\"","fetch"))
    fmt.Println(getValue("example.ini","core","hideDotFiles"))
}
```

运行上面的示例程序，输出结果如下：

+refs/heads/*:refs/remotes/origin/* dotGitOnly

输出内容中 “+refs/heads/*:refs/remotes/origin/*” 表示 INI 文件中`[remote "origin"]`的 “fetch” 键对应的值；dotGitOnly 表示 INI 文件中`[core]`中键名为 “hideDotFiles” 的值。

注意 main 函数的第 2 行中，由于段名中包含双引号，所以使用`\`进行转义。

getValue() 函数的逻辑由 4 部分组成：即读取文件、读取行文本、读取段和读取键值组成。接下来分步骤了解 getValue() 函数的详细处理过程。

#### 读取文件

Go 语言的 OS 包中提供了文件打开函数 os.Open()，文件读取完成后需要及时关闭，否则文件会发生占用，系统无法释放缓冲资源。参考下面代码：

```go
  // 打开文件
  file, err := os.Open(filename)

  // 文件找不到，返回空
  if err != nil {
      return ""
  }

  // 在函数结束时，关闭文件
  defer file.Close()
```

代码说明如下：

- 第 2 行，filename 是由 getValue() 函数参数提供的 INI 的文件名。使用 os.Open() 函数打开文件，如果成功打开，会返回文件句柄，同时返回打开文件时可能发生的错误：err。

- 第 5 行，如果文件打开错误，err 将不为 nil，此时 getValue() 函数返回一个空的字符串，表示无法从给定的 INI 文件中获取到需要的值。

- 第 10 行，使用 defer 延迟执行函数，defer 并不会在这一行执行，而是延迟在任何一个 getValue() 函数的返回点，也就是函数退出的地方执行。调用 file.Close() 函数后，打开的文件就会被关闭并释放系统资源。

INI 文件已经打开了，接下来就可以开始读取 INI 的数据了。

#### 读取行文本

INI 文件的格式是由多行文本组成，因此需要构造一个循环，不断地读取 INI 文件的所有行。Go 语言总是将文件以二进制格式打开，通过不同的读取方式对二进制文件进行操作。Go 语言对二进制读取有专门的代码，bufio 包即可以方便地以比较常见的方式读取二进制文件。

```go
  // 使用读取器读取文件
  reader := bufio.NewReader(file)

  // 当前读取的段的名字
  var sectionName string

  for {

      // 读取文件的一行
      linestr, err := reader.ReadString('\n')
      if err != nil {
          break
      }

      // 切掉行的左右两边的空白字符
      linestr = strings.TrimSpace(linestr)

      // 忽略空行
      if linestr == "" {
          continue
      }

      // 忽略注释
      if linestr[0] == ';' {
          continue
      }

      //读取段和键值的代码
      //...
  }
```

代码说明如下：

- 第 2 行，使用 bufio 包提供的 NewReader() 函数，传入文件并构造一个读取器。

- 第 5 行，提前声明段的名字字符串，方便后面的段和键值读取。

- 第 7 行，构建一个读取循环，不断地读取文件中的每一行。

- 第 10 行，使用 reader.ReadString() 从文件中读取字符串，直到碰到`\n`，也就是行结束。这个函数返回读取到的行字符串（包括`\n`）和可能的读取错误 err，例如文件读取完毕。

- 第 16 行，每一行的文本可能会在标识符两边混杂有空格、回车符、换行符等不可见的空白字符，使用 strings.TrimSpace() 可以去掉这些空白字符。

- 第 19 行，可能存在空行的情况，继续读取下一行，忽略空行。

- 第 24 行，当行首的字符为`;`分号时，表示这一行是注释行，忽略一整行的读取。

读取 INI 文本文件时，需要注意各种异常情况。文本中的空白符就是经常容易忽略的部分，空白符在调试时完全不可见，需要打印出字符的 ASCII 码才能辨别。

抛开各种异常情况拿到了每行的行文本 linestr 后，就可以方便地读取 INI 文件的段和键值了。

#### 读取段

行字符串 linestr 已经去除了空白字符串，段的起止符又以`[`开头，以`]`结尾，因此可以直接判断行首和行尾的字符串匹配段的起止符匹配时读取的是段，如下图所示。

[![img](http://c.biancheng.net/uploads/allimg/190821/4-1ZR112563KA.gif)](http://c.biancheng.net/uploads/allimg/190821/4-1ZR112563KA.gif)

图：INI 文件的段名解析

此时，段只是一个标识，而无任何内容，因此需要将段的名字取出保存在 sectionName（己在之前的代码中定义）中，待读取段后面的键值对时使用。

```go
  // 行首和尾巴分别是方括号的，说明是段标记的起止符
  if linestr[0] == '[' && linestr[len(linestr)-1] == ']' {

      // 将段名取出
      sectionName = linestr[1 : len(linestr)-1]

      // 这个段是希望读取的
  }
```

代码说明如下：

- 第 2 行，`linestr[0]`表示行首的字符，`len(linestr)-1`取出字符串的最后一个字符索引随后取出行尾的字符。根据两个字符串是否匹配方括号，断定当前行是否为段。

- 第 5 行，linestr 两边的`[`和`]`去掉，取出中间的段名保存在 sectionName 中，留着后面的代码用。

#### 读取键值

这里代码紧接着前面的代码。当前行不是段时（不以`[`开头），那么行内容一定是键值对。别忘记此时 getValue() 的参数对段有匹配要求。找到能匹配段的键值对后，开始对键值对进行解析，参考下面的代码：

```go
  else if sectionName == expectSection {

      // 切开等号分割的键值对
      pair := strings.Split(linestr, "=")

      // 保证切开只有1个等号分割的简直情况
      if len(pair) == 2 {

          // 去掉键的多余空白字符
          key := strings.TrimSpace(pair[0])

          // 是期望的键
          if key == expectKey {

              // 返回去掉空白字符的值
              return strings.TrimSpace(pair[1])
          }
      }

  }
```

代码说明如下：

- 第 1 行，当前的段匹配期望的段时，进行后面的解析。

- 第 4 行，对行内容（linestr）通过 strings.Split() 函数进行切割，INI 的键值对使用`=`分割，分割后 strings.Split() 函数会返回字符串切片，其类型为 []string。这里只考虑一个`=`的情况，因此被分割后 strings.Split() 函数返回的字符串切片有 2 个元素。

- 第 7 行，只考虑切割出 2 个元素的情况。其他情况会被忽略， 键值如没有`=`、行中多余一个`=`等情况。

- 第 10 行，pair[0] 表示`=`左边的键。使用 strings.TrimSpace() 函数去掉空白符，如下图所示。

- 第 13 行，键值对切割出后，还需要判断键是否为期望的键。

- 第 16 行，匹配期望的键时，将 pair[1] 中保存的键对应的值经过去掉空白字符处理后作为函数返回值返回。

[![img](http://c.biancheng.net/uploads/allimg/190821/4-1ZR1125U3U9.gif)](http://c.biancheng.net/uploads/allimg/190821/4-1ZR1125U3U9.gif)

图：lNI 的键值解析

### 13. 文件的写入、追加、读取、复制操作

Go语言的 os 包下有一个 OpenFile 函数，其原型如下所示：

```go
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

其中 name 是文件的文件名，如果不是在当前路径下运行需要加上具体路径；flag 是文件的处理参数，为 int 类型，根据系统的不同具体值可能有所不同，但是作用是相同的。

下面列举了一些常用的 flag 文件处理参数：

- O_RDONLY：只读模式打开文件；
- O_WRONLY：只写模式打开文件；
- O_RDWR：读写模式打开文件；
- O_APPEND：写操作时将数据附加到文件尾部（追加）；
- O_CREATE：如果不存在将创建一个新文件；
- O_EXCL：和 O_CREATE 配合使用，文件必须不存在，否则返回一个错误；
- O_SYNC：当进行一系列写操作时，每次都要等待上次的 I/O 操作完成再进行；
- O_TRUNC：如果可能，在打开时清空文件。


【示例 1】：创建一个新文件 golang.txt，并在其中写入 5 句“http://c.biancheng.net/golang/”。

```go
package main
import (
    "bufio"
    "fmt"
    "os"
)
func main() {
    //创建一个新文件，写入内容 5 句 “http://c.biancheng.net/golang/”
    filePath := "e:/code/golang.txt"
    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE, 0666)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    //及时关闭file句柄
    defer file.Close()
    //写入文件时，使用带缓存的 *Writer
    write := bufio.NewWriter(file)
    for i := 0; i < 5; i++ {
        write.WriteString("http://c.biancheng.net/golang/ \n")
    }
    //Flush将缓存的文件真正写入到文件中
    write.Flush()
}
```

执行成功之后会在指定目录下生成一个 golang.txt 文件，打开该文件如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200115/4-200115100Q94R.gif)


【示例 2】：打开一个存在的文件，在原来的内容追加内容“C语言中文网”

```go
package main
import (
    "bufio"
    "fmt"
    "os"
)
func main() {
    filePath := "e:/code/golang.txt"
    file, err := os.OpenFile(filePath, os.O_WRONLY|os.O_APPEND, 0666)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    //及时关闭file句柄
    defer file.Close()
    //写入文件时，使用带缓存的 *Writer
    write := bufio.NewWriter(file)
    for i := 0; i < 5; i++ {
        write.WriteString("C语言中文网 \r\n")
    }
    //Flush将缓存的文件真正写入到文件中
    write.Flush()
}
```

执行成功之后，打开 golang.txt 文件发现内容追加成功，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200115/4-20011510133aa.gif)


【示例 3】：打开一个存在的文件，将原来的内容读出来，显示在终端，并且追加 5 句“Hello，C语言中文网”。

```go
package main
import (
    "bufio"
    "fmt"
    "io"
    "os"
)
func main() {
    filePath := "e:/code/golang.txt"
    file, err := os.OpenFile(filePath, os.O_RDWR|os.O_APPEND, 0666)
    if err != nil {
        fmt.Println("文件打开失败", err)
    }
    //及时关闭file句柄
    defer file.Close()
    //读原来文件的内容，并且显示在终端
    reader := bufio.NewReader(file)
    for {
        str, err := reader.ReadString('\n')
        if err == io.EOF {
            break
        }
        fmt.Print(str)
    }
    //写入文件时，使用带缓存的 *Writer
    write := bufio.NewWriter(file)
    for i := 0; i < 5; i++ {
        write.WriteString("Hello，C语言中文网。 \r\n")
    }
    //Flush将缓存的文件真正写入到文件中
    write.Flush()
}
```

执行成功之后，会在控制台打印出文件的内容，并在文件中追加指定的内容，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200115/4-200115101939462.gif)


【示例 4】：编写一个程序，将一个文件的内容复制到另外一个文件（注：这两个文件都已存在）

```go
package main
import (
    "fmt"
    "io/ioutil"
)
func main() {
    file1Path := "e:/code/golang.txt"
    file2Path := "e:/code/other.txt"
    data, err := ioutil.ReadFile(file1Path)
    if err != nil {
        fmt.Printf("文件打开失败=%v\n", err)
        return
    }
    err = ioutil.WriteFile(file2Path, data, 0666)
    if err != nil {
        fmt.Printf("文件打开失败=%v\n", err)
    }
}
```

执行成功后，发现内容已经复制成功，如下图所示：



![img](http://c.biancheng.net/uploads/allimg/200115/4-200115102T0491.gif)

### 14.  文件锁操作

我们使用Go语言开发一些程序的时候，往往出现多个进程同时操作同一份文件的情况，这很容易导致文件中的数据混乱。这时我们就需要采用一些手段来平衡这些冲突，文件锁（flock）应运而生，下面我们就来介绍一下。

对于 flock，最常见的例子就是 Nginx，进程运行起来后就会把当前的 PID 写入这个文件，当然如果这个文件已经存在了，也就是前一个进程还没有退出，那么 Nginx 就不会重新启动，所以 flock 还可以用来检测进程是否存在。

flock 是对于整个文件的建议性锁。也就是说，如果一个进程在一个文件（inode）上放了锁，其它进程是可以知道的（建议性锁不强求进程遵守）。最棒的一点是，它的第一个参数是文件描述符，在此文件描述符关闭时，锁会自动释放。而当进程终止时，所有的文件描述符均会被关闭。所以很多时候就不用考虑类似原子锁解锁的事情。

在具体介绍前，先上代码

```go
package main
import (
    "fmt"
    "os"
    "sync"
    "syscall"
    "time"
)
//文件锁
type FileLock struct {
    dir string
    f   *os.File
}
func New(dir string) *FileLock {
    return &FileLock{
        dir: dir,
    }
}
//加锁
func (l *FileLock) Lock() error {
    f, err := os.Open(l.dir)
    if err != nil {
        return err
    }
    l.f = f
    err = syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
    if err != nil {
        return fmt.Errorf("cannot flock directory %s - %s", l.dir, err)
    }
    return nil
}
//释放锁
func (l *FileLock) Unlock() error {
    defer l.f.Close()
    return syscall.Flock(int(l.f.Fd()), syscall.LOCK_UN)
}
func main() {
    test_file_path, _ := os.Getwd()
    locked_file := test_file_path
    wg := sync.WaitGroup{}
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(num int) {
            flock := New(locked_file)
            err := flock.Lock()
            if err != nil {
                wg.Done()
                fmt.Println(err.Error())
                return
            }
            fmt.Printf("output : %d\n", num)
            wg.Done()
        }(i)
    }
    wg.Wait()
    time.Sleep(2 * time.Second)
}
```

在 Windows 系统下运行上面的代码会出现下面的错误：

```go
undefined: syscall.Flock
undefined: syscall.LOCK_EX
undefined: syscall.LOCK_NB
undefined: syscall.Flock
undefined: syscall.LOCK_UN
```

这是因为 Windows 系统不支持 pid 锁，所以我们需要在 Linux 或 Mac 系统下才能正常运行上面的程序。

上面代码中演示了同时启动 10 个 goroutinue，但在程序运行过程中，只有一个 goroutine 能获得文件锁（flock）。其它的 goroutinue 在获取不到 flock 后，会抛出异常的信息。这样即可达到同一文件在指定的周期内只允许一个进程访问的效果。

代码中文件锁的具体调用：

```go
syscall.Flock(int(f.Fd()), syscall.LOCK_EX|syscall.LOCK_NB)
```

我们采用了 syscall.LOCK_EX、syscall.LOCK_NB，这是什么意思呢？

flock 属于建议性锁，不具备强制性。一个进程使用 flock 将文件锁住，另一个进程可以直接操作正在被锁的文件，修改文件中的数据，原因在于 flock 只是用于检测文件是否被加锁，针对文件已经被加锁，另一个进程写入数据的情况，内核不会阻止这个进程的写入操作，也就是建议性锁的内核处理策略。

flock 主要三种操作类型：

- LOCK_SH：共享锁，多个进程可以使用同一把锁，常被用作读共享锁；
- LOCK_EX：排他锁，同时只允许一个进程使用，常被用作写锁；
- LOCK_UN：释放锁。


进程使用 flock 尝试锁文件时，如果文件已经被其他进程锁住，进程会被阻塞直到锁被释放掉，或者在调用 flock 的时候，采用 LOCK_NB 参数。在尝试锁住该文件的时候，发现已经被其他服务锁住，会返回错误，错误码为 EWOULDBLOCK。

flock 锁的释放非常具有特色，即可调用 LOCK_UN 参数来释放文件锁，也可以通过关闭 fd 的方式来释放文件锁（flock 的第一个参数是 fd），意味着 flock 会随着进程的关闭而被自动释放掉。



## 第十二章 编译与工具

### 1. go build命令（go语言编译命令）完全攻略

Go语言的编译速度非常快。Go 1.9 版本后默认利用Go语言的并发特性进行函数粒度的并发编译。

Go语言的程序编写基本以源码方式，无论是自己的代码还是第三方代码，并且以 GOPATH 作为工作目录和一套完整的工程目录规则。因此Go语言中日常编译时无须像 [C++](http://c.biancheng.net/cplus/) 一样配置各种包含路径、链接库地址等。

Go语言中使用 go build 命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。

go build 有很多种编译方法，如无参数编译、文件列表编译、指定包编译等，使用这些方法都可以输出可执行文件。

#### go build 无参数编译

本小节需要用到的代码具体位置是`./src/chapter11/gobuild`。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

代码相对于 GOPATH 的目录关系如下：

```go
.
└── src
  └── chapter11
    └── gobuild
      ├── lib.go
      └── main.go
```

main.go 代码如下：

```go
package main
import (
    "fmt"
)
func main() {
    // 同包的函数
    pkgFunc()
    fmt.Println("hello world")
}
```

lib.go 代码如下：

```go
package main
import "fmt"
func pkgFunc() {
    fmt.Println("call pkgFunc")
}
```

如果源码中没有依赖 GOPATH 的包引用，那么这些源码可以使用无参数 go build。格式如下：

```go
go build
```

在代码所在目录（`./src/chapter11/gobuild`）下使用 go build 命令，如下所示：

```go
$ cd src/chapter11/gobuild/
$ go build
$ ls
gobuild lib.go main.go
$ ./gobuild
call pkgFunc
hello world
```

命令行指令和输出说明如下：

- 第 1 行，转到本例源码目录下。
- 第 2 行，go build 在编译开始时，会搜索当前目录的 go 源码。这个例子中，go build 会找到 lib.go 和 main.go 两个文件。编译这两个文件后，生成当前目录名的可执行文件并放置于当前目录下，这里的可执行文件是 go build。
- 第 3 行和第 4 行，列出当前目录的文件，编译成功，输出 go build 可执行文件。
- 第 5 行，运行当前目录的可执行文件 go build。
- 第 6 行和第 7 行，执行 go build 后的输出内容。

#### go build+文件列表

编译同目录的多个源码文件时，可以在 go build 的后面提供多个文件名，go build 会编译这些源码，输出可执行文件，“go build+文件列表”的格式如下：

```go
go build file1.go file2.go……
```

在代码代码所在目录（./src/chapter11/gobuild）中使用 go build，在 go build 后添加要编译的源码文件名，代码如下：

```go
$ go build main.go lib.go
$ ls
lib.go main main.go
$ ./main
call pkgFunc
hello world
$ go build lib.go main.go
$ ls
lib lib.go main main.go
```

命令行指令和输出说明如下：

- 第 1 行在 go build 后添加文件列表，选中需要编译的 Go 源码。
- 第 2  行和第 3 行列出完成编译后的当前目录的文件。这次的可执行文件名变成了 main。
- 第 4～6 行，执行 main 文件，得到期望输出。
- 第 7 行，尝试调整文件列表的顺序，将 lib.go 放在列表的首位。
- 第 8 行和第 9 行，编译结果中出现了 lib 可执行文件。

##### 提示

使用“go build+文件列表”方式编译时，可执行文件默认选择文件列表中第一个源码文件作为可执行文件名输出。

如果需要指定输出可执行文件名，可以使用`-o`参数，参见下面的例子：

```go
$ go build -o myexec main.go lib.go
$ ls
lib.go main.go myexec
$ ./myexec
call pkgFunc
hello world
```

上面代码中，在 go build 和文件列表之间插入了`-o myexec`参数，表示指定输出文件名为 myexec。

##### 注意

使用“go build+文件列表”编译方式编译时，文件列表中的每个文件必须是同一个包的 Go 源码。也就是说，不能像 C++ 一样将所有工程的 Go 源码使用文件列表方式进行编译。编译复杂工程时需要用“指定包编译”的方式。

“go build+文件列表”方式更适合使用Go语言编写的只有少量文件的工具。

#### go build+包

“go build+包”在设置 GOPATH 后，可以直接根据包名进行编译，即便包内文件被增（加）删（除）也不影响编译指令。

##### 1) 代码位置及源码

本小节需要用到的代码具体位置是`./src/chapter11/goinstall`。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

相对于GOPATH的目录关系如下：

```go
.
└── src
  └── chapter11
    └──goinstall
      ├── main.go
      └── mypkg
        └── mypkg.go
```

main.go代码如下：

```go
package main
import (
    "chapter11/goinstall/mypkg"
    "fmt"
)
func main() {
    mypkg.CustomPkgFunc()
    fmt.Println("hello world")
}
```

mypkg.go代码如下：

```go
package mypkg
import "fmt"
func CustomPkgFunc() {
    fmt.Println("call CustomPkgFunc")
}
```

#### 2) 按包编译命令

执行以下命令将按包方式编译 goinstall 代码：

```go
$ export GOPATH=/home/davy/golangbook/code
$ go build -o main chapter11/goinstall
$ ./goinstall
call CustomPkgFunc
hello world
```

代码说明如下：

- 第 1 行，设置环境变量 GOPATH，这里的路径是笔者的目录，可以根据实际目录来设置 GOPATH。
- 第 2 行，`-o`执行指定输出文件为 main，后面接要编译的包名。包名是相对于 GOPATH 下的 src 目录开始的。
- 第 3～5 行，编译成功，执行 main 后获得期望的输出。


读者在参考这个例子编译代码时，需要将 GOPATH 更换为自己的目录。注意 GOPATH 下的目录结构，源码必须放在 GOPATH 下的 src 目录下。所有目录中不要包含中文。

#### go build 编译时的附加参数

go build 还有一些附加参数，可以显示更多的编译信息和更多的操作，详见下表所示。

| 附加参数 | 备  注                                      |
| -------- | ------------------------------------------- |
| -v       | 编译时显示包名                              |
| -p n     | 开启并发编译，默认情况下该值为 CPU 逻辑核数 |
| -a       | 强制重新构建                                |
| -n       | 打印编译时会用到的所有命令，但不真正执行    |
| -x       | 打印编译时会用到的所有命令                  |
| -race    | 开启竞态检测                                |


表中的附加参数按使用频率排列，读者可以根据需要选择使用。

### 2. go clean命令——清除编译文件

Go语言中`go clean`命令可以移除当前源码包和关联源码包里面编译生成的文件，这些文件包括以下几种：

- 执行`go build`命令时在当前目录下生成的与包名或者 Go 源码文件同名的可执行文件。在 Windows 下，则是与包名或者 Go 源码文件同名且带有“.exe”后缀的文件。
- 执行`go test`命令并加入`-c`标记时在当前目录下生成的以包名加“.test”后缀为名的文件。在 Windows 下，则是以包名加“.test.exe”后缀的文件。
- 执行`go install`命令安装当前代码包时产生的结果文件。如果当前代码包中只包含库源码文件，则结果文件指的就是在工作区 pkg 目录下相应的归档文件。如果当前代码包中只包含一个命令源码文件，则结果文件指的就是在工作区 bin 目录下的可执行文件。
- 在编译 Go 或 C 源码文件时遗留在相应目录中的文件或目录 。包括：“_obj”和“_test”目录，名称为“_testmain.go”、“test.out”、“build.out”或“a.out”的文件，名称以“.5”、“.6”、“.8”、“.a”、“.o”或“.so”为后缀的文件。这些目录和文件是在执行`go build`命令时生成在临时目录中的。

`go clean`命令就像 [Java](http://c.biancheng.net/java/) 中的`maven clean`命令一样，会清除掉编译过程中产生的一些文件。在 Java 中通常是 .class 文件，而在Go语言中通常是上面我们所列举的那些文件。

```go
go clean -i -n
```

通过上面的示例可以看出，`go clean`命令还可以指定一些参数。对应的参数的含义如下所示：

- -i 清除关联的安装的包和可运行文件，也就是通过`go install`安装的文件；
- -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的；
- -r 循环的清除在 import 中引入的包；
- -x 打印出来执行的详细命令，其实就是 -n 打印的执行版本；
- -cache 删除所有`go build`命令的缓存
- -testcache 删除当前包所有的测试结果


实际开发中`go clean`命令使用的可能不是很多，一般都是利用`go clean`命令清除编译文件，然后再将源码递交到 github 上，方便对于源码的管理。

下面我们以本地的一个项目为例，演示一下`go clean`命令：

```go
go clean -n
cd D:\code
rm -f code code.exe code.test code.test.exe main main.exe
```

在命令中使用`-n`标记可以将命令的执行过程打印出来，但不会正真执行。如果既要打印命令的执行过程同时又执行命令的话可以使用`-x`标记，如下所示：

```go
go clean -x
cd D:\code
rm -f code code.exe code.test code.test.exe main main.exe
```

![go clean 命令执行前后对比](http://c.biancheng.net/uploads/allimg/200116/4-200116102KJ01.gif)
图：go clean 命令运行前后对比

### 3. go run命令——编译并运行

[Python](http://c.biancheng.net/python/) 或者 Lua 语言可以在不输出二进制的情况下，将代码使用虚拟机直接执行。Go语言虽然不使用虚拟机，但可使用`go run`指令达到同样的效果。

`go run`命令会编译源码，并且直接执行源码的 main() 函数，不会在当前目录留下可执行文件。

下面我们准备一个 main.go 的文件来观察`go run`的运行结果，源码如下：

```go
package main
import (   
    "fmt"
    "os"
)
func main() {
    fmt.Println("args:", os.Args)
}
```

这段代码的功能是将输入的参数打印出来。使用`go run`运行这个源码文件，命令如下：

```go
$ go run main.go --filename xxx.go
args: [/tmp/go-build006874658/command-line-arguments/_obj/exe/main--filename xxx.go]
```

`go run`不会在运行目录下生成任何文件，可执行文件被放在临时文件中被执行，工作目录被设置为当前目录。在`go run`的后部可以添加参数，这部分参数会作为代码可以接受的命令行输入提供给程序。

`go run`不能使用“go run+包”的方式进行编译，如需快速编译运行包，需要使用如下步骤来代替：

1. 使用`go build`生成可执行文件。
2. 运行可执行文件。

### 4. go fmt命令——格式化代码文件

对于一门编程语言来说，代码格式化是最容易引起争议的一个问题，不同的开发者可能会有不同的编码风格和习惯，但是如果所有开发者都能使用同一种格式来编写代码，那么开发者就可以将主要精力放在语言要解决的问题上，从而节省开发时间。

#### gofmt 介绍

Go语言的开发团队制定了统一的官方代码风格，并且推出了 gofmt 工具（gofmt 或 go fmt）来帮助开发者格式化他们的代码到统一的风格。

gofmt 是一个 cli 程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有 .go 文件，如果不传参数，会格式化当前目录下的所有 .go 文件。

gofmt 默认不对代码进行简化，使用`-s`参数可以开启简化代码功能，具体来说会进行如下的转换：

##### 1) 去除数组、切片、Map 初始化时不必要的类型声明

如下形式的切片表达式：

```go
[]T{T{}, T{}}
```

简化后的代码为：

```go
[]T{{}, {}}
```

##### 2) 去除数组切片操作时不必要的索引指定

如下形式的切片表达式：

```go
s[a:len(s)]
```

简化后的代码为：

```go
s[a:]
```

##### 3) 去除循环时非必要的变量赋值

如下形式的循环：

```go
for x, _ = range v {...}
```

简化后的代码为：

```go
for x = range v {...}
```

如下形式的循环：

```go
for _ = range v {...}
```

简化后的代码为：

```go
for range v {...}
```

gofmt 命令参数如下表所示：

| 标记名称    | 标记描述                                                     |
| ----------- | ------------------------------------------------------------ |
| -l          | 仅把那些不符合格式化规范的、需要被命令程序改写的源码文件的绝对路径打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 |
| -w          | 把改写后的内容直接写入到文件中，而不是作为结果打印到标准输出。 |
| -r          | 添加形如“a[b:len(a)] -> a[b:]”的重写规则。如果我们需要自定义某些额外的格式化规则，就需要用到它。 |
| -s          | 简化文件中的代码。                                           |
| -d          | 只把改写前后内容的对比信息作为结果打印到标准输出。而不是把改写后的全部内容都打印到标准输出。 命令程序将使用 diff 命令对内容进行比对。在 Windows 操作系统下可能没有 diff 命令，需要另行安装。 |
| -e          | 打印所有的语法错误到标准输出。如果不使用此标记，则只会打印每行的第 1 个错误且只打印前 10 个错误。 |
| -comments   | 是否保留源码文件中的注释。在默认情况下，此标记会被隐式的使用，并且值为 true。 |
| -tabwidth   | 此标记用于设置代码中缩进所使用的空格数量，默认值为 8。要使此标记生效，需要使用“-tabs”标记并把值设置为 false。 |
| -tabs       | 是否使用 tab（'\t'）来代替空格表示缩进。在默认情况下，此标记会被隐式的使用，并且值为 true。 |
| -cpuprofile | 是否开启 CPU 使用情况记录，并将记录内容保存在此标记值所指的文件中。 |


可以看到 gofmt 命令还支持自定义的重写规则，使用`-r`参数，按照 pattern -> replacement 的格式传入规则。

【示例】有如下内容的 Golang 程序，存储在 main.go 文件中。

```go
package main
import "fmt"
func main() {
    a := 1
    b := 2
    c := a + b
    fmt.Println(c)
}
```

用以下规则来格式化上面的代码。

```go
gofmt -w -r "a + b -> b + a" main.go
```

格式化的结果如下。

```go
package main
import "fmt"
func main() {
    a := 1
    b := 2
    c := b + a
    fmt.Println(c)
}
```

注意：gofmt 使用 tab 来表示缩进，并且对行宽度无限制，如果手动对代码进行了换行，gofmt 不会强制把代码格式化回一行。

#### go fmt 和 gofmt

gofmt 是一个独立的 cli 程序，而Go语言中还有一个`go fmt`命令，`go fmt`命令是 gofmt 的简单封装。

```go
go help fmt
usage: go fmt [-n] [-x] [packages]

Fmt runs the command 'gofmt -l -w' on the packages named
by the import paths. It prints the names of the files that are modified.

For more about gofmt, see 'go doc cmd/gofmt'.
For more about specifying packages, see 'go help packages'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

To run gofmt with specific options, run gofmt itself.

See also: go fix, go vet.
```

`go fmt`命令本身只有两个可选参数`-n`和`-x`：

- `-n`仅打印出内部要执行的`go fmt`的命令；
- `-x`命令既打印出`go fmt`命令又执行它，如果需要更细化的配置，需要直接执行 gofmt 命令。


`go fmt`在调用 gofmt 时添加了`-l -w`参数，相当于执行了`gofmt -l -w`。

### 5. go install命令——编译并安装

go install 命令的功能和前面一节《[go build命令](http://c.biancheng.net/view/120.html)》中介绍的 go build 命令类似，附加参数绝大多数都可以与 go build 通用。go install 只是将编译的中间文件放在 GOPATH 的 pkg 目录下，以及固定地将编译结果放在 GOPATH 的 bin 目录下。

这个命令在内部实际上分成了两步操作：第一步是生成结果文件（可执行文件或者 .a 包），第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。

本小节需要用到的代码位置是`./src/chapter11/goinstall`。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

使用 go install 来执行代码，参考下面的 shell：

```go
$ export GOPATH=/home/davy/golangbook/code
$ go install chapter11/goinstall
```

编译完成后的目录结构如下：

```go
.
├── bin
│   └── goinstall
├── pkg
│   └── linux_amd64
│       └── chapter11
│           └── goinstall
│               └── mypkg.a
└── src
    └── chapter11
        ├── gobuild
        │   ├── lib.go
        │   └── main.go
        └── goinstall
            ├── main.go
            └── mypkg
                └── mypkg.go
```

go install 的编译过程有如下规律：

- go install 是建立在 GOPATH 上的，无法在独立的目录里使用 go install。
- GOPATH 下的 bin 目录放置的是使用 go install 生成的可执行文件，可执行文件的名称来自于编译时的包名。
- go install 输出目录始终为 GOPATH 下的 bin 目录，无法使用`-o`附加参数进行自定义。
- GOPATH 下的 pkg 目录放置的是编译期间的中间文件。

### 6.  go get命令——一键获取代码、编译并安装

go get 命令可以借助代码管理工具通过远程拉取或更新代码包及其依赖包，并自动完成编译和安装。整个过程就像安装一个 App 一样简单。

这个命令可以动态获取远程代码包，目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。在使用 go get 命令前，需要安装与远程包匹配的代码管理工具，如 Git、SVN、HG 等，参数中需要提供一个包名。

这个命令在内部实际上分成了两步操作：第一步是下载源码包，第二步是执行 go install。下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下：

```go
BitBucket (Mercurial Git)
GitHub (Git)
Google Code Project Hosting (Git, Mercurial, Subversion)
Launchpad (Bazaar)
```

所以为了 go get 命令能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的 PATH 中。其实 go get 支持自定义域名的功能。

参数介绍：

- -d 只下载不安装
- -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地 fork 的包特别有用
- -fix 在获取源码之后先运行 fix，然后再去做其他的事情
- -t 同时也下载需要为运行测试所需要的包
- -u 强制使用网络去更新包和它的依赖包
- -v 显示执行的命令

#### 远程包的路径格式

Go语言的代码被托管于 Github.com 网站，该网站是基于 Git 代码管理工具的，很多有名的项目都在该网站托管代码。其他类似的托管网站还有 code.google.com、bitbucket.org 等。

这些网站的项目包路径都有一个共同的标准，参见下图所示。



![img](http://c.biancheng.net/uploads/allimg/180820/1-1PR0110433A4.jpg)
图：远程包路径格式


图中的远程包路径是 Go语言的源码，这个路径共由 3 个部分组成：

- 网站域名：表示代码托管的网站，类似于电子邮件 @ 后面的服务器地址。
- 作者或机构：表明这个项目的归属，一般为网站的用户名，如果需要找到这个作者下的所有项目，可以直接在网站上通过搜索“域名/作者”进行查看。这部分类似于电子邮件 @ 前面的部分。
- 项目名：每个网站下的作者或机构可能会同时拥有很多的项目，图中标示的部分表示项目名称。

#### go get+ 远程包

默认情况下，go get 可以直接使用。例如，想获取 go 的源码并编译，使用下面的命令行即可：

```go
$ go get github.com/davyxu/cellnet
```

获取前，请确保 GOPATH 已经设置。Go 1.8 版本之后，GOPATH 默认在用户目录的 go 文件夹下。

cellnet 只是一个网络库，并没有可执行文件，因此在 go get 操作成功后 GOPATH 下的 bin 目录下不会有任何编译好的二进制文件。

需要测试获取并编译二进制的，可以尝试下面的这个命令。当获取完成后，就会自动在 GOPATH 的 bin 目录下生成编译好的二进制文件。

```go
$ go get github.com/davyxu/tabtoy
```

#### go get 使用时的附加参数

使用 go get 时可以配合附加参数显示更多的信息及实现特殊的下载和安装操作，详见下表所示。

| 附加参数  | 备  注                                 |
| --------- | -------------------------------------- |
| -v        | 显示操作流程的日志及信息，方便检查错误 |
| -u        | 下载丢失的包，但不会更新已经存在的包   |
| -d        | 只下载，不安装                         |
| -insecure | 允许使用不安全的 HTTP 方式进行下载操作 |

### 7. go generate命令——在编译前自动化生成某类代码

`go generate`命令是在Go语言 1.4 版本里面新添加的一个命令，当运行该命令时，它将扫描与当前包相关的源代码文件，找出所有包含`//go:generate`的特殊注释，提取并执行该特殊注释后面的命令。

使用`go generate`命令时有以下几点需要注意：

- 该特殊注释必须在 .go 源码文件中；
- 每个源码文件可以包含多个 generate 特殊注释；
- 运行`go generate`命令时，才会执行特殊注释后面的命令；
- 当`go generate`命令执行出错时，将终止程序的运行；
- 特殊注释必须以`//go:generate`开头，双斜线后面没有空格。


在下面这些场景下，我们会使用`go generate`命令：

- yacc：从 .y 文件生成 .go 文件；
- protobufs：从 protocol buffer 定义文件（.proto）生成 .pb.go 文件；
- Unicode：从 UnicodeData.txt 生成 Unicode 表；
- HTML：将 HTML 文件嵌入到 go 源码；
- bindata：将形如 JPEG 这样的文件转成 go 代码中的字节数组。


再比如：

- string 方法：为类似枚举常量这样的类型生成 String() 方法；
- 宏：为既定的泛型包生成特定的实现，比如用于 ints 的 sort.Ints。

`go generate`命令格式如下所示：

```go
go generate [-run regexp] [-n] [-v] [-x] [command] [build flags] [file.go... | packages]
```

参数说明如下：

- -run 正则表达式匹配命令行，仅执行匹配的命令；
- -v 输出被处理的包名和源文件名；
- -n 显示不执行命令；
- -x 显示并执行命令；
- command 可以是在环境变量 PATH 中的任何命令。


执行`go generate`命令时，也可以使用一些环境变量，如下所示:

- $GOARCH 体系架构（arm、amd64 等）；
- $GOOS 当前的 OS 环境（linux、windows 等）；
- $GOFILE 当前处理中的文件名；
- $GOLINE 当前命令在文件中的行号；
- $GOPACKAGE 当前处理文件的包名；
- $DOLLAR 固定的`$`，不清楚具体用途。


【示例 1】假设我们有一个 main.go 文件，内容如下：

```go
package main
import "fmt"
//go:generate go run main.go
//go:generate go version
func main() {
    fmt.Println("http://c.biancheng.net/golang/")
}
```

执行`go generate -x`命令，输出结果如下：

```go
go generate -x
go run main.go
http://c.biancheng.net/golang/
go version
go version go1.13.6 windows/amd64
```

通过运行结果可以看出`//go:generate`之后的命令成功运行了，命令中使用的`-x`参数是为了将执行的具体命令同时打印出来。

下面通过 stringer 工具来演示一下`go generate`命令的使用。

stringer 并不是Go语言自带的工具，需要手动安装。我们可以通过下面的命令来安装 stringer 工具。

```go
go get golang.org/x/tools/cmd/stringer
```

上面的命令需要翻墙。条件不允许的话也可以通过 Github 上的镜像来安装，安装方法如下：

```go
git clone https://github.com/golang/tools/ $GOPATH/src/golang.org/x/tools
go install golang.org/x/tools/cmd/stringer
```

安装好的 stringer 工具位于 GOPATH/bin 目录下，想要正常使用它，需要先将 GOPATH/bin 目录添加到系统的环境变量 PATH 中。

【示例 2】使用 stringer 工具实现 String() 方法：

首先，在项目目录下新建一个 painkiller 文件夹，并在该文件夹中创建 painkiller.go 文件，文件内容如下：

```go
//go:generate stringer -type=Pill
package painkiller
type Pill int
const (
    Placebo Pill = iota
    Aspirin
    Ibuprofen
    Paracetamol
    Acetaminophen = Paracetamol
)
```

然后，在 painkiller.go 文件所在的目录下运行`go generate`命令。

执行成功后没有任何提示信息，但会在当前目录下面生成一个 pill_string.go 文件，文件中实现了我们需要的 String() 方法，文件内容如下：

```go
// Code generated by "stringer -type=Pill"; DO NOT EDIT.
package painkiller
import "strconv"
func _() {
    // An "invalid array index" compiler error signifies that the constant values have changed.
    // Re-run the stringer command to generate them again.
    var x [1]struct{}
    _ = x[Placebo-0]
    _ = x[Aspirin-1]
    _ = x[Ibuprofen-2]
    _ = x[Paracetamol-3]
}
const _Pill_name = "PlaceboAspirinIbuprofenParacetamol"
var _Pill_index = [...]uint8{0, 7, 14, 23, 34}
func (i Pill) String() string {
    if i < 0 || i >= Pill(len(_Pill_index)-1) {
        return "Pill(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]
}
```

### 8. go test命令（Go语言测试命令）完全攻略

Go语言拥有一套单元测试和性能测试系统，仅需要添加很少的代码就可以快速测试一段需求代码。

go test 命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。输出的信息类似下面所示的样子：

```go
ok archive/tar 0.011s
FAIL archive/zip 0.022s
ok compress/gzip 0.033s
..
```

性能测试系统可以给出代码的性能数据，帮助测试者分析性能问题。

##### 提示

单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。对于单元测试中单元的含义，一般要根据实际情况去判定其具体含义，如C语言中单元指一个函数，[Java](http://c.biancheng.net/java/) 里单元指一个类，图形化的软件中可以指一个窗口或一个菜单等。总的来说，单元就是人为规定的最小的被测功能模块。

单元测试是在软件开发过程中要进行的最低级别的测试活动，软件的独立单元将在与程序的其他部分相隔离的情况下进行测试。

#### 单元测试——测试和验证代码的框架

要开始一个单元测试，需要准备一个 go 源码文件，在命名文件时需要让文件必须以`_test`结尾。默认的情况下，`go test`命令不需要任何的参数，它会自动把你源码包下面所有 test 文件测试完毕，当然你也可以带上参数。

这里介绍几个常用的参数：

- -bench regexp 执行相应的 benchmarks，例如 -bench=.；
- -cover 开启测试覆盖率；
- -run regexp 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数；
- -v 显示测试的详细命令。

单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以`Test`为前缀，例如：

```go
func TestXXX( t *testing.T )
```

- 测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。
- 测试用例文件使用`go test`指令来执行，没有也不需要 main() 作为函数入口。所有在以`_test`结尾的源码内以`Test`开头的函数会自动被执行。
- 测试用例可以不传入 *testing.T 参数。


helloworld 的测试代码（具体位置是`./src/chapter11/gotest/helloworld_test.go`）：

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

```go
package code11_3
import "testing"
func TestHelloWorld(t *testing.T) {
    t.Log("hello world")
}
```

代码说明如下：

- 第 5 行，单元测试文件 (*_test.go) 里的测试入口必须以 Test 开始，参数为 *testing.T 的函数。一个单元测试文件可以有多个测试入口。
- 第 6 行，使用 testing 包的 T 结构提供的 Log() 方法打印字符串。

##### 1) 单元测试命令行

单元测试使用 go test 命令启动，例如：

```go
$ go test helloworld_test.go
ok          command-line-arguments        0.003s
$ go test -v helloworld_test.go
=== RUN   TestHelloWorld
--- PASS: TestHelloWorld (0.00s)
        helloworld_test.go:8: hello world
PASS
ok          command-line-arguments        0.004s
```

代码说明如下：

- 第 1 行，在 go test 后跟 helloworld_test.go 文件，表示测试这个文件里的所有测试用例。
- 第 2 行，显示测试结果，ok 表示测试通过，command-line-arguments 是测试用例需要用到的一个包名，0.003s 表示测试花费的时间。
- 第 3 行，显示在附加参数中添加了`-v`，可以让测试时显示详细的流程。
- 第 4 行，表示开始运行名叫 TestHelloWorld 的测试用例。
- 第 5 行，表示已经运行完 TestHelloWorld 的测试用例，PASS 表示测试成功。
- 第 6 行打印字符串 hello world。

##### 2) 运行指定单元测试用例

`go test`指定文件时默认执行文件内的所有测试用例。可以使用`-run`参数选择需要的测试用例单独执行，参考下面的代码。

一个文件包含多个测试用例（具体位置是`./src/chapter11/gotest/select_test.go`）

```go
package code11_3
import "testing"
func TestA(t *testing.T) {
    t.Log("A")
}
func TestAK(t *testing.T) {
    t.Log("AK")
}
func TestB(t *testing.T) {
    t.Log("B")
}
func TestC(t *testing.T) {
    t.Log("C")
}
```

这里指定 TestA 进行测试：

```go
$ go test -v -run TestA select_test.go
=== RUN   TestA
--- PASS: TestA (0.00s)
        select_test.go:6: A
=== RUN   TestAK
--- PASS: TestAK (0.00s)
        select_test.go:10: AK
PASS
ok          command-line-arguments        0.003s
```

TestA 和 TestAK 的测试用例都被执行，原因是`-run`跟随的测试用例的名称支持正则表达式，使用`-run TestA$`即可只执行 TestA 测试用例。

##### 3) 标记单元测试结果

当需要终止当前测试用例时，可以使用 FailNow，参考下面的代码。

测试结果标记（具体位置是`./src/chapter11/gotest/fail_test.go`）

```go
func TestFailNow(t *testing.T) {
    t.FailNow()
}
```

还有一种只标记错误不终止测试的方法，代码如下：

```go
func TestFail(t *testing.T) {
    fmt.Println("before fail")
    t.Fail()
    fmt.Println("after fail")
}
```

测试结果如下：

```go
=== RUN   TestFail
before fail
after fail
--- FAIL: TestFail (0.00s)
FAIL
exit status 1
FAIL        command-line-arguments        0.002s
```

从日志中看出，第 5 行调用 Fail() 后测试结果标记为失败，但是第 7 行依然被程序执行了。

##### 4) 单元测试日志

每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。

| 方  法 | 备  注                           |
| ------ | -------------------------------- |
| Log    | 打印日志，同时结束测试           |
| Logf   | 格式化打印日志，同时结束测试     |
| Error  | 打印错误日志，同时结束测试       |
| Errorf | 格式化打印错误日志，同时结束测试 |
| Fatal  | 打印致命日志，同时结束测试       |
| Fatalf | 格式化打印致命日志，同时结束测试 |


开发者可以根据实际需要选择合适的日志。

#### 基准测试——获得代码内存占用和运行效率的性能数据

基准测试可以测试一段程序的运行性能及耗费 CPU 的程度。Go语言中提供了基准测试框架，使用方法类似于单元测试，使用者无须准备高精度的计时器和各种分析工具，基准测试本身即可以打印出非常标准的测试报告。

##### 1) 基础测试基本使用

下面通过一个例子来了解基准测试的基本使用方法。

基准测试（具体位置是`./src/chapter11/gotest/benchmark_test.go`）

```go
package code11_3
import "testing"
func Benchmark_Add(b *testing.B) {
    var n int
    for i := 0; i < b.N; i++ {
        n++
    }
}
```

这段代码使用基准测试框架测试加法性能。第 7 行中的 b.N 由基准测试框架提供。测试代码需要保证函数可重入性及无状态，也就是说，测试代码不使用全局变量等带有记忆性质的[数据结构](http://c.biancheng.net/data_structure/)。避免多次运行同一段代码时的环境不一致，不能假设 N 值范围。

使用如下命令行开启基准测试：

```go
$ go test -v -bench=. benchmark_test.go
goos: linux
goarch: amd64
Benchmark_Add-4           20000000         0.33 ns/op
PASS
ok          command-line-arguments        0.700s
```

代码说明如下：

- 第 1 行的`-bench=.`表示运行 benchmark_test.go 文件里的所有基准测试，和单元测试中的`-run`类似。
- 第 4 行中显示基准测试名称，2000000000 表示测试的次数，也就是 testing.B 结构中提供给程序使用的 N。“0.33 ns/op”表示每一个操作耗费多少时间（纳秒）。


注意：Windows 下使用 go test 命令行时，`-bench=.`应写为`-bench="."`。

##### 2) 基准测试原理

基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。

##### 3) 自定义测试时间

通过`-benchtime`参数可以自定义测试时间，例如：

```go
$ go test -v -bench=. -benchtime=5s benchmark_test.go
goos: linux
goarch: amd64
Benchmark_Add-4           10000000000                 0.33 ns/op
PASS
ok          command-line-arguments        3.380s
```

##### 4) 测试内存

基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。

```go
func Benchmark_Alloc(b *testing.B) {
    for i := 0; i < b.N; i++ {
        fmt.Sprintf("%d", i)
    }
}
```

在命令行中添加`-benchmem`参数以显示内存分配情况，参见下面的指令：

```go
$ go test -v -bench=Alloc -benchmem benchmark_test.go
goos: linux
goarch: amd64
Benchmark_Alloc-4 20000000 109 ns/op 16 B/op 2 allocs/op
PASS
ok          command-line-arguments        2.311s
```

代码说明如下：

- 第 1 行的代码中`-bench`后添加了 Alloc，指定只测试 Benchmark_Alloc() 函数。
- 第 4 行代码的“16 B/op”表示每一次调用需要分配 16 个字节，“2 allocs/op”表示每一次调用有两次分配。


开发者根据这些信息可以迅速找到可能的分配点，进行优化和调整。

##### 5) 控制计时器

有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。

基准测试中的计时器控制（具体位置是`./src/chapter11/gotest/benchmark_test.go`）：

```go
func Benchmark_Add_TimerControl(b *testing.B) {
    // 重置计时器
    b.ResetTimer()
    // 停止计时器
    b.StopTimer()
    // 开始计时器
    b.StartTimer()
    var n int
    for i := 0; i < b.N; i++ {
        n++
    }
}
```

从 Benchmark() 函数开始，Timer 就开始计数。StopTimer() 可以停止这个计数过程，做一些耗时的操作，通过 StartTimer() 重新开始计时。ResetTimer() 可以重置计数器的数据。

计数器内部不仅包含耗时数据，还包括内存分配的数据。

### 9. go pprof命令（Go语言性能分析命令）完全攻略

Go语言工具链中的 go pprof 可以帮助开发者快速分析及定位各种性能问题，如 CPU 消耗、内存分配及阻塞分析。

性能分析首先需要使用 runtime.pprof 包嵌入到待分析程序的入口和结束处。runtime.pprof 包在运行时对程序进行每秒 100 次的采样，最少采样 1 秒。然后将生成的数据输出，让开发者写入文件或者其他媒介上进行分析。

go pprof 工具链配合 Graphviz 图形化工具可以将 runtime.pprof 包生成的数据转换为 PDF 格式，以图片的方式展示程序的性能分析结果。

#### 安装第三方图形化显式分析数据工具（Graphviz）

Graphviz 是一套通过文本描述的方法生成图形的工具包。描述文本的语言叫做 DOT。

在 [www.graphviz.org](http://www.graphviz.org/) 网站可以获取到最新的 Graphviz 各平台的安装包。

CentOS 下，可以使用 yum 指令直接安装：

```go
$ yum install graphiviz
```

#### 安装第三方性能分析来分析代码包

runtime.pprof 提供基础的运行时分析的驱动，但是这套接口使用起来还不是太方便，例如：

- 输出数据使用 io.Writer 接口，虽然扩展性很强，但是对于实际使用不够方便，不支持写入文件。
- 默认配置项较为复杂。


很多第三方的包在系统包 runtime.pprof 的技术上进行便利性封装，让整个测试过程更为方便。这里使用 github.com/pkg/profile 包进行例子展示，使用下面代码安装这个包：

```go
$ go get github.com/pkg/profile
```

#### 性能分析代码

下面代码故意制造了一个性能问题，同时使用 github.com/pkg/profile 包进行性能分析。

> 本套教程所有源码下载地址：https://pan.baidu.com/s/1ORFVTOLEYYqDhRzeq0zIiQ  提取密码：hfyf

基准测试代码如下（具体文件：./src/chapter11/profile/cpu.go）：

```go
package main
import (
    "github.com/pkg/profile"
    "time"
)
func joinSlice() []string {
    var arr []string
    for i := 0; i < 100000; i++ {
     // 故意造成多次的切片添加(append)操作, 由于每次操作可能会有内存重新分配和移动, 性能较低
        arr = append(arr, "arr")
    }
    return arr
}
func main() {
    // 开始性能分析, 返回一个停止接口
    stopper := profile.Start(profile.CPUProfile, profile.ProfilePath("."))
    // 在main()结束时停止性能分析
    defer stopper.Stop()
    // 分析的核心逻辑
    joinSlice()
    // 让程序至少运行1秒
    time.Sleep(time.Second)
}
```

代码说明如下：

- 第 4 行，引用 github.com/pkg/profile 第三方包封装。
- 第 14 行，为了进行性能分析，这里在已知元素大小的情况下，还是使用 append() 函数不断地添加切片。性能较低，在实际中应该避免，这里为了性能分析，故意这样写。
- 第 22 行，使用 profile.Start 调用 github.com/pkg/profile 包的开启性能分析接口。这个 Start 函数的参数都是可选项，这里需要指定的分析项目是 profile.CPUProfile，也就是 CPU 耗用。profile.ProfilePath(".") 指定输出的分析文件路径，这里指定为当前文件夹。profile.Start() 函数会返回一个 Stop 接口，方便在程序结束时结束性能分析。
- 第 25 行，使用 defer，将性能分析在 main() 函数结束时停止。
- 第 28 行，开始执行分析的核心。
- 第 31 行，为了保证性能分析数据的合理性，分析的最短时间是 1 秒，使用 time.Sleep() 在程序结束前等待 1 秒。如果你的程序默认可以运行 1 秒以上，这个等待可以去掉。


性能分析需要可执行配合才能生成分析结果，因此使用命令行对程序进行编译，代码如下：

```go
$ go build -o cpu cpu.go
$ ./cpu
$ go tool pprof --pdf cpu cpu.pprof > cpu.pdf
```

代码说明如下：

- 第 1 行将 cpu.go 编译为可执行文件 cpu。
- 第 2 行运行可执行文件，在当前目录输出 cpu.pprof 文件。
- 第 3 行，使用 go tool 工具链输入 cpu.pprof 和 cpu 可执行文件，生成 PDF 格式的输出文件，将输出文件重定向为 cpu.pdf 文件。这个过程中会调用 Graphviz 工具，Windows 下需将 Graphviz 的可执行目录添加到环境变量 PATH 中。


最终生成 cpu.pdf 文件，使用 PDF 查看器打开文件，观察后发现下图所示的某个地方可能存在瓶颈。

![img](http://c.biancheng.net/uploads/allimg/180820/1-1PR0130104114.jpg)
图：性能分析


图中的每一个框为一个函数调用的路径，第 3 个方框中 joinSlice 函数耗费了 50% 的 CPU 时间，存在性能瓶颈。重新优化代码，在已知切片元素数量的情况下直接分配内存，代码如下：

```go
func joinSlice() []string {
    const count = 100000
    var arr []string = make([]string, count)
    for i := 0; i < count; i++ {
        arr[i] = "arr"
    }
    return arr
}
```

代码说明如下：

- 第 5 行，将切片预分配 count 个数量，避免之前使用 append() 函数的多次分配。
- 第 8 行，预分配后，直接对每个元素进行直接赋值。



重新运行上面的代码进行性能分析，最终得到的 cpu.pdf 中将不会再有耗时部分。

### 10. 与c/c++进行交互

Go 语言是类 C 的语言，与 C 语言有着千丝万缕的联系，在 Go 语言的代码中可以直接调用 C 语言代码，但不支持直接调用 C++。

Go 调用 C/C++ 的方式：

- C：直接调用 C API；

- C++：通过实现一层封装的 C 接口来调用 C++ 接口。

#### 调用 C 语言

在 Go 语言的源代码中直接声明 C 语言代码是比较简单的应用情况，可以直接使用这种方法将 C 语言代码直接写在 Go 语言代码的注释中，并在注释之后紧跟`import "C"`，通过`C.xx `来引用 C 语言的结构和函数，如下所示：

```go
  package main

  /*
  #include <stdio.h>
  #include <stdlib.h>

  typedef struct {
      int id;
  }ctx;

  ctx *createCtx(int id) {
      ctx *obj = (ctx *)malloc(sizeof(ctx));
      obj->id = id;
      return obj;
  }
  */
  import "C"
  import (
      "fmt"
  )

  func main() {
      var ctx *C.ctx = C.createCtx(100)
      fmt.Printf("id : %d\n", ctx.id)
  }
```

运行结果如下：

```go
go run main.go id : 100
```

#### 通过封装实现 C++ 接口的调用

首先我们新建一个 cpp 目录，并将 C++ 的代码放置在 cpp 目录下，C++ 代码需要提前编译成动态库（拷贝到系统库目录可以防止 go 找不到动态库路径），go 程序运行时会去链接。

```go
├── cpp
│   ├── cwrap.cpp
│   ├── cwrap.h
│   ├── test.cpp
│   └── test.h
└── main.go
```

其中 test.cpp 和 test.h 是 C++ 接口的实现；cwrap.h 和 cwrap.cpp 是封装的 C 接口的实现。

##### 1) test.h

```c++
  #ifndef __TEST_H__
  #define __TEST_H__

  #include <stdio.h>

  class  Test {
  public:
      void call();
  };

  #endif
```

##### 2) test.cpp

```c++
  #include "test.h"

  void Test::call() {
      printf("call from c++ language\n");
  }

  cwrap.cpp

  #include "cwrap.h"
  #include "test.h"

  void call() {
      Test  ctx;
      ctx.call();
  }
```

##### 3) cwrap.h

```c++
  #ifndef __CWRAP_H__
  #define __CWRAP_H__

  #ifdef __cplusplus
  extern "C" {
  #endif
  void call();

  #ifdef __cplusplus
  }
  #endif

  #endif
```

##### 4) main.go

```go
  package main

  /*
  #cgo CFLAGS: -Icpp

  #cgo LDFLAGS: -lgotest

  #include "cwrap.h"
  */
  import "C"

  func main() {
      C.call()
  }
```

### 11. 内存管里

内存管理是非常重要的一个话题。关于编程语言是否应该支持垃圾回收就有个搞笑的争论，一派人认为，内存管理太重要了，而手动管理麻烦且容易出错，所以我们应该交给机器去管理。另一派人则认为，内存管理太重要了！所以如果交给机器管理我不能放心。争论归争论，但不管哪一派，大家对内存管理重要性的认同都是勿庸质疑的。

Go 语言是一门带垃圾回收的语言，Go 语言中有指针，却没有 C 语言中那么灵活的指针操作。大多数情况下是不需要用户自己去管理内存的，但是理解 Go 语言是如何做内存管理对于写出优秀的程序是大有帮助的。

#### 内存池概述

Go 语言的内存分配器采用了跟 tcmalloc 库相同的实现，是一个带内存池的分配器，底层直接调用操作系统的 mmap 等函数。

作为一个内存池，它的基本部分包括以下几部分：

- 首先，它会向操作系统申请大块内存，自己管理这部分内存。

- 然后，它是一个池子，当上层释放内存时它不实际归还给操作系统，而是放回池子重复利用。

- 接着，内存管理中必然会考虑的就是内存碎片问题，如果尽量避免内存碎片，提高内存利用率，像操作系统中的首次适应，最佳适应，最差适应，伙伴算法都是一些相关的背景知识。

- 另外，Go 语言是一个支持 goroutine 这种多线程的语言，所以它的内存管理系统必须也要考虑在多线程下的稳定性和效率问题。

在多线程方面，很自然的做法就是每条线程都有自己的本地的内存，然后有一个全局的分配链，当某个线程中内存不足后就向全局分配链中申请内存。这样就避免了多线程同时访问共享变量时的加锁。

在避免内存碎片方面，大块内存直接按页为单位分配，小块内存会切成各种不同的固定大小的块，申请做任意字节内存时会向上取整到最接近的块，将整块分配给申请者以避免随意切割。

Go 语言中为每个系统线程分配一个本地的 MCache（前面介绍的结构体 M 中的 MCache 域），少量的地址分配就直接从 MCache 中分配，并且定期做垃圾回收，将线程的 MCache 中的空闲内存返回给全局控制堆。小于 32K 为小对象，大对象直接从全局控制堆上以页（4k）为单位进行分配，也就是说大对象总是以页对齐的。一个页可以存入一些相同大小的小对象，小对象从本地内存链表中分配，大对象从中心内存堆中分配。

大约有 100 种内存块类别，每一个类别都有自己对象的空闲链表。小于 32kB 的内存分配被向上取整到对应的尺寸类别，从相应的空闲链表中分配。一页内存只可以被分裂成同一种尺寸类别的对象，然后由空闲链表分配器管理。

分配器的数据结构包括:

- FixAlloc：固定大小（128kB）的对象的空闲链分配器，被分配器用于管理存储；

- MHeap：分配堆，按页的粒度进行管理（4kB）；

- MSpan：一些由 MHeap 管理的页；

- MCentral：对于给定尺寸类别的共享的 free list；

- MCache：用于小对象的每 M 一个的 cache。

我们可以将 Go 语言的内存管理看成一个两级的内存管理结构 MHeap 和 MCache。上面一级管理的基本单位是页，用于分配大对象，每次分配都是若干连续的页，也就是若干个 4KB 的大小。使用的数据结构是 MHeap 和 MSpan，用 BestFit 算法做分配，用位示图做回收。下面一级管理的基本单位是不同类型的固定大小的对象，更像一个对象池而不是内存池，用引用计数做回收。下面这一级使用的数据结构是 MCache。

#### MHeap

Go 语言的程序在启动之初，会一次性从操作系统那里申请一大块内存作为内存池。这块内存空间会放在一个叫 Mheap 的 struct 中管理，Mheap 负责将这一整块内存切割成不同的区域，并将其中一部分的内存切割成合适的大小，分配给用户使用。

MHeap 层次用于直接分配较大（>32kB）的内存空间，以及给 MCentral 和 MCache 等下层提供空间。它管理的基本单位是 MSpan。MSpan 是一个表示若干连续内存页的数据结构，简化后如下：

```go
  struct MSpan
  {
      PageID     start;          // starting page number
      uintptr     npages;        // number of pages in span
  };
```

通过一个基地址 +(页号*页大小)，就可以定位到这个 MSpan 的实际的地址空间了，基地址是在 MHeap 中存储了的，MHeap 负责将 MSpan 组织和管理起来。

free 是一个分配池，从 free[i] 出去的 MSpan 每个大小都是 i 页的，总共 256 个槽位。再大了之后，大小就不固定了，由 large 链起来。

Go 语言在这里使用的类似于位示图，可以看到 MHeap 中有一个。

MSpan *map[1<<MHeapMap_Bits];

这个数组是一个用于将内存地址映射成 MSpan 结构体的表，每个内存页都会对应到 map 中的一个 MSpan 指针，通过 map 就能够将地址映射到相应的 MSpan。

具体做法是，给定一个地址，通过 (地址 - 基地址) / 页大小得到页号，再通过 map[页号] 就得到了相应的 MSpan 结构体。

前面说过 MSpan 就是若干连续的页。那么，一个多页的 MSpan 会占用 map 数组中的多项，有多少页就会占用多少项。比如，map[502] 到 map[505] 可能都指向同一个 MSpan，这个 MSpan 的 PageId 为 502，npages 为 4。

回收一个 MSpan 时，首先会查找它相邻的页的址址，再通过 map 映射得到该页对应的 MSpan，如果 MSpan 的 state 是未使用，则可以将两者进行合并。最后会将这页或者合并后的页归还到 free[] 分配池或者是 large 中。

#### MCache

MCache 层次跟 MHeap 层次非常像，也是一个分配池，对每个尺寸的类别都有一个空闲对象的单链表。Go 的内存管理可以看成一个两级的层次，上面一级是 MHeap 层次，而 MCache 则是下面一级。

每个 M 都有一个自己的局部内存缓存 MCache，这样分配小对象的时候直接从 MCache 中分配，就不用加锁了，这是 Go 语言能够在多线程环境中高效地进行内存分配的重要原因。MCache 就是用于小对象的分配。

分配一个小对象（<32kB）的过程：

- 将小对象大小向上取整到一个对应的尺寸类别，查找相应的 MCache 的空闲链表。如果链表不空，直接从上面分配一个对象。这个过程可以不必加锁。

- 如果 MCache 自由链是空的，通过从 MCentral 自由链拿一些对象进行补充。

- 如果 MCentral 自由链是空的，则通过 MHeap 中拿一些页对 MCentral 进行补充，然后将这些内存截断成规定的大小。

- 如果 MHeap 是空的，或者没有足够大小的页了，从操作系统分配一组新的页（至少 1MB）。分配一大批的页分摊了从操作系统分配的开销。

注意上面表述中的用词 “一些”。从 MCentral 中拿 “一些 “自由链对象补充 MCache 分摊了访问 MCentral 加锁的开销。从 MHeap 中分配 “一些 “的页补充 MCentral 分摊了对 MHeap 加锁的开销。

释放一个小对象也是类似的过程：

- 查找对象所属的尺寸类别，将它添加到 MCache 的自由链。

- 如果 MCache 自由链太长或者 MCache 内存大多了，则返还一些到 MCentral 自由链。

- 如果在某个范围的所有的对象都归还到 MCentral 链了，则将它们归还到页堆。

归还到 MHeap 就结束了，目前还是没有归还到操作系统。

MCache 层次仅用于分配小对象，分配和释放大的对象则是直接使用 MHeap 的，跳过 MCache 和 MCentral 自由链。MCache 和 MCentral 中自由链的小对象可能是也可能不是清 0 了的。对象的第 2 个字节作为标记，当它是 0 时，此对象是清 0 了的。页堆中的总是清零的，当一定范围的对象归还到页堆时，需要先清零。这样才符合 Go 语言规范：分配一个对象不进行初始化，它的默认值是该类型的零值。

#### MCentral

MCentral 层次是作为 MCache 和 MHeap 的连接。对上，它从 MHeap 中申请 MSpan；对下，它将 MSpan 划分成各种小尺寸对象，提供给 MCache 使用。

```go
  struct  MCentral
  {
      Lock;
      int32  sizeclass;
      MSpan  nonempty;
      MSpan  empty;
      int32  nfree;
  };
```

注意，每个 MSpan 只会分割成同种大小的对象。每个 MCentral 也是只含同种大小的对象。MCentral 结构中，有一个 nonempty 的 MSpan 链和一个 empty 的 MSpan 链，分别表示还有空间的 MSpan 和装满了对象的 MSpan。

分配还是很简单，直接从 MCentral->nonempty->freelist 分配。如果发现 freelist 空了，则说明这一块 MSpan 满了，将它移到 MCentral->empty。

前面说过，回收比分配复杂，因为涉及到合并。这里的合并是通过引用计数实现的。从 MSpan 中每划出一个对象，则引用计数加一，每回收一个对象，则引用计数减一。如果减完之后引用计数为零了，则说明这整块的 MSpan 已经没被使用了，可以将它归还给 MHeap。

### 12. 垃圾回收

Go 语言中使用的垃圾回收使用的是标记清扫算法。进行垃圾回收时会 stoptheworld。不过在 Go 语言 1.3 版本中，实现了精确的垃圾回收和并行的垃圾回收，大大地提高了垃圾回收的速度，进行垃圾回收时系统并不会长时间卡住。

#### 标记清扫算法

标记清扫算法是一个很基础的垃圾回收算法，该算法中有一个标记初始的 root 区域，以及一个受控堆区。root 区域主要是程序运行到当前时刻的栈和全局数据区域。在受控堆区中，很多数据是程序以后不需要用到的，这类数据就可以被当作垃圾回收了。

判断一个对象是否为垃圾，就是看从 root 区域的对象是否有直接或间接的引用到这个对象。如果没有任何对象引用到它，则说明它没有被使用，因此可以安全地当作垃圾回收掉。

标记清扫算法分为两阶段，分别是标记阶段和清扫阶段。

- 标记阶段，从 root 区域出发，扫描所有 root 区域的对象直接或间接引用到的对象，将这些对上全部加上标记；

- 清扫阶段，扫描整个堆区，对所有无标记的对象进行回收。

#### 位图标记和内存布局

既然垃圾回收算法要求给对象加上垃圾回收的标记，显然是需要有标记位的。一般的做法会将对象结构体中加上一个标记域，一些优化的做法会利用对象指针的低位进行标记，这都只是些奇技淫巧罢了。Go 没有这么做，它的对象和 C 的结构体对象完全一致，使用的是非侵入式的标记位，我们看看它是怎么实现的。

堆区域对应了一个标记位图区域，堆中每个字（不是 byte，而是 word）都会在标记位区域中有对应的标记位。每个机器字（32 位或 64 位）会对应 4 位的标记位。因此 64 位系统中相当于每个标记位图的字节对应 16 个堆中的字节。

虽然是一个堆字节对应 4 位标记位，但标记位图区域的内存布局并不是按 4 位一组，而是 16 个堆字节为一组，将它们的标记位信息打包存储的。每组 64 位的标记位图从上到下依次包括：

- 16 位的特殊位、标记位；

- 16 位的垃圾回收标记位；

- 16 位的无指针 / 块边界的标记位；

- 16 位的已分配标记位。

这样设计使得对一个类型的相应的位进行遍历很容易。

前面提到堆区域和堆地址的标记位图区域是分开存储的，其实它们是以 mheap.arena_start 地址为边界，向上是实际使用的堆地址空间，向下则是标记位图区域。以 64 位系统为例，计算堆中某个地址的标记位的公式如下：

```shell
偏移 = 地址 - mheap.arena_start
标记位地址 = mheap.arena_start - 偏移 / 16 - 1
移位 = 偏移 % 16
标记位 = *标记位地址 >> 移位
```

然后就可以通过（标记位 & 垃圾回收标记位）、（标记位 & 分配位）等来测试相应的位。其中已分配的标记为 1<<0，无指针 / 块边界是 1<<16，垃圾回收的标记位为 1<<32，特殊位 1<<48。

#### 精确的垃圾回收

像 C 语言这种不支持垃圾回收的语言，其实还是有些垃圾回收的库可以使用的。这类库一般也是用的标记清扫算法实现的，但是它们都是保守的垃圾回收。之所以叫 “保守” 是因为它们没办法获取对象类型信息，因此只能保守地假设地址区间中每个字都是指针。

无法获取对象的类型信息会造成什么问题呢？这里举两个例子来说明。

先看第一个例子，假设某个结构体中是不包含指针成员的，那么对该结构体成员进行垃圾回收时，其实是不必要递归地标记结构体的成员的。但是由于没有类型信息，我们并不知道这个结构体成员不包含指针，因此我们只能对结构体的每个字节递归地标记下去，这显然会浪费很多时间。这个例子说明精确的垃圾回收可以减少不必要的扫描，提高标记过程的速度。

再看另一个例子，假设堆中有一个 long 的变量，它的值是 8860225560。但是我们不知道它的类型是 long，所以在进行垃圾回收时会把它当作指针处理，这个指针引用到了 0x2101c5018 位置。假设 0x2101c5018 碰巧有某个对象，那么这个对象就无法被释放了，即使实际上已经没任何地方使用它。

这个例子说明，保守的垃圾回收某些情况下会出现垃圾无法被回收的情况。虽然不会造成大的问题，但总是让人很不爽，都是没有类型信息惹的祸。

现在好了，在 Go 语言的 1.1 版本中开始支持精确的垃圾回收。精确的垃圾回收首先需要的就是类型信息，上一节中讲过 MSpan 结构体，类型信息是存储在 MSpan 中的。从一个地址计算它所属的 MSpan，公式如下：

```shell
页号 =  (地址 -  mheap.arena_start)  >>  页大小
MSpan  =  mheap->map[页号]
```

接下来通过 MSpan->type 可以得到分配块的类型。这是一个 MType 的结构体：

```go
  struct  MTypes
  {
      byte         compression;     //  one  of  MTypes_*
      bool         sysalloc;       //  whether  (void*)data  is  from  runtime·SysAlloc uintptr data;
  };
```

MTypes 描述 MSpan 里分配的块的类型，其中 compression 域描述数据的布局。它的取值为 MTypes_Empty、MTypes_Single、MTypes_Words、MTypes_Bytes 四个中的一种：

- MTypes_Empty：所有的块都是 free 的，或者这个分配块的类型信息不可用。这种情况下 data 域是无意义的。

- MTypes_Single：这个 MSpan 只包含一个块，data 域存放类型信息，sysalloc 域无意义。

- MTypes_Words：这个 MSpan 包含多个块（块的种类多于 7）。这时 data 指向一个数组 [NumBlocks]uintptr，数组里每个元索存放相应块的类型信息。

- MTypes_Bytes：这个 MSpan 中包含最多 7 种不同类型的块。这时 data 域指下面这个结构体

```c++
struct  {
    type    [8]uintptr               //  type[0]  is  always  0
    index   [NumBlocks]byte
}
```

第 i 个块的类型是 data.type[data.index[i]]

表面上看 MTypes_Bytes 好像最复杂，其实这里的复杂程度是 MTypes_Empty 小于 MTypes_Single 小于 MTypes_Bytes 小于 MTypes_Words 的。MTypes_Bytes 只不过为了做优化而显得很复杂。

上一节中说过，每一块 MSpan 中存放的块的大小都是一样的，不过它们的类型不一定相同。如果没有使用，那么这个 MSpan 的类型就是 MTypes_Empty。如果存一个很大块，大于这个 MSpan 大小的一半，因此存不了其它东西了，那么这个 MSpan 的类型是 MTypes_Single。

假设存了多种块，每一块用一个指针，本来可以直接用 MTypes_Words 存的。但是当类型不多时，可以把这些类型的指针集中起来放在数组中，然后存储数组索引。这是一个小的优化，可以节省内存空间。

得到的类型信息最终是什么样子的呢？其实是一个这样的结构体：

```go
  struct  Type
  {
      uintptr  size;
      uint32  hash;
      uint8  _unused;
      uint8  align;
      uint8  fieldAlign;
      uint8  kind;
      Alg  *alg;
      void  *gc;
      String  *string;
      UncommonType  *x;
      Type  *ptrto;
  };
```

不同类型的类型信息结构体略有不同，这个是通用的部分。可以看到这个结构体中有一个 gc 域，精确的垃圾回收就是利用类型信息中这个 gc 域实现的。

从 gc 出去其实是一段指令码，是对这种类型的数据进行垃圾回收的指令，Go 语言中用一个状态机来执行垃圾回收指令码。大致的框架是类似下面这样子：

```c++
  for(;;)  {
      switch(pc[0])  {
          case  GC_PTR:
          break;
          case  GC_SLICE:
          break;
          case  GC_APTR:
          break;
          case  GC_STRING:
          continue;
          case  GC_EFACE:
          if(eface->type  ==  nil)
              continue;
          break;
          case  GC_IFACE:
          break;
          case  GC_DEFAULT_PTR:
          while(stack_top.b  <=  end_b){
              obj = *(byte**)stack_top.b;
              stack_top.b += PtrSize;
              if(obj >=  arena_start && obj < arena_used) {
                  *ptrbufpos++  =  (PtrTarget){obj,  0};
                  if(ptrbufpos  ==  ptrbuf_end)
                      flushptrbuf(ptrbuf,  &ptrbufpos,  &wp,  &wbuf,  &nobj);
              }
          }
          case GC_ARRAY_START:
          continue;
          case GC_ARRAY_NEXT:
          continue;
          case GC_CALL:
          continue;
          case GC_MAP_PTR:
          continue;
          case GC_MAP_NEXT:
          continue;
          case GC_REGION:
          continue;
          case GC_CHAN_PTR:
          continue;
          case GC_CHAN:
          continue;
          default:
          runtime·throw("scanblock:  invalid  GC  instruction");
          return;
      }
  }
```

Go 语言使用标记清扫的垃圾回收算法，标记位图是非侵入式的，内存布局设计得比较巧妙。并且当前版本的 Go 语言实现了精确的垃圾回收。在精确的垃圾回收中，通过定位对象的类型信息，得到该类型中的垃圾回收的指令码，通过一个状态机解释这段指令码来执行特定类型的垃圾回收工作。

对于堆中任意地址的对象，找到它的类型信息过程为，先通过它在的内存页找到它所属的 MSpan，然后通过 MSpan 中的类型信息找到它的类型信息。

目前 Go 语言中垃圾回收的核心函数是 scanblock，源代码在文件 runtime/mgc0.c 中。这个函数非常难读，单个函数写了足足 500 多行。

上面有两个大的循环，外层循环作用是扫描整个内存块区域，将类型信息提取出来，得到其中的 gc 域。内层的大循环是实现一个状态机，解析执行类型信息中 gc 域的指令码。

MType 中的数据其实是类型信息，但它是用 uintptr 表示，而不是 Type 结构体的指针，这是一个优化的小技巧。由于内存分配是机器字节对齐的，所以地址就只用到了高位，低位是用不到的。

于是低位可以利用起来存储一些额外的信息。这里的 uintptr 中高位存放的是 Type 结构体的指针，低位用来存放类型。通过下面的代码：

```c++
t  =  (Type*)(type  &  ~(uintptr)(PtrSize-1));
```

就可以从 uintptr 得到 Type 结构体指针，而通过下面的代码：

```c++
type & (PtrSize-1)
```

就可以得到类型。这里的类型有 TypeInfo_SingleObject、TypeInfo_Array、TypeInfo_Map、TypeInfo_Chan 几种。

#### 基本的标记过程

从最简单的开始看，基本的标记过程，有一个不带任何优化的标记的实现，对应于函数 debug_scanblock。

debug_scanblock 函数是递归实现的，单线程的，更简单更慢的 scanblock 版本。该函数接收的参数分别是一个指针表示要扫描的地址，以及字节数。

首先要将传入的地址，按机器字节大小对齐。然后对待扫描区域的每个地址：

- 找到它所属的 MSpan，将地址转换为 MSpan 里的对象地址。

- 根据对象的地址，找到对应的标记位图里的标记位。

- 判断标记位，如果是未分配则跳过。否则加上特殊位标记（debug_scanblock 中用特殊位代码的 mark 位）完成标记。

- 判断标记位中标记了无指针标记位，如果没有，则要递归地调用 debug_scanblock。

这个递归版本的标记算法还是很容易理解的。其中涉及的细节在上节中已经说过了，比如任意给定一个地址，找到它的标记位信息。很明显这里仅仅使用了一个无指针位，并没有精确的垃圾回收。

#### 并行的垃圾回收

Go 语言在这个版本中不仅实现了精确的垃圾回收，而且实现了并行的垃圾回收。标记算法本质上就是一个树的遍历过程，上面实现的是一个递归版本。

并行的垃圾回收需要做的第一步，就是先将算法做成非递归的。非递归版本的树的遍历需要用到一个队列。树的非递归遍历的伪代码大致是：

根结点进队

```go
while(队列不空){
    出队
    访问
    将子结点进队
}
```

第二步是使上面的代码能够并行地工作，显然这时是需要一个线程安全的队列的。假设有这样一个队列，那么上面代码就能够工作了。但是，如果不加任何优化，这里的队列的并行访问非常地频繁，对这个队列加锁代价会非常高，即使是使用 CAS 操作也会大大降低效率。

所以，第三步要做的就是优化上面队列的数据结构。事实上，Go 中并没有使用这样一个队列，为了优化，它通过三个数据结构共同来完成这个队列的功能，这三个数据结构分别是 PtrTarget 数组，Workbuf，lfstack。

先说 Workbuf 吧。听名字就知道，这个结构体的意思是工作缓冲区，里面存放的是一个数组，数组中的每个元素都是一个待处理的结点，也就是一个 Obj 指针。这个对象本身是已经标记了的，这个对象直接或间接引用到的对象，都是应该被标记的，它们不会被当作垃圾回收掉。Workbuf 是比较大的，一般是 N 个内存页的大小 (目前是 2 页，也就是 8K)。

PtrTarget 数组也是一个缓冲区，相当于一个 intermediate buffer，跟 Workbuf 有一点点的区别。

- 第一，它比 Workbuf 小很多，大概只有 32 或 64 个元素的数组。

- 第二，Workbuf 中的对象全部是已经标记过的，而 PtrTarget 中的元素可能是标记的，也可能是没标记的。

- 第三，PtrTarget 里面的元素是指针而不是对象，指针是指向任意地址的，而对象是对齐到正确地址的。从一个指针变为一个对象要经过一次变换，上一节中有讲过具体细节。

垃圾回收过程中，会有一个从 PtrTarget 数组冲刷到 Workbuf 缓冲区的过程。对应于源代码中的 flushptrbuf 函数，这个函数作用就是对 PtrTaget 数组中的所有元素，如果该地址是 mark 了的，则将它移到 Workbuf 中。

标记过程形成了一个环，在环的一边，对 Workbuf 中的对象，会将它们可能引用的区域全部放到 PtrTarget 中记录下来。在环的另一边，又会将 PtrTarget 中确定需要标记的地址刷到 Workbuf 中。这个过程一轮一轮地进行，推动非递归版本的树的遍历过程，也就是前面伪代码中的出队，访问，子结点进队的过程。

另一个数据结构是 lfstack，这个名字的意思是 lock free 栈。其实它是被用作了一个无锁的链表，链表结点是以 Workbuf 为单位的。并行垃圾回收中，多条线程会从这个链表中取数据，每次以一个 Workbuf 为工作单位。

同时，标记的过程中也会产生 Workbuf 结点放到链中。lfstack 保证了对这个链的并发访问的安全性。由于现在链表结点是以 Workbuf 为单位的，所以保证整体的性能，lfstack 的底层代码是用 CAS 操作实现的。

经过第三步中数据结构上的拆解，整个并行垃圾回收的架构已经呼之欲出了，这就是标记扫描的核心函数 scanblock。这个函数是在多线程下并行安全的。

那么，最后一步，多线程并行。整个的 gc 是以 runtime.gc 函数为入口的，它实际调用的是 gc。进入 gc 函数后会先 stoptheworld，接着添加标记的 root 区域。然后会设置 markroot 和 sweepspan 的并行任务。运行 mark 的任务，扫描块，运行 sweep 的任务，最后 starttheworld 并切换出去。

有一个 ParFor 的数据结构。在 gc 函数中调用了

```c++
runtime·parforsetup(work.markfor,  work.nproc,  work.nroot,  nil,  false,  markroot);
runtime·parforsetup(work.sweepfor,  work.nproc,  runtime·mheap->nspan,  nil,  true,  sweepspan);
```

是设置好回调函数让线程去执行 markroot 和 sweepspan 函数。垃圾回收时会 stoptheworld，其它 goroutine 会对发起 stoptheworld 做出响应，调用 runtime.gchelper，这个函数会调用 scanblock 帮助标记过程。也会并行地做 markroot 和 sweepspan 的过程。

```go
  void
  runtime·gchelper(void)
  {
      gchelperstart();
      //  parallel  mark  for  over  gc  roots runtime·parfordo(work.markfor);

      //  help  other  threads  scan  secondary  blocks scanblock(nil,  nil,  0,  true);
      if(DebugMark)  {
      //  wait  while  the  main  thread  executes  mark(debug_scanblock)
          while(runtime·atomicload(&work.debugmarkdone)  ==  0)
              runtime·usleep(10);
      }
      runtime·parfordo(work.sweepfor);
      bufferList[m->helpgc].busy  =  0;
      if(runtime·xadd(&work.ndone,  +1)  ==  work.nproc-1)
          runtime·notewakeup(&work.alldone);
  }
```

其中并行时也有实现工作流窃取的概念，多个 worker 同时去工作缓存中取数据出来处理，如果自己的任务做完了，就会从其它的任务中 “偷” 一些过来执行。

#### 垃圾回收的时机

垃圾回收的触发是由一个 gcpercent 的变量控制的，当新分配的内存占已在使用中的内存的比例超过 gcprecent 时就会触发。

比如 gcpercent=100，当前使用了 4M 的内存，那么当内存分配到达 8M 时就会再次 gc。如果回收完毕后，内存的使用量为 5M，那么下次回收的时机则是内存分配达到 10M 的时候。也就是说，并不是内存分配越多，垃圾回收频率越高，这个算法使得垃圾回收的频率比较稳定，适合应用的场景。

gcpercent 的值是通过环境变量 GOGC 获取的，如果不设置这个环境变量，默认值是 100。如果将它设置成 off，则是关闭垃圾回收。

### 13. 实现RAS和AES加解密

密码学里目前有两大经典算法，一个是对称加解密，其中具有代表性的是 AES 加解密；另一个是非对称加解密，其中具有代表性的是 RSA 加解密。这里就以这两个经典算法为例，简单介绍一下其在 Go 语言中的实现。

#### AES 加解密

AES 加密又分为 ECB、CBC、CFB、OFB 等几种，这里只列两种吧。

##### 1) CBC 加解密

```go
  package main

  import (
      "bytes"
      "crypto/aes"
      "crypto/cipher"
      "encoding/base64"
      "fmt"
  )

  func main() {
      orig := "http://c.biancheng.net/golang/"
      key := "123456781234567812345678"
      fmt.Println("原文：", orig)
      encryptCode := AesEncrypt(orig, key)
      fmt.Println("密文：", encryptCode)
      decryptCode := AesDecrypt(encryptCode, key)
      fmt.Println("解密结果：", decryptCode)
  }
  func AesEncrypt(orig string, key string) string {
      // 转成字节数组
      origData := []byte(orig)
      k := []byte(key)
      // 分组秘钥
      block, _ := aes.NewCipher(k)
      // 获取秘钥块的长度
      blockSize := block.BlockSize()
      // 补全码
      origData = PKCS7Padding(origData, blockSize)
      // 加密模式
      blockMode := cipher.NewCBCEncrypter(block, k[:blockSize])
      // 创建数组
      cryted := make([]byte, len(origData))
      // 加密
      blockMode.CryptBlocks(cryted, origData)
      return base64.StdEncoding.EncodeToString(cryted)
  }
  func AesDecrypt(cryted string, key string) string {
      // 转成字节数组
      crytedByte, _ := base64.StdEncoding.DecodeString(cryted)
      k := []byte(key)
      // 分组秘钥
      block, _ := aes.NewCipher(k)
      // 获取秘钥块的长度
      blockSize := block.BlockSize()
      // 加密模式
      blockMode := cipher.NewCBCDecrypter(block, k[:blockSize])
      // 创建数组
      orig := make([]byte, len(crytedByte))
      // 解密
      blockMode.CryptBlocks(orig, crytedByte)
      // 去补全码
      orig = PKCS7UnPadding(orig)
      return string(orig)
  }

  //补码
  func PKCS7Padding(ciphertext []byte, blocksize int) []byte {
      padding := blocksize - len(ciphertext)%blocksize
      padtext := bytes.Repeat([]byte{byte(padding)}, padding)
      return append(ciphertext, padtext...)
  }

  //去码
  func PKCS7UnPadding(origData []byte) []byte {
      length := len(origData)
      unpadding := int(origData[length-1])
      return origData[:(length - unpadding)]
  }
```

其运行结果如下：

go run main.go 原文： http://c.biancheng.net/golang/ 密文： m6bjY+Z9O8LPwT8nYPZ9/41JG7+k5PXxtENxYwnrii0= 解密结果： http://c.biancheng.net/golang/

##### 2) CFB 加解密

代码如下：

```go
  package main

  import (
      "crypto/aes"
      "crypto/cipher"
      "fmt"
      "os"
  )

  var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}

  func main() {
      //需要去加密的字符串
      plaintext := []byte("http://c.biancheng.net/golang/")
      //如果传入加密串的话，plaint就是传入的字符串
      if len(os.Args) > 1 {
          plaintext = []byte(os.Args[1])
      }
      //aes的加密字符串
      key_text := "astaxie12798akljzmknm.ahkjkljl;k"
      if len(os.Args) > 2 {
          key_text = os.Args[2]
      }
      // 创建加密算法aes
      c, err := aes.NewCipher([]byte(key_text))
      if err != nil {
          fmt.Printf("Error: NewCipher(%d bytes) = %s", len(key_text), err)
          os.Exit(-1)
      }
      //加密字符串
      cfb := cipher.NewCFBEncrypter(c, commonIV)
      ciphertext := make([]byte, len(plaintext))
      cfb.XORKeyStream(ciphertext, plaintext)
      fmt.Printf("%s=>%x\n", plaintext, ciphertext)
      // 解密字符串
      cfbdec := cipher.NewCFBDecrypter(c, commonIV)
      plaintextCopy := make([]byte, len(plaintext))
      cfbdec.XORKeyStream(plaintextCopy, ciphertext)
      fmt.Printf("%x=>%s\n", ciphertext, plaintextCopy)
  }
```

其运行结果如下：

go run main.go[http://c.biancheng.net/golang/=>757fbec27b304698750a3542896e8bc5b5d49ac7dba6c589a2ec35778bca](https://www.notion.so/8bc5b5d49ac7dba6c589a2ec35778bca) 757fbec27b304698750a3542896e8bc5b5d49ac7dba6c589a2ec35778bca=>http://c.biancheng.net/golang/

上面的代码如果细看和分解成加解密函数，发现是有问题的，这里再列个官方的示例：

```go
  package main

  import (
      "crypto/aes"
      "crypto/cipher"
      "crypto/rand"
      "encoding/hex"
      "fmt"
      "io"
  )

  func ExampleNewCFBDecrypter() {
      key, _ := hex.DecodeString("6368616e676520746869732070617373")
      ciphertext, _ := hex.DecodeString("939e08921a34ebc7d921c641edb55916c24cc2fa6f14e91b66c22a70c38d23e588c2aed3548cad5ab4baa63a214a")
      block, err := aes.NewCipher(key)
      if err != nil {
          panic(err)
      }
      if len(ciphertext) < aes.BlockSize {
          panic("ciphertext too short")
      }
      iv := ciphertext[:aes.BlockSize]
      ciphertext = ciphertext[aes.BlockSize:]
      stream := cipher.NewCFBDecrypter(block, iv)
      stream.XORKeyStream(ciphertext, ciphertext)
      fmt.Printf("%s\n", ciphertext)
  }
  func ExampleNewCFBEncrypter() {
      key, _ := hex.DecodeString("6368616e676520746869732070617373")
      plaintext := []byte("http://c.biancheng.net/golang/")
      block, err := aes.NewCipher(key)
      if err != nil {
          panic(err)
      }
      ciphertext := make([]byte, aes.BlockSize+len(plaintext))
      iv := ciphertext[:aes.BlockSize]
      if _, err := io.ReadFull(rand.Reader, iv); err != nil {
          panic(err)
      }
      stream := cipher.NewCFBEncrypter(block, iv)
      stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext)
      fmt.Printf("%x\n", ciphertext)
  }
  func main() {
      ExampleNewCFBDecrypter()
      ExampleNewCFBEncrypter()
  }
```

运行结果如下：

go run main.gohttp://c.biancheng.net/golang/ 8bd6cefc2b436124221ae07de571d30a9071c89427340e0364b8645557dc69e5085896f121c34be0e17728263602

#### RSA 加解密

AES 一般用于加解密文，而 RSA 算法一算用来加解密密码。这里列举一个代码示例，如下：

```go
  package main

  import (
      "crypto/rand"
      "crypto/rsa"
      "crypto/x509"
      "encoding/base64"
      "encoding/pem"
      "errors"
      "fmt"
  )

  // 可通过openssl产生
  //openssl genrsa -out rsa_private_key.pem 1024
  var privateKey = []byte(`
  \-----BEGIN RSA PRIVATE KEY-----
  MIICXQIBAAKBgQDfw1/P15GQzGGYvNwVmXIGGxea8Pb2wJcF7ZW7tmFdLSjOItn9
  kvUsbQgS5yxx+f2sAv1ocxbPTsFdRc6yUTJdeQolDOkEzNP0B8XKm+Lxy4giwwR5
  LJQTANkqe4w/d9u129bRhTu/SUzSUIr65zZ/s6TUGQD6QzKY1Y8xS+FoQQIDAQAB
  AoGAbSNg7wHomORm0dWDzvEpwTqjl8nh2tZyksyf1I+PC6BEH8613k04UfPYFUg1
  0F2rUaOfr7s6q+BwxaqPtz+NPUotMjeVrEmmYM4rrYkrnd0lRiAxmkQUBlLrCBiF
  u+bluDkHXF7+TUfJm4AZAvbtR2wO5DUAOZ244FfJueYyZHECQQD+V5/WrgKkBlYy
  XhioQBXff7TLCrmMlUziJcQ295kIn8n1GaKzunJkhreoMbiRe0hpIIgPYb9E57tT
  /mP/MoYtAkEA4Ti6XiOXgxzV5gcB+fhJyb8PJCVkgP2wg0OQp2DKPp+5xsmRuUXv
  720oExv92jv6X65x631VGjDmfJNb99wq5QJBAMSHUKrBqqizfMdOjh7z5fLc6wY5
  M0a91rqoFAWlLErNrXAGbwIRf3LN5fvA76z6ZelViczY6sKDjOxKFVqL38ECQG0S
  pxdOT2M9BM45GJjxyPJ+qBuOTGU391Mq1pRpCKlZe4QtPHioyTGAAMd4Z/FX2MKb
  3in48c0UX5t3VjPsmY0CQQCc1jmEoB83JmTHYByvDpc8kzsD8+GmiPVrausrjj4p
  y2DQpGmUic2zqCxl6qXMpBGtFEhrUbKhOiVOJbRNGvWW
  \-----END RSA PRIVATE KEY-----
  `)

  //openssl
  //openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem
  var publicKey = []byte(`
  \-----BEGIN PUBLIC KEY-----
  MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDfw1/P15GQzGGYvNwVmXIGGxea
  8Pb2wJcF7ZW7tmFdLSjOItn9kvUsbQgS5yxx+f2sAv1ocxbPTsFdRc6yUTJdeQol
  DOkEzNP0B8XKm+Lxy4giwwR5LJQTANkqe4w/d9u129bRhTu/SUzSUIr65zZ/s6TU
  GQD6QzKY1Y8xS+FoQQIDAQAB
  \-----END PUBLIC KEY-----
  `)

  // 加密
  func RsaEncrypt(origData []byte) ([]byte, error) {
      //解密pem格式的公钥
      block, _ := pem.Decode(publicKey)
      if block == nil {
          return nil, errors.New("public key error")
      }
      // 解析公钥
     pubInterface, err := x509.ParsePKIXPublicKey(block.Bytes)
     if err != nil {
          return nil, err
      }
      // 类型断言
      pub := pubInterface.(*rsa.PublicKey)
      //加密
      return rsa.EncryptPKCS1v15(rand.Reader, pub, origData)
  }

  // 解密
  func RsaDecrypt(ciphertext []byte) ([]byte, error) {
      //解密
      block, _ := pem.Decode(privateKey)
      if block == nil {
          return nil, errors.New("private key error!")
      }
      //解析PKCS1格式的私钥
      priv, err := x509.ParsePKCS1PrivateKey(block.Bytes)
      if err != nil {
          return nil, err
      }
      // 解密
      return rsa.DecryptPKCS1v15(rand.Reader, priv, ciphertext)
  }
  func main() {
      data, _ := RsaEncrypt([]byte("http://c.biancheng.net/golang/"))
      fmt.Println(base64.StdEncoding.EncodeToString(data))
      origData, _ := RsaDecrypt(data)
      fmt.Println(string(origData))
  }
```

运行结果如下：

go run main.go z7mjbTqVg09F20pVib8TqGpZ3d/dNkYg4Hksai/elXoOJJJRH0YgRT4fqJTzj2+9DaCH5BXhiFuCgPzEOl2S3oPeTIQjEFqbYy7yBNScufWaGhh0YigrqUyseQ7JJR+oWTCZPpMNie/xKg9 vhUqJ7yH3d91v+AexHw7HOcLYHYE=


